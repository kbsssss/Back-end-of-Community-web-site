.
.
.
1.스프링부트 로깅에 대해 본격적으로 들어가기에 앞서 기본적인 내용들과 추가 부수적인 내용들에대해
    한번 정리하고 들어가겠다. 여기에 있는 내용들은 뒤의 2.에서 정리한 내용과 섞여가며 설명을 하겠다. 그래야
    이해가 잘된다.
    (1).log4j, logback, log4j2를 모두 로깅 구현체라고 부르는데 이러한 이유와 slf4j를 로그 모듈들의 추상체이며 인터페이스와
        비슷하다고 하는 이유에 대해 간단하게 이해가 되게 정리해보도록 하겠다. 엄밀히 말하면 slf4j가 완전히 인터페이스와 같은 역활을
        하는것같진 않지만 인터페이스와 비슷한 역활을 한다고 볼 수 있다. @@@@@@@@@@@@@@@2
        .
        그렇기에, 위와같은 이유로 스프링부트의 기본설정인 logback 로깅 프레임워크(로그 라이브러리) 외에도 다른 로그 구현체를 최소한의 설정만
        변경하면 바로 사용할 수 있다고 한다. 또한, 로그를 사용하는 코드에서는 특정 로깅 구현체의 패키지를 사용하지 않기 때문에 즉, 특정 로깅 구현체의
        패키지를 import같은것을 해서 사용하지 않기 때문에 더욱더 다른 로깅 구현체로 바꿔주는게 쉬운것 같다. 즉, 더 얘기하자면 애초에, 로그를 사용하려는
        클래스에서 로거를 생성해서 사용을 하는데 이 로거를 사용하기 위해 실제 import되는 패키지는 slf4j 패키지밖에 없다는 것이다. 즉, 로그를 사용할 클래스에서도
        logback과 같은 로깅 구현체의 패키지를 import하지 않고 이 slf4j만 import하기 때문에 이렇게 클래스에 로그 관련 코드를 작성하고 나서도 다른 로깅 구현체를
        사용하려고 한다해도 해당 클래스에서 추가적으로 변경할 부분이 없기때문에 쉽다는거다. 실제로 기본설정된 logback만 사용해보겠지만 나중에 필요시 log4j2로
        사용하는 경우에 더 자세한 사항들은 그때 보도록 하자. 즉, 정말로 클래스에 적혀진 코드들은 아무것도 안건드려도 되는지 혹은 설정파일은 변경할 것은 없는지에
        관해서는 나중에 실제로 바꿀때 해보자는거다.@@@@@@@@@@@@@
        [참조링크 : ]     
        [참조링크 : ]    
        [참조문헌 : 스프링부트 시작하기 초록책 92pg,94pg]            
        (1-1).우선은 이 아래 코드들
            import org.slf4j.Logger;
            import org.slf4j.LoggerFactory;
            (공간)
            Logger log = LoggerFactory.getLogger(this.getClass());
            를 보면서 얘기해보도록 하겠다. 여기에서 볼것이 굉장히 많은데 하나하나 보도록
            하겠다. 추가로 봐야할것은 어디는 private static final 에 대해서도 추가로 보도록 하겠다.
            [참조문헌 : 스프링부트 시작하기 초록책 107pg] / 위와같이 쓰이는 코드 예시    
            [참조링크 : ]    
            [참조링크 : ]    
        (1-2).동시에, 이 Logger log = LoggerFactory.getLogger(this.getClass());에 대해서 보도록 하겠다. 이 Logger는 인터페이스형이고 LoggerFactory
            는 클래스형인데, 위의 코드를 보면, 이 Logger형 타입선언과 LoggerFactory를 쓰기위해서는 slf4j에 대한 모듈을 import해서 사용해야 한다. 그렇게해서
            Logger형 변수를 선언해주고 LoggerFactory.getLogger()메서드를 이용해서 로거 객체를 갖고오게 된다. 이때 또 알아야 할 것은 LoggerFactory는 생성자주입도 
            아니고, 객체를 대입해준것도 아닌데 그냥 이 자체로 사용이 가능하였었다. 이거는 찾아봐도 안나오고 이 자체로 특수케이스라고 생각하고 넘어가자. 즉, 조금 더 이해를
            하자면, 이 LoggerFactory자체를 해당 형의 인스턴스가 주입된 변수명이라고 이해하는게 맞을것같다. 즉, 이미 이 자체로 코드가 읽히기만 한다면 LoggerFactory의 메서드 같은것을
            사용할 수 있는것이다.(또한, 자바클래스에서 멤버변수에 new ~()로 생성자로 객체주입하거나 아니면 this.메서드()사용해서 멤버변수 값 대입하고 출력 했는데 모두 정상적으로
            적용이 됬었다. 즉, 인스턴스화 할때 코드를 읽는다는것이다. 이정도만 알고 당연히 뒤에서 이것에 대해 더 자세하게 봐야된다면 그때 더 정리하도록 하자.)
            그리고나서 LoggerFactory.getLogger(this.getClass())처럼 사용이 되는데, 우선 여기서 위의 말대로 getLogger()메서드를 사용할 수 있게 되는것이고,
            또 신기한게 원래 이 this는 사실상 사용되는 클래스의 생성자나 메서드안에서 사용이 되는것만 봐왔는데, 위에서 보듯이 멤버변수공간에서도 this가 쓰이는것을
            보았다.(심지어 this.print()로 해당 클래스내의 메서드를 호출해서 그 안에 숫자 3을 System.out.println으로 호출하는거 해봄) 즉, 어떤 클래스를 인스턴스화 
            시킬때 멤버변수쪽 코드를 읽을때 이렇게 this.메서드()로 호출이 가능하다는것을 알았다. 그로인해 해당 클래스가 항상 갖고있는 getClass()메서드를 사용할 수
            있게 되고 this.getClass()의 결과물로 해당 클래스의 자료를 클래스형객체형태로 반환하게 되는거다. 그렇게 되면, 원래는 이 getLogger("~")에 "~"로 적어넣으면
            ~를 이름으로 로거의 이름을 기반으로 로거 인스턴스를 생성해서 갖고오게 되는건데 getLogger(this.getClass())처럼 클래스 객체를 넘겨주게 되면, 로거의 이름이
            해당 클래스형 객체에 담겨있는 클래스 정보의 패키지 이름과 클래스 이름으로 로거 이름이 완성된다고 한다. (ex 마치 "패키지 이름 + 클래스 이름" 이런형태라는거다.)
            근데 이 getLogger()로 로거의 이름을 기반으로 로거 인스턴스를 생성해준다고 했는데, 좀 더 이해가 가게설명하자면 이 로거의 이름에 해당하는것으로 빈이 생성이 되는데,
            빈 이름이 이 '로거의 이름'으로 쓰이게 되고, '형'은 로깅구현체를 무엇으로 쓰냐에 따라 그 '형'으로 지정이 되는것 같다. 만약 중복되었던 로거이름을 적어주면 
            기존에 있었던 해당 이름의 로거 객체를 갖고오게되나보다. 또한, <pattern>같은데도 한번 봐봤는데 여기에서도 로거 객체의 이름을 이용해서 뭔가를 나타내는것은 없었다. 
            딱여기까지만 이해하고 나중에 필요시 더 이해하도록하자. (또한, 아래 설명할거지만 실제 생성되는 로거 객체의 타입은 logback관련 타입일것이다.)
            [직접해봄]    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@여기 파일명 정리할때, 클래스의 멤버변수 필드에 생성자, this.메서드도 사용이 가능해서 코드를 읽는다는거 정리하기
            [참조문헌 : 스프링부트 시작하기 초록책 94pg] / getLogger()에 대한 개념    
            [참조문헌 : 스프링부트 시작하기 초록책 107pg] / 예시코드   
            [참조링크 : https://docs.python.org/ko/3.8/library/logging.html] / .getLogger(~)에서 만약 ~에 같은 이름을 적어주면, 항상 같은 로거 객체를 반환해준다고 한다.    
        (1-3).이제, Logger log = LoggerFactory.getLogger(this.getClass());에서 이 Logger앞에 private static final을 붙이거나
            아니면 private final Logger ~ 처럼 사용하는 경우를 보았다. 여기서 private을 붙이는거는 어떻게보면 당연한게 해당 Logger 인터페이스형이
            변수가 만들어진 클래스의 메서드에서밖에(지금까지 내가봐온바론 그렇다. 나중에 다른경우가 있는경우 더 정리) 안쓰이기에 사실상 해당 클래스 안에서
            밖에 안쓰이는것이기 떄문에 private으로 하는게 맞다. 또한, final의 경우는 자바책을 봤을때 한번 대입이 되면 그 다음은 값을 변경할 수 없게 하는거다.
            사실상, 한번 대입된 로거 인스턴스는 바뀔일이 없기때문에 이것또한 어느 정도 맞다고 생각했다. 아래 final 조금 더 정리)
            [참조링크 : https://goddaehee.tistory.com/206] / private final    
            [참조링크 : https://backtony.github.io/spring/2021/03/23/spring-mvc-0/] private final    
            [참조링크 : https://osc131.tistory.com/120] / private static final   
            [참조링크 : https://kogle.tistory.com/28] / private static final            
            +
            근데, 한가지 직접해본결과 나는 스프링부트 시작하기 초록책 95pg에 나오는것처럼 컨트롤러에서도 했는데, 사실상 여기에는 나는
            @RequiredArgsConstructor을 지정해서 사용도 같이 했었다. 그런데 이거는 final이 붙은 필드의 경우 생성자주입을 해주는데 이
            Logger 멤버변수의 경우는 대입되는 값이 있어서인지 별다른 에러나 아니면 변경된 사항이 없었었다. 이제는 static에 대해 볼것인데
            static 멤버변수는 클래스 내부에 선언하지만, 다른 멤버변수처럼 인스턴스가 생성될 때마다 새로 생성되는 변수가 아니라, 객체를 생성하기
            전에 static 변수는 Static영역에 올라가게되어서 객체를 생성하기전에도 사용할 수 있다고 한다.(클래스도 이 Static 영역에 생성이 되는거고
            new 연산을 통해 생성된 객체는 힙영역에 생성이 되는거다. 그런데 이 힙영역의 메모리는 가비지콜렉터를 통해 수시로 관리를 받지만, Static영역에
            할당된 메모리는 관련 모든 객체가 공유하는 메모리라는 장점을 갖었지만 가비지 콜렉터의 관리 영역밖에 존재하므로 이 Static영역에 메모리를 할당되어서
            사용되어지는 static 지정 멤버변수를 너무 많이 지정해서 사용하게 되면 프로그램의 종료시에만 이 메모리가 해제되기에 되면 시스템의 performance에 악영향을 줄 수
            있다고 한다.) 그렇기에, 매번 객체를 생성해주고 그에 관해 this라는 것도 생성된 객체를 나타내는건데 이런 객체가 생성되어지기전에 static 멤버변수
            코드를 읽어서 static영역에 올리는거니 this라는 예약어는 사용할 수 없는것으로 보인다. 그렇기에 아래 + 참조링크에서도 이 static을 이용해서 로거
            변수를 선언해줄때도 그 안의 코드에 this를 사용하지 않고 그냥 클래스파일명을 적어주었다. 그러나 아래 참조링크들을 추가로 보자면, 보통 이 static
            을 붙여서 멤버변수를 사용하는 경우는 1.자주사용되고, 2.절대 변하지 않는 경우에 static final을 붙여서 사용한다고 한다.(보면 알겠지만 보통
            static만 안쓰고 final을 같이 붙여쓴다.) 그렇게 되면, 매번 객체가 생성될때마다 코드를 읽어서 만들어줄 필요가 없어서 성능향상에 좋다고 한다.
            물론, 이러한 자잘한 로거변수는 성능향상에 큰 도움이 없을 수 있다. 또한, 나중에는 아래 참조링크에 나와있지만, static을 잘못사용하면 굉장히 문제가
            크게 발생할 수도 있다고 하나 이는 쓰레드니 기타 다른 내용에서의 이야기로 보인다. 이거는 나중에 필요하면 다시 보도록 하자. 또한 아래 참조링크
            중 하나는 말이 모호하게 되있는데 static을 자주사용한다고 시스템의 퍼포먼스에 악영향을 주는것보다는 잘못사용하여 에러가 발생하거나 아니면 성능을
            악화시키는일 또는 과도하게 사용하여 메모리가 부족하게 되는 경우가 주 문제로 보인다. 그러니 이 부분은 신경쓰지 말고 나중에 문제가 된다면 다시봐보도록 하자.
            이제 원래 하고자했던 얘기는 그래서 static을 쓸까말까를 얘기할건데 그 얘기는 아래에 추가로 정리하도록 하겠다.
            [참조문헌 : 자바책 181pg]    
            [참조링크 : https://mangkyu.tistory.com/47] / static 멤버변수를 자주쓰면 메모리가 할당된 채로 존재하므로 시스템 퍼포먼스에 악영향을 주게 된다고 한다.
            [참조링크 : https://12bme.tistory.com/94]     
            [참조링크 : https://programmingfbf7290.tistory.com/entry/static-%EC%84%B1%EB%8A%A5]    
            [참조링크 : https://reference-m1.tistory.com/69]    
            [참조링크 : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=software705&logNo=220634319628]    
            [참조링크 : https://sungjk.github.io/2019/03/30/java-performance-tuning-2.html]    @@@@@@@@@@@@ 멤버변수에 final있어도 LoggerFactory처럼 대입해주면 @RequiredArgsConstructor 적용안되나보다. , static멤버변수성능 , Static영역 & 힙영역 ,static멤버변수 this
            +
            여기는 각각 private , private final , private static final을 Logger로 사용하고 있지만, private도 붙이고 
            private final도 붙이고 private static final도 붙여서 사용을 하는데, 아래 @Slf4j와 방금까지 설명한것들을 보면,
            private과 final은 당연히 붙여주는게 좋고, static을 붙이는것도 문제될것이 없고 오히려 긍정적인 효과를 낼것으로 보고
            있다. 또한 @Slf4j에서 기본적으로 private static final와 같은 방식으로 만들어지니 만약에 직접 쓸 일이 있다면, 이렇게
            private static final을 모두 사용하여 해주는게 좋을것으로 보고있다.
            [참조링크 : https://goddaehee.tistory.com/206] / private final Logger ~
            [참조링크 : https://unipiz.tistory.com/4] / private final Logger ~    
            [참조링크 : https://kogle.tistory.com/28] / private static final Logger ~ (~.class)    
            [참조링크 : https://osc131.tistory.com/120] / private static final Logger ~ (~.class)    
            [참조문헌 : 스프링부트 시작하기 초록책 95pg] / private Logger ~     
            +
            추가로 알게된 사실인데 멤버변수를 메서드,생성자에서 그대로 이름그대로 쓸 수 있었다. 그 특유의 파라미터명이 이 멤버변수와 같은
            이름을 쓸때는 못쓰는거고 이럴떄 this.멤버변수명을 쓰는거고 만약 파라미터명과 겹치지 않으면 그냥 그 자체 멤버변수명을 써도 잘
            적용이 됬었다. 또한, 추가로 멤버변수에 다른 멤버변수를 this.멤버변수로 값을 써주어도 정상작동했었다. 그러나 만약에 static을 붙인
            클래스 변수가 있게 되면 우선 위에서 언급했던대로 getLogger(this.getClass());와 같은것은 써주지 못하는 이유가 아직 객체 생성 전이기
            때문에 this가 쓰이는게 불가능한거고 방금 말한거는 이미 객체가 생성되고 나서이기 때문에 가능한거다. 그렇다면 클래스변수를 다른 멤버변수나
            메서드나 생성자에서 사용하려면 어떨까 ? 직접해보니 클래스변수도 멤버변수 다른 변수나 아니면 생성자 혹은 메서드에서 클래스 변수명을
            그대로 사용할 수 있었다. 그러나 this.클래스변수명을 사용하려 할때는 다른 멤버변수나 메서드 혹은 생성자에서는 실제로 사용을 할때
            정상작동은 하였으나 오류를 고치라고 나왔다. 즉, 이 클래스변수는 this.클래스변수로는 왠만하면 사용지 않는게 좋겠다.
            [직접해봄]    
        (1-4).위에 이 Logger에 대해 자세히 설명했으니, 그러면 이어서 @Slf4j와 롬복에 관련해서도 정리하겠다. 이 @Slf4j를 사용하게 되면
            private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(@Slf4j를 쓴 클래스명.class);와 같이 뜨게
            되는데, 여기서 우선 알아야 할 두가지가 이 org.slf4j.Logger와 org.slf4j.LoggerFactory처럼 뜨는것과 클래스명.class로 적혀지게 되는
            것이다. 첫번째로 @Slf4j를 사용하게 되면 org.slf4j.Logger와 org.slf4j.LoggerFActory처럼 코드가 생성이 되는데,
            ㅁ 그거도 알아둬야해 직접해보니 @Slf4j는 org.slf4j.Logger같은 형태로 패키지명을 아예 써서 가져다가 사용하는데
            실제로 내가 BoardService형에 저렇게 패키지명을 써주니까아예 import문을 안썼었다.@@@@
            [참조링크 : https://fntg.tistory.com/200] / @Slf4j를 사용하게 되면 실제 생성되는 코드    
            [참조링크 : ]    
            [참조링크 : ]    
        (1-5).이제 위의 (1-3).에 적어놓았던것을 왜 slf4j가 추상체이며 자바의 인터페이스와 비슷한 역활을하고 logback은 로깅 구현체 중 하나라고
            하는지에 대한 설명과 왜 다른 로그 라이브러리를 사용하더라도(log4j2같은거) 최소한의 설정만 변경하면 바로 사용할 수 있는지, 로그를 사용하는 코드에서도
            왜 특정 로깅 구현체의 패키지를 사용하지 않는지에 대해 정리하겠다. 우선, 아래 logback-spring.xml이 정리된 글을 보면 스프링부트가 가동이 되고 properties
            설정파일을 읽어와서 기본경로인 logback-spring.xml을 읽을지 아니면 다른 경로와 파일명으로 로그백설정파일을 읽어올지 등을 정하며 동시에 properties에서도
            로그백 관련 설정코드가 있으면 적용이 되고 그 다음 로그백 설정파일을 읽어와서 로그백 설정을 한다고 나와있다. 그럼 이 로그백설정과 관련해서는 패키지별로 어느
            로그 level을 정해놓을지 그리고 패키지경로별로 몇개의 로그를 발생시키고 어떠한 형태로 로그를 발생시킬지 어디로 보낼지 관련 설정을 하게 된다. 이런것들은 모두
            로그백에서 설정하게 되고(로그 구현체) 그 이후에 내가 따로 또 로그를 발생시킬 객체 로거를 사용하기 위해서는 Logger라는 slf4j모듈에 속한 인터페이스를 사용을하고
            또한, LoggerFactory라는 slf4j모듈에 속한 클래스로 가져다가 로거 인스턴스를 생성해서 반환하게 해준다. 근데 여기서도 실제 로거 인스턴스가 생성되는 '형'은 로그백
            과 관련된 '형'으로 보고있다. 즉, 실질적인 인스턴스는 이 로그 구현체로부터 만들어지게 되는것이다. 그런다음 자동형변환을 거쳐 Logger형 변수에 대입이 되고,
            debug(),info()와 같은 메서드를 이용해서 로그를 발생시키게 되는거다.(물론, 해당 패키지에 로그level이상만 발생하게 되겠지만 말이다.)
            [직접해봄]    
            [참조링크 : ]    
            [참조링크 : ]    
            +
            즉, 다른 로그 구현체를 사용하더라도 최소한의 설정과 로그를 사용하는 코드에서도 특정 로깅 구현체의 패키지를 사용하지 않는다 했는데, 바로 위의 
            (1-3)과 (1-4)를 보면 실제로, 로그를 사용하는 코드에서도 로깅 구현체에 대한 패키지를 사용하지 않아 import하지 않기때문에, 다른 로깅 구현체를
            사용하더라도 이 코드 부분들에서도 수정할것이 없는것으로 알고있다. 또한, 만약 다른 로깅 구현체인 log4j2를 사용한다 하더라도, 그냥 기존 logback
            관련 의존모듈을 사용하지 않는다 설정해주고, lg4j2의존 모듈을 추가해준다음에 log4j2.xml에가 로그설정파일을 적어주면 되는것으로 알고있다. 그리고
            이 로그 설정파일에도 기존의 로그백설정파일인 logback-spring.xml과 별차이가 없는것으로 알고있다. 그렇기에 그저 의존성설정(1.logback사용안한다.
            2.log4j2의존추가)과 로그설정파일명등만 간단하게 바꾸면 되기에 쉽게 다른 로그 라이브러리로 변경할 수 있다는거다.
            [직접해봄]    
            [참조링크 : ]    
            [참조링크 : ]    
            +
            그리고 Logback, log4j2와 같은 것은 로그 구현체라고 하고, slf4j는 로그 모듈들의 추상체로써 인터페이스와 비슷한 역활을 한다했는데, 여기서도
            사실상 모든 로그 관련 실질적인 설정은 로그백이라는 로그 구현체에서 담당을 해서 설정파일로 설정을 하게되고, Logger가 쓰이는 코드에서도 이 Logger
            는 인터페이스형이고 LoggerFactory는 단순 로거를 생성시켜주는건데 실질적으로 생성된 로거는 이 구현체 관련형이라는것이다. 그렇기에 실질적으로
            이 로거가 발생시키는 로그들도 로깅 구현체에서 하는것이다. 그렇기에, 이 slf4j를 다양한 로그 모듈들의 추상체 혹은 인터페이스와 비슷한 역활을 한다고
            하는것으로 보는것 같다.
            [직접해봄]    
            [참조링크 : ]    
            [참조링크 : ]    
        (1-6).
            [참조링크 : ]    
            [참조링크 : ]    
    (2).우선, 고민을 했었다. logback 스프링부트 기본설정 로깅 구현체를 쓸지 아니면 제일 최근에 나왔다고 하는
        log4j2라는 로깅 구현체를 쓸지 말이다. 실제로 log4j2라는 로깅 구현체는 멀티쓰레드환경에서 다른 구현체와는
        다른 월등한 성능효과를 보였다. 하지만, 기본적으로 스프링부트의 기본 설정은 logback으로 되있고, 이전에도 대부분 logback
        을 써왔었다. 만약에 logback사용으로 성능에 문제가 있거나 바꿔야할 필요성을 느끼게 된다면 그때 다시 log4j2 로깅 프레임워크를
        보도록 하자. 그리고 log4j, logback, log4j2 모두 로깅 구현체이다.@@@@@@@@@@@@@@@@@@@
        [참조링크 : https://huisam.tistory.com/entry/log4j2] / log4j2의 월등한 성능 & 로깅 구현체라 부른다. 
        [참조링크 : https://minkwon4.tistory.com/161] / log4j2의 월등한 성능 & 로깅 구현체라 부른다.
    (3).log4j -> logback -> log4j2 순서로 로깅 구현체가 나왔는데, 여기서 이 3개 각각을 모두 로깅 프레임워크라고
        부른다고 나와있다. 이 외에 다른 참조링크들에서도 모두 로깅 프레임워크라 부른다. 근데 또 아래 참조문헌에는 log4j
        , logback 그리고 log4j2를 모두 로그 라이브러리라고 부르고 있다. 이렇다는것만 알아두고 이 부분에 관해서는 나중에 명확하게
        알아야 할 필요가 있을시에 다시 봐보도록 하자.
        [참조링크 : https://madplay.github.io/post/log4j-logback-log4j2] / log4f, logback, log4j2를 모두 로깅 프레임워크라 했다.    
        [참조링크 : https://junshock5.tistory.com/124] / log4j, logback, log4j2를 모두 로깅 프레임워크라 했다.
        [참조문헌 : 스프링부트 시작하기 초록책 92pg] / 여기서는 log4j와 나머지들 logback, log4j2도 로그 라이브러리라 불렀다.   
    [추가사항]    
        1.로그를 사용하는 이유에 대해 보도록 하겠다. 로그를 사용하는 이유는 크게 두가지다. 바로 서비스 동작 상태 파악과  
            특정 api사용에 대한 통계등에 관해서 그리고 장애파악혹은 이로인한 알람이다. 또한, 수민이가 굳이, 로그를 분석해서
            cs관리를 따로 하려는 규모의 웹서비스가 아니면 사실상 에러만 잡아도 되고 나도 ERROR 레벨로만 로그를 잡아서 사용하려고 한다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://m.blog.naver.com/minjincodi/60063653]    
            [참조링크 : https://ahndding.tistory.com/12]    
        2.ㅁ
.
.
.
2.스프링부트에서 로그를 실제로 사용하기 위한 과정에 대해 설명하겠다.
    (1).우선적으로 의존 모듈 설정에 대해 설명하도록 하겠다.
        (1-1).제일 먼저, spring-boot-starter-web 의존 모듈을 추가해준다면 그 안에 spring-boot-starter-logging이라는 모듈이 있어서
            이것이 자동으로 의존 모듈로 추가가 되는거다. 조금 더 이 spring-boot-starter-logging에 대해 알아보자면, 우선, 이 spring-boot-starter-logging
            안에는 logback-classic과 그 외에 두가지 모듈이 더 있다.(이 모듈들 중에 안에 또 다른 모듈도 있긴하다.) 아래 참조링크를 보면, logback을 사용하려면, 
            logback-classic과 logback-core 모듈을 추가해주어야지 logback을 쓸 수 있는것으로 나와있는데, 실제 이 spring-boot-starter-logging모듈안의 
            logback-classic에 logback-core도 포함되어 있어서 logback-core를 따로 추가해주지 않아도 된다.
            [직접해봄]    
            [참조링크 : https://jeong-pro.tistory.com/154]     
            [참조링크 : https://bamdule.tistory.com/29]    
        (1-2).그리고 spring-boot-starter-aop에 관해서인데, 이게 왜 나오냐면 spring-boot-starter-aop모듈도 추가를 해준다면, spring-boot-starter-web에 포함되어있는
            spring-boot-starter-logging과 동일한 모듈이 spring-boot-starter-aop에도 포함되어 있어서 만약에, spring-boot-starter-web과 spring-boot-starter-aop을 
            둘 모듈 모두 의존 모듈로 추가하게 된다면, 기존에 spring-boot-starter-web에 있던 spring-boot-starter-logging 모듈은 사라지고 spring-boot-starter-aop에
            있는 spring-boot-starter-logging으로 의존 모듈을 추가하게 된다. 직접 해본결과다 이렇게 완전히 겹치는 모듈이 있다면 그 중에 하나를 골라서 한쪽에 있는것을 모듈로 
            추가해주고 다른 모듈에 포함되어있는것은 아예 포함시키지 않는것같다.
            [직접해봄]    
        (1-3).spring-boot-starter-logging 모듈안에 logback-classic모듈말고도 또 두가지 모듈이 더 있다고 말했다.(당연히 어떤 모듈은 그 안에 또 다른 모듈을
            또 포함하기도 한다.) 근데, 이 두가지 나머지 모듈에 대해서는 사실 따로 설명한 참조링크들이 없었다. 그리고 slf4j를 사용하는데 있어서도 따로 모듈을 의존
            대상으로 추가해주지 않는데, 이 spring-boot-starter-logging에 있는 나머지 모듈들이 이 역활들을 해주는것으로 이해하고 있자.
            [직접해봄]    
        [정리]    
            이렇게, spring-boot-starter-aop혹은 spring-boot-starter-web만 추가해주면 로그는(logback 구현체) 그대로 사용할 수 있다.
            [직접해봄]     
    (2).그 다음은 로그를 사용하기 위한 설정파일 혹은 이 설정과 관련된것에 정리 하도록 하겠다.
        (2-1).우선적으로, 순차적으로 적용되는 방식에 대해 알아야 한다. 아래 참조링크들을 보면, 우선적으로 logback(로그백) 관련 설정을
            해야하는데, 보통 스프링부트(스프링에서는 진행하지 않을꺼니 나중에 필요시보고)가 구동하기전에 logback은 설정을 할 설정파일을 자동으로 찾는데, logback내부에서 먼저 
            logback.groovy -> logback-test.xml -> logback.xml 순으로 찾아서 로그백 설정을 한다고 한다.(근데, 이게 resources 바로 아래에서 찾는건지는 안나왔다.) 그런다음에, 
            스프링부트가 구동이되고, 스프링부트에서 로그백 설정을 해주기위해 기본 클래스패스 resources아래에 기본 설정파일명인 logback-spring.xml을 찾아 로그백 관련
            설정을 또 하게 된다.
            [참조링크 : https://jeong-pro.tistory.com/154] / 스프링부트가 구동되기 전 즉, 스프링부트에서 로그백관련 설정 전에 로그백설정을(logback.xml등) 하게된다.    
            [참조링크 : https://supawer0728.github.io/2018/04/07/spring-boot-logging/] / 스프링부트가 구동되기 전 즉, 스프링부트에서 로그백관련 설정 전에 로그백설정을(logback.xml등) 하게된다.    
            +
            여기서 보아야 할 것들이 있는데, 우선 이 스프링부트 가동전에 로그백 자체 내에서 로그백 설정을 하게 된다는것은, 스프링부트 연동으로 설정된것이 아니라서
            만약, 내가 로그백 설정파일을 logback-spring.xml로 안하고 클래스패스에 logback.xml로 파일명을 써놓으면 스프링부트가 구동전에 로그백 내에서 자체적인 설정에서
            이 파일을 가져다가 로그백 설정을 하게 되는것같다. 그런데, 원래는 스프링부트에서는 logback-spring.xml을 사용해서 스프링부트에서 로그백을 구동할 수 있도록 
            지원해줌으로써 프로필이나 application.xml에 설정된 properties등을 읽어올 수 있다고 한다.(이 부분은 나중에 필요시 자세하게 알아보겠지만, 간단하게 말하면 아래 참조링크처럼 
            로그백을 커스텀하거나 추가 기능 설정등을 가능하게 해주는데( logback-spring.xml사용시) 만약에, 이 logback.xml명으로 로그백을 설정하게되면 방금 써놓은 추가기능이나
            로그백 커스터마이즈를 할 수 없다고 한다. 즉, 이해하는 방향이 스프링부트로 연동해서 로그백 설정이 된것이 아니기때문에 한번 logback.xml로 설정된것은 스프링부트에서
            변동시킬 수 없다고 보는게 나을것같다.(만약에 틀릴 시 나중에 다시 정리)
            [참조링크 : https://supawer0728.github.io/2018/04/07/spring-boot-logging/] / logback-spring.xml을 사용하면 프로필이나 각종 properties을 적용할 수 있다.   
            [참조링크 : https://gaemi606.tistory.com/entry/Spring-Boot-logbackxml-%ED%8C%8C%EC%9D%BC-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95] / logback-spring.xml로 로그백설정을 해야 커스텀 할 수 있다고 한다.   
            [참조링크 : https://dadadamarine.github.io/java/spring/2019/05/01/spring-logging-xml.html] / logback.xml로 파일명으로 설정하면 로그백과 스프링부트를 연동해주는 '스프링부트' 설정전에 로그백 설정이 되어서 로그백 관련 제어나 추가 기능설정이 불가한것같다.
            [참조링크 : https://goddaehee.tistory.com/206] / logback-spring.xml을 이용하여 스프링부트가 logback을 구동할 수 있게 지원하며 이를 이용하여 프로필을 이용하고, application.xml에 설정된 properties를 읽어올 수 있다고 한다.
            +
            아래 참조링크를 보면 스프링부트의 로그백 기본 설정방법은 application.properties와 resources/loback-spring.xml
            그리고 resources/logback.xml이 3가지가 있다고 한다. 또한, 스프링이나 자바 프로그램의 경우 logback.xml로 resources디렉토리에
            만들어서 로그백 설정을 한다고 하는데, 여기서도 아마 로그백 커스터마이즈가 안되는것으로 알고있다. 이 부분도 나중에 필요시 더 자세하고
            정확하게 정리하도록 하자.
            [참조링크 : https://yjh5369.tistory.com/483]
            +
            진짜 추가적으로 얘기하자면 아래 참조링크를 보면, profile쓰는것이 나와있다. 아마도, 커스터마이즈란 이런 프로필을 쓰는것으로
            이것을 스프링부트 연동 로그백 설정에서만 사용할 수 있는것으로 보아 로그백 설정파일명을 logback.xml으로하면 이러한 연동에서 주는
            기능을 못쓰지 커스터마이즈 혹은 profile등의 기능을 못쓴다고 하나보다. 나중에 필요시 더 자세하게 보도록 하자.
            [참조링크 : https://m.blog.naver.com/cutesboy3/221933485820]    
        (2-2).부수적으로 알아야 할 것이 만약에 스프링부트에서 로그백을 설정해주는 클래스패스와 설정파일명을 변경하고 싶다면
            아래와 같이 스프링부트에서 적용되어지는 properties파일에 이것만 적어주면 된다. logging.config=classpath:logback/logback-config.xml
            이렇게 적어주게 되면, 클래스패스는 resources안에 logback이며, 설정파일명은 logback-config.xml이 되게 된다. 추가로 이 문장
            위에 #logging config 같은 주석도 적어주면 좋다.
            [참조링크 : https://aljjabaegi.tistory.com/413]    
            [참조링크 : https://coding-start.tistory.com/186]    
        (2-3).위에서 추가적으로 알아야 할 과정이 무엇이냐면, 스프링부트 가동전에 로그백내에서 알아서 로그백관련 설정파일을 찾아서 로그백 설정을 하게되고, 
            그 다음 스프링부트가 가동이 된 다음에, properties 설정파일에서 logging.config=classpath:~ 와 같은 문장이 있으면 읽어서 반영을 하고 없으면 그냥
            기본 클래스패스에 logback-spring.xml설정파일명을 찾아서 로그백 설정을 하게 된다.(이거는 내가 생각한거지만, 나중에 틀릴시에 다시봐보도록 하자.) 근데
            여기서 그 후에 .yml이나 .properties파일에서 로그백 관련설정을 또 읽어가는데(위의 properties설정파일의 logging.config관련과는 다른거로 보는게 좋겠다.)
            , 그렇게 되면 .yml(.properties)에 있는 로그백 설정파일을 적용 후에 xml파일의 로그백 설정을 적용한다고 한다. 자세한 사항은 나중에 .yml이나 .properties로
            로그백 설정을 하게 된다면 알아보면 될 것 같다. 내 생각에는 다시 봐보니, 이 properties에서 로그백 xml설정파일에 관한 logging.config=classpath:~가 있으면
            이것을 적용하고 동시에 로그백 설정이 이 properties파일에 있으면 이것부터 적용하고 나중에 xml파일을 적용한다로 이해하면 될것같다.
            [참조링크 : https://goddaehee.tistory.com/206]    
            +
            .yml이나 .properties로 로그백 설정도 가능하지만, 할 수 있는 기능이 많지 않다고 한다. 그래서 실제 어느 정도
            규모가 있는 서비스를 운영하기 위해서는 xml파일로 설정해 두는것이 좋다고 한다. 또한 스프링부트 시작하기 초록책에서도
            따로 .yml이나 .properties를 이용해서 로그백을 설정하지 않았었다.
            [참조링크 : https://gofnrk.tistory.com/108]    
            [참조문헌 : 스프링부트 시작하기 초록책 93pc]    
        (2-4).그렇다면, 이제 그 다음은 logback-spring.xml설정파일에 대해 알아보도록 하겠다.
            (1).제일먼저 logback-spring.xml파일에 맨 앞에 적혀져 있는 <?xml version="1.0" encoding="UTF-8"?>에 대해
                보도록 하겠다. 이 xml파일 선언부는 79번쯤되는 xml파일 관련 정리문서에 잘 설명되어있다. 여기서는 그보다, 이 xml
                파일이 근본적으로 어떤 용도인지에 대해 알아보겠다. 아래 참조링크를 보니, xml파일은 데이터들을 쉽게 구조화 해서
                전달하기 위해 만들어진 문서 형식이라고 한다. 즉, 데이터를 전송하기 위한 하나의 매게체로 보면 될 것같다.
                [참조링크 : https://hi098123.tistory.com/96]    
                +
                어느 참조링크나 참조문헌을 봐도 이 xml선언부에 standalone을 사용하는것을 못봤다.
                mapper.xml에서도 못봤고, 이것은 그냥 주어진데로 생략해서 사용하고 나중에 더 자세히
                알아야할 때 다시 봐보도록 하자.
                [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/]     
                [참조링크 : https://jeong-pro.tistory.com/154]    
                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
            (2).그 다음은, <configuration>에 대해 보도록 하겠다.
                우선은, 모든 logback-spring.xml파일을 보면 선언부 다음에 항상 이 <configuration>태그가 나왔다. 한 번의 예외도 없이
                나왔다. mapper.xml파일을 봤을때도, <mapper>가 나왔었는데 이와 비슷하게 정리하자면, 이 <configuration> 태그 안에 로그백설정
                관련 태그들을 적어야 적용되는것으로 보인다. 다른 참조링크에 대해 정확히 그렇다고 명시된것은 없지만, 다른 참조링크에서 항상 이 <configuration>
                태그를 쓰고 아래 두 참조링크에서도 <configuration>태그 내에 로그백 설정 태그들에 대해 적어야 된다고 나와있다. 즉, 정리하자면 이 
                <configuration>태그는 스프링부트에서 로그백설정을 하기위해 logback-spring.xml파일을 읽어가 설정할때, <configuration>태그를
                일종의 기준점, 즉 일종의 있어야할 필수 구조중 하나로 보고 이것을 기준으로 긁어가서 이해하는것같다.
                [참조링크 : https://dololak.tistory.com/631]    
                [참조링크 : https://ckddn9496.tistory.com/79]    
                +
                이 <configuration> 태그는 내부에 최대 1개의 root 태그만을 갖고, 0개 이상의 appender와 logger태그를 가질 수 있다고
                한다. 사실 어떻게보면 당연한 이야기지만, 여러 참조링크중에 이러한 얘기가 따로 있어서 정리해 보았다. 나중에 더 자세히 봐야한다면
                그때 다시 알아보도록 하자.
                [참조링크 : https://ckddn9496.tistory.com/79]    
                +
                이 <configuration>태그에는 여태까지 봐왔던거랑 참조링크를보면, 두가지 속성에 관해 나오는데 첫번째 속성은 debug라는것이다.
                이 debug의 값은 false와 true가 있는데, 간단하게 말하면 만약 debug="true"를 작성하게되면, 어떠한 기능이냐면 이 logback-spring.xml
                이라는 설정파일을 분석하는 동안 경고 또는 에러가 발생하면, Logback은 내장 상태 시스템에 의해 콘솔에 내부 상태 데이터를 자동으로 출력
                한다는것이다. 또한, 만약 코드를 작성하는 개발자가 이 내부 상태 수신 코드를 명시적으로 등록할 경우에는 중복을 제거하기 위해 loback의
                자동 상태 출력 기능은 비활성화가 된다고 한다. 즉, 이거는 logback설정파일을 분석할때 경고 또는 에러발생시에 로그를 출력하기위한 기능으로
                이 configuration태그의 속성값으로 설정할 수 있는것 같다. 또한, 콘솔이라 했는데 이것은 나중에 더 제대로 알아야 할 필요가 있을때 다시보도록하고
                우선, debug="true"로 속성 설정값을 설정하고 사용하는게 좋을것같다. 또한, 어딜봐도 이 debug속성의 기본값에 대해서는 나와있지 않은데, 아래
                참조링크를 보면 만약 debug속성값을 false로 사용하고 싶다면 그냥 속성자체를 지우면 된다고 한다. 그러는것보니 기본값은 false인것같다. 이것도
                나중에 더 자세하게 알아봐야한다면 다시 봐보도록 하자.
                [참조링크 : https://ckddn9496.tistory.com/78]    
                [참조링크 : https://kouzie.github.io/spring/logback/#logback-xml-%EC%84%A4%EC%A0%95]    
                [참조링크 : https://pythonq.com/so/logback/24150]    
                [참조링크 : https://ckddn9496.tistory.com/79] / 여기서 configuration파일이란 로그백 설정파일인 logback-spring.xml을 의미한다.
                [참조링크 : https://pythonq.com/so/logback/24150] / debug의 값을 false로 하고 싶다면 제거하거나 false라고 값을 명시해주라고 한다.
                +
                두번째 속성으로는 scan="true"와 scanPeriod="30 seconds"가 있다. 이거는 true로 놓으면 해당 초 주기마다(여기는 30초라고 적어놓았다.)
                logback-spring.xml이 바뀌었는지 검사하고 바뀌었으면 프로그램에서 갱신한다고 한다. 즉, 이 기능은 서버를 재시작 하지 않아도 해당 로그백
                설정파일을 다시 읽어봐 서버를 재시작 하지 않아도 되는 기능이다. scan의 기본값은 false로 보고 있으며, scanPeriod="60 seconds"로 60초
                등 초로 맞춰서 사용할 수 있다. 만약 scan="true"로 맞춰놓고 scanPeriod를 맞춰놓지 않으면 디폴트는 60초라고 한다. 근데, 사실상 ec2 인스턴스에 올리고
                배포하여 사용하는 경우에는 어떻게 서버 재시작을 하지않고 올린다는것인지는 모르겠다. 이것도 나중에 필요하면 다시보고 맨 아래 참조링크에 보면, scan을
                할때 너무 자주 하게 하면 disk io가 증가해서 오히려 부담이 될 수 있다고 한다. 즉, 우선은 이 기능은 사용하지 않도록 하고 나중에 필요시에 사용하도록 하고
                그때 필요한 만큼 다시 더 자세히 보도록 하자. 스프링부트 시작하기 초록책에서도 적혀있찌 않은 속성값이였다.
                [참조링크 : https://jaehyun8719.github.io/2019/05/15/utils/logback/]    
                [참조링크 : https://goddaehee.tistory.com/206]    
                [참조링크 : https://ming9mon.tistory.com/150]    
                [참조링크 : https://linkeverything.github.io/springboot/spring-logging-runtime/]     
            (3).여기에서는, <appender>와 <logger>를 한번에 정리하도록 하겠다.
                (3-1).이 <appender>와 <logger>에 대해서 들어가기전에 먼저 알아두어야 할 것이 있다. 이걸 알아두면 이해하기 더 편할것으로 보고있다.
                    바로 로그는 전부다 발생하고 그걸 형식에 맞게 그 로그들을 갖고오는게 아니라, 애초에 <logger>나 <root>마다, 주어진 조건에 맞는것만,
                    로그를 발생시키고 가져오는것으로 보인다. 아래에 설명하면서 더 구체적으로 봐보도록 하겠다. 일종의 순서를 얘기하자면, 이 로그백 설정들이
                    적용이되고 패키지경로에따라 로그 레벨이 정해지고 그 다음, root나 logger의 name에 따라 additivity를 적절히 적용되어서 해당되는 패키지경로에서
                    지정된 로그 레벨 이상만 로그를 발생시키고 각각 console이나 db등 보내게 되는거다. 근데, 이때 각각의 root나 logger에 지정된 <patter>에 따라
                    로그를 각각 발생시키고 가져가게 되는거다.
                    [직접해봄]
                    +
                    Logback-spring.xml은 <appender>와 <logger>이렇게 크게 두개로 구분된다고 한다. 다른 관련 참조링크들도 그렇고 대부분
                    이렇게 얘기 한다.
                    [직접해봄]      
                    [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0]    
                    [참조링크 : https://goddaehee.tistory.com/206]      
                (3-2).이번엔 <appender>태그에 대해 알아보도록 하겠다.
                    1.우선 이 appender태그의 의미부터 알아야 하는데, 이 loback-spring.xml이 적용되는 방향과 의미하는 바를 먼저 알 필요가 있다.
                        이게 실제로 정확히는 안맞을지 몰라도 이렇게 이해하는게 좋을것같다. 우선, 이 logger는 하나의 태그이자 요소로 이것 자체가 주체가
                        되는게 아니라 하나의 설정인것이다. 그렇게 보고 시작해야한다.
                        이 appender라는 요소 안에는 name과 class라는 속성이 있다. 아래 더 자세히 볼 거지만 간략하게 말하면, appender태그는 마치 logger태그내의
                        <appender-ref>태그의 ref 속성으로 연결시켜주어서 순서가 있을것같지만, 실제로는 이 logger태그와 연결된 appender태그의 속성들을 한꺼번에 적용시키는것이라
                        실제 사용되는것에서는 순서가 없이 각각 요소의 속성들의 기능에 맞게 적용이 되는거다. 이 말을 하는 이유는 아래 <logger>에서 알게 될거다. 본격적으로
                        appender의 속성인 name부터 보자면, 이는 단순히 appender를 나타내는 명칭으로, logger에서 <appender-ref>에서 지정해서 사용하는것이며, class는 발생된로그를
                        갖고와서 콘솔이나 db나 파일로 만들어줄것인지 정하는것이다. 그리고 마지막으로 하위에 있는 <pattern>이라는 요소는 여기에 지정된 값들을 적용을해서 로그를 발생시킬때
                        이 형식에 맞게 로그를 발생시키는거다.
                        [직접해봄]      
                    2.여기서는 appender 태그의 name 속성에 대해 보도록 하겠다.
                        사실은, 이 appender태그의 name속성은 그렇게 크게 의미가 없으나 아래에 보다시피 필수로 적어주어야 한다. 여기에다가
                        name값 즉 이름을 지어주게 되면 logger의 하위요소인 appender-ref요소에서 값을 지정하여 사용하게 되는것이다. 즉, logger와
                        연결시키기 위한 이름작명 정도라고 알면된다.
                        [참조링크 : https://ckddn9496.tistory.com/79] / name속성은 appender의 이름을 명시       
                        [참조링크 : https://gs.saro.me/dev?tn=479] / name속성은 appender의 이름   
                        +
                        아래 나와있는 참조링크들을보면, name속성은 필수로 지정해주어야 한다고 한다. 즉,
                        appender요소의 name속성은 필수로 지정해주어야 한다고 나와있다.
                        [참조링크 : https://goddaehee.tistory.com/206] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                        [참조링크 : https://ckddn9496.tistory.com/79] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                        [참조링크 : https://yjh5369.tistory.com/483] / logger요소의 name속성을 적어주는것은 필수라고 한다.                        
                    3.그 다음은 class 속성에 대해 보도록 하겠다.
                        [참조링크 : ]            
                        [참조링크 : ]    
                        +
                        추가로 아래 참조링크를보면, class속성을 필수로 적어주어야 한다고 나와있다.
                        [참조링크 : https://ckddn9496.tistory.com/79]    
                        [참조링크 : ]    
                    4.그 다음은 <appender>태그의 하위 요소인 <encoder>와 <pattern>에 대해 보도록 하겠다.
                        [참조링크 : ]    
                        [참조링크 : ]    
                (3-3).이번엔 <logger>태그에 대해 알아보도록 하겠다. 
                    1.우선 이 logger태그의 의미부터 알아야 한다. 이 loback-spring.xml이 적용되는 방향과 의미하는 바를 먼저 알 필요가 있다.
                        이게 실제로 정확히는 안맞을지 몰라도 이렇게 이해하는게 좋을것같다. 우선, 이 logger는 하나의 태그이자 요소로 이것 자체가 주체가
                        되는게 아니라 하나의 설정인것이다. 그렇게 보고 시작해야한다.
                        이 logger라는 요소 안에는 name과 level 그리고 하위요소로 <appender-ref> 라는 요소가 있다. 자세히 볼 거지만 간략하게 말하면, level은 내가 
                        설정해놓은 레벨이상의 로그로 구역으로 지정하고, name은 로그가 발생했을시에 해당 범위(name)만큼에서 level에 맞는 로그들만 발생시키고 갖고오게 된다. 
                        좀 더 말하자면, 이 level과 <logger>의 name과 <root>로 적용되어서 만들어져야할 로그의 갯수와는 전혀 독립적인 관계인거다. 서로 독립적으로 생각해야한다. 그런데, 이때
                        <appender-ref>태그의 ref속성값은 <appender>태그와 연결하는것으로 이때 위의 (3-2).에서 말했다시피, <logger>와 <appender>가 적용된 기능들이 한번에 적용되는것이라고 
                        했는데 즉, 위의 <appender>내의 <pattern>에 해당하는 값들이 적용이되어서, 방금 로그들이 발생한다할때 이 pattern의 형식에 맞춰서 발생이 되고 가져오게되는거다. 
                        그리고나서 이 갖고온 로그들을 해당 <appender>요소의 속성중 하나인 class의 값에 맞게 로그들을 보내게 되는거다. 또한, 아래 name에서 더 정확하게
                        다루겠지만, 이 <logger>나 <root>로 name에 해당하는것을 여러개 적용할 수 있다. 자세한것은 아래에서 설명하겠다. 또한, additivity속성도 name에서
                        더 정확하게 하겠다.
                        [직접해봄]    
                    2.여기서는 이 name에 대해 더 자세히 보도록 하겠다.        
                        그럼 이 name의 역활은 무엇이냐는 거다. 이 name에는 값을 넣어주는건데, 무슨 값을 넣어주냐면
                        패키지명을 적어주는거다. 그런데 다른 참조링크에서도 봤는데 풀패키지명을 적어주어야 정상적으로 작동한다.(근데, 그 링크 까먹음..)
                        그리고 실제로도 풀패키지명이 아닌 그냥 디렉토리로 적어서 해봤는데 정상적으로 작동하지 않았었다. 풀패키지로 적으니 정상작동했다.
                        그렇게 패키지명을 적게되면 해당 패키지명 이하 패키지를 일종의 영역인거다. 그렇게 해서 root는 전역이 영역인거고 logger는 해당하는
                        name이하의 패키지가 영역인거다. 근데 이 영역은 logger와 root마다 중복이 될 수 있는것이며 level은 level에서 말했다싶이 독립적으로
                        적용이 되면, 이제 그 패키지별로 지정된 log level의 이상이 발생이되면 이 logger name이나 root가 지정된 갯수만큼 중복으로 로그를 발생시키게
                        되는거다. 이때 로그가 발생이 될때 각각의 logger나 name이 연결된 appender의 pattern에 맞게 생성이 되는거고, 그리고 나서 연결된 appender
                        의 class에 맞게 로그를 보내게 되는거다. 
                        [직접해봄]    
                        [참조링크 : https://jaehyun8719.github.io/2019/05/15/utils/logback/] / name이하 패키지에만 로그를 적용
                        [참조링크 : https://coding-start.tistory.com/186] / name에 애플리케이션 패키지명을 넣는다.    
                        [참조링크 : https://linkeverything.github.io/springboot/spring-logging-runtime/] / name에 애플리케이션 패키지명을 넣는다.    
                        [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/]      
                        +
                        그리고, 어차피 이 logger안의 additivity라는 속성도 있는데, 이것은 logger의 name속성과만 연관된것이니 여기에 정리하도록 하겠다.
                        우선, additivity는 따로 값을 지정해주지 않을경우 기본값은 true이다. 이 true와 false가 의미하는 바는 위에서 root나 logger의 name의 경우
                        로그를 발생시키는 영역의 갯수를 의미하는데 이를 중복되지 못하게 막는것이다. 즉, 만약 root가 있고 logger의 name이 com.celebmine인것과 name이
                        com.celebmine.webservice이렇게 된것 3가지가 있다고 해보자. 그러면, com.celebmine.webservice.~에 해당하는 패키지들에는 이 3가지 영역이 들어가있어서
                        해당 패키지에 level를 충족하는 로그가 발생시에 각각의 영역들의 appender의 pattern에 맞게 로그들이 3번이 발생이되어 전달되게 된다. 근데 만약에
                        이 name이 com.celebmine.webservice에 해당하는 logger의 additivity가 false로 지정해준다면 상위의 패키지에서 지정해준 name이나 root는 해당 additivity를
                        false로 지정해준 logger의 name값의 패키지 이하에는 영역이 침범하지 못하게 되는것이다. 즉, com.celebmine.webservice.~에 로그가 발생해도 이 name이 com.celebmine.webservice
                        에 해당하는것만 로그를 발생하게 한다는것이다. 또한 다른요소들은 additivity를 적용안하고 만약에 com.celebmine이 name값인 logger에 additivity를 false로 해주면
                        이때는 com.celebmine.webservice.~에 로그가 발생하게 되면 name이 com.celebmine인것과 name이 com.celebmine.webservice인것의 두 영역만 로그를 발생시키게 된다.
                        [직접해봄]    
                        [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/]    
                        [참조링크 : https://goddaehee.tistory.com/206] / additivity의 기본값은 true라고 한다. 
                        [참조링크 : https://jaehyun8719.github.io/2019/05/15/utils/logback/]    
                        [참조링크 : https://gs.saro.me/dev?tn=479]    
                        [참조링크 : https://jeong-pro.tistory.com/154]
                        +
                        아래 나와있는 참조링크들을보면, name속성은 필수로 지정해주어야 한다고 한다. 그러나 여기 뿐만이 아니라 즉,
                        logger요소의 name속성뿐만이 아니라, appender요소의 name속성또한 필수로 지정해주어야 한다고 나와있다.
                        [참조링크 : https://goddaehee.tistory.com/206] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                        [참조링크 : https://ckddn9496.tistory.com/79] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                        [참조링크 : https://yjh5369.tistory.com/483] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                    3.이 logger태그에서 level에 쓰이는 것에대해 잠깐 보도록 하겠다.
                        우선, 로그 레벨은 TRACE, DEBUG, INFO, WARN, 그리고 ERROR가 있다. 간략하게 설명하자면, TRACE는 DEBUG보다 좀 더 상세한 정보이고
                        DEBUG는 프로그램을 디버깅하기 위한정보이며, INFO는 상태변경과 같은 정보성 로그 그리고 WARN은 처리 가능한 문제이나 향후 시스템 에러의 원인이
                        될 수 있는 경고성 메시지를 나타낸다. 그리고 ERROR는 요청을 처리하는 중 오류가 발생한 경우 표시한다. 여기서 DEBUG는 운영서버에서는 표시하지 않는다고 한다.
                        또한, 이 level에 값으로 ERROR, WARN, INFO, DEBUG, TRACE가 있는데 특정 값을 넣어주면 해당 로그 레벨 이상의 로그만 출력한다고 한다. 또한, 아래
                        참조링크를 보면 FATAL이라는것도 있는데, 이는 어플리케이션을 종료 상태로 만들 수 있는 경우이다. 즉, ERROR와 다른점은 ERROR는 종료까지 가지 않지만,
                        의도하지 않은 에러를 의미하며, FATAL은 어플리케이션을 종료 상태로 까지 만들 수 있는경우다.
                        [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0] / 로그 레벨에 대하여 & DEBUG는 운영서버에서는 표시하지 않는다.   
                        [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/] / 로그 레벨에 대하여 & 설정하는 로그 레벨 이상의 로그만 출력한다한다    
                        [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/] / FATAL 레벨도 있다.    
                        +
                        그리고, 이 level 속성값이 대문자이거나 소문자여도 상관이 없다. 직접 둘다 해보았고 책에는 대문자로
                        적혀져있고 내가 직접해보니 소문자로도 잘 작동했었다. 그런데 대부분 참조링크에서는 대문자로 쓰니 나도
                        대문자로 쓰는게 더 가독성이 좋아볼일것같기는하다.
                        [직접해봄]    
                        [참조링크 : https://ckddn9496.tistory.com/79]    
                        +
                        그리고, 이 level에 대해서 알아야 할 것이 있는데, logger나 root로 level을 지정하더라도, 이거는 다른 logger의 name속성이나
                        아니면 그 어떠한것도 무관한거다. 그냥 특정 패키지에 level이 지정되고 이 하위 패키지에 logger요소로 또 level을 지정하게 되면, 그냥
                        이건 더 하위 패키지에 level이 지정되있지 않는이상 해당 특정 패키지의 모든 하위 로그 level은 특정 패키지에서 정해준 로그 level을 따라가게
                        되니 한마디로 level을 logger나 root로 적용함으로써 일종의 level영역 표시가 되는거다. 즉, 하위 패키지에서 level을 debug로 하고 해당 패키지의
                        상위 패키지에서 level을 error로 해놔도 해당 하위패키지 바로 위의 패키지까지만 level이 error로 지정이 된다. 이건 root에서 지정해주건 logger에서
                        지정해주건 차이가 없고, 어느 요소에서 level을 지정해주던지 딱 영역별로 level을 지정해주는기능밖에는 없다. 그 외에 다른 기능은 없다. 그렇게해서
                        적용된 logger나 root의 갯수만큼 해당 구역의 로그level 이상의 로그만을 발생시키게 되는거다.
                        [직접해봄]    
                        +
                        즉, 좀만 더 덧붙이자면, 이 level은 additivity나 logger의 name속성 등 이런것과는 전혀 무관한것으로 그냥 패키지명에 따른
                        독립적으로 log level을 지정해주고, 해당 패키지 경로에는 지정된 로그 level에 해당하는 로그만 발생시키게 되는것이다.
                        [직접해봄]    
                        +
                        그리고 이 logger요소의 level속성값을 off로 주게되면, 해당 off가 적용된 디렉토리는 어떠한 레벨의 로그도 발생시키지 않는다는것이다. 이게
                        root에 하고 logger에는 level="debug"로 하던 아니면 logger에 off로 level속성값넣고 그 하위 logger level속성값을 off로 하던 off속성값도
                        똑같이 다른 level속성값과 동일하게 적용이된다. 또한, level을 명시해주지 않으면 debug이상만 나오게 되는데 직접 logger요소에서 해봐서 확인해봤고
                        이것도 off속성값과 마차가지로 다른 level속성값처럼 logger에 적용하던 root에 적용하던 아니면 level이 적용되는 중간에 적용하던 모두 다른 로그 level
                        속성값들과 동일한 성격을 갖었다. 즉, 특정 디렉토리가 level이 없는거로 적용되고 하위 디렉토리가 로그 level이 trace면 이 하위디렉토리는 모두 trace로
                        적용되고 바로 위의 특정 디렉토리까지가 level이 적용안됬으니 debug로 적용된다는것이다.
                        [직접해봄]    
                        [참조링크 : https://benfatto.tistory.com/47] / <logger>요소에서도 level off 사용한다. 
                        [참조링크 : https://ckddn9496.tistory.com/79] / 여기에 logger의 level속성은 필수가 아니고 선택적이라 나와있다.    
                        +
                        위에 name을 정리하다가 추가로 정리하려고 하는데, 이 level은 root는 어차피 전역이니 제외하고 level이 적용된
                        logger에는 필수로 name이 적용되어 있다. 그러면 해당 name의 패키지명을 포함한 하위의 모든 패키지에 level속성을 적용하게되는것이고
                        이것은 additivity와는 별개로 오직 logger에서 어느 name을 써서 어느것이 더 하위패키지에 적용되냐를 따져서 적용하는거다. 즉, 이 level
                        이 적용되는범위는 name에 따라 달렸으며, logger의 name이 더 하위패키지냐에 따라 level이 적용되는것이다. 즉, com.celebmine과 com.celebmine.webservice
                        이렇게 name이 다른 logger가 있으면 com.celebmine.webservice가 더 하위패키지이기 떄문에 여기에 level을 적용시키면 com.celebmine의 name을 가진
                        logger의 level은 적용되지 않고 이것은 additivity와 무관하다는 거다.
                        [직접해봄]    
                   4.마지막으로 이 logger태그의 하위태그인 <appender-ref>태그에 대해 보도록 하겠다.
                        원래는, 스프링부트 시작하기 초록책 93pg에 보면 appender-ref속성으로 logger태그 내에 쓰이도록 나왔는데, 실제로 간혹 참조링크에
                        이렇게 속성으로 쓰인것들이 있었는데, 이거는 제대로 작동하지 않았었다. 이것은 나중에 필요시 다시 보도록 하고 우선은 logger태그의 하위태그로
                        쓰이는 <appender-ref>태그에 대해 정리하도록 하겠다. 이 appender-ref태그의 속성인 ref에는 appender태그의 name값에 해당하는것을 적어주는데
                        그렇게 되면 해당 logger태그는 해당 name을 갖은 appender태그를 참조하게되어 appender태그의 pattern을 적용하고 로그 발생시 appender태그의 class
                        에 해당하는곳으로 로그를 보내게 된다.
                        [참조링크 : https://earth-95.tistory.com/41]     
                        [참조링크 : https://benfatto.tistory.com/47]    
                        [참조링크 : https://ckddn9496.tistory.com/79]    
                        +
                        근데, 이 appender-ref태그의 경우는 <logger>내에서 중복으로 태그를 사용이 가능한것으로 알고있고, 
                        logger에는 0개 이상 appender-ref태그를 적을 수 있다고 한다. 또한, logger내 또는 root태그내에 appender-ref태그를 직접 해보니 
                        appender-ref 태그를 안써줘도 정상작동은 했었다. 즉, 에러가 안났다. 즉, root태그혹은 logger태그에서도 0개의 appender-ref태그를 
                        적어줄 수 있는것으로 보인다. 그렇다면, 여러개의 appender-ref태그를 적어주는것에 관해서가 문제인데, 우선 이 appender-ref태그를 해당
                        logger요소의 속성인 name 경로에서 발생시킬 로그의 수를 의미한다.(당연 각각의 appender-ref에 맞는 appender태그의 pattern도 각각 적용된다.)
                        (또한, 당연히 하위에 logger요소의 name으로 지정된 영역이 있고 additivity여부도 따져주어야 하지만 말이다.) 그렇기에 만약에 <appender> 요소가 2개
                        (각각 A와 B라하면) logger요소나 root요소의 appender-ref에서 ref속성값을 각각 A가 중복되던 B가 중복되던 상관이없다.
                        [직접해봄]    
                        [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/] / 0개 이상의 appender-ref요소를 사용할 수 있다.    
                        [참조링크 : https://goddaehee.tistory.com/206] / root요소, logger요소 모두 여러개 써줌   
                        [참조문헌 : 스프링부트 시작하기 초록책 93pg] / 여기서 내가 변형하여 appender중복해서 사용했는데도 괜찮았다.    
                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@아 그것도 해야해 한 경로에 어디는 info이상만 어디는 error이상만. 근데 이거는 여기서 못하는거아닌가
            (4).이번엔 <root>태그에 대해 알아보도록 하겠다.
                (4-1).우선, root 요소는 전역설정이라고 하는데(추가로 logger는 지역설정이라한다.), 
                    한마디로 모든 패키지에 해당하는 경로를 지정하는것으로 보인다. 그래서 logger요소처럼 name속성이 
                    따로 있는것도 아닌가보다. 두번쨰 참조링크를 보면 root요소는 최상위 패키지에 기본적으로 적용한다고 나와있다. 
                    그리고 root도 그 외에는 logger와 같다고 나와있다.
                    [참조링크 : https://goddaehee.tistory.com/206]        
                    [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0]    
                (4-2).이 root 요소는 속성으로는 하나인 level속성만 사용하는것 같다. 아래 참조링크에 보면, 루트 로거의 속성으로는
                    단 하나 level속성만 허용된다고 나와있다. 이 level에 대해서는 logger요소의 level에 대한것과 아래 실제 사용하는 서비스에서의
                    level에 대해 충분히 정리했으니 그곳을 참고하면 될것같다. 덧붙이자면, 이 level에 값을 넣어주고 logger요소의 level속성값을 무엇을
                    적어주든지 간에 그 logger의 하위 level속성값은 해당 요소의 logger의 level속성값이 적용이 되는거다.(당연, 또 그 하위 패키지명에
                    logger로 level지정해주면 그게 지정이 된다. 그 하위 패키지는) 추가로 다른 참조링크를 보아도 이 root요소에 level속성말고 다른것을
                    쓰는것을 본적이 없다.
                    [직접해봄]    
                    [참조링크 : https://ckddn9496.tistory.com/79]    
                (4-3).신기한것은 이 root 요소의 level속성값에는 OFF라는게 들어갈 수 있는데, 아니면 아예 안적어 줄 수도있다.
                    내가 직접해보니 off로 적어주건 OFF로 적어주건 똑같이 정상작동하였고, 이 OFF나 off의 의미는 어떠한 로그 레벨도
                    설정하지 않는다는것으로 볼 수 있다. 즉, off라고 적어주면 어떠한 로그 레벨도 지정되지 않게된다. 즉, 이 off가 적용된
                    패키지경로에서는 아무 로그도 발생시키지 않는다. 또한 아무것도 level속성값을 적어주지 않게되면, 직접해본결과 DEBUG부터 
                    로그를 출력하게 된다. 즉, level이 debug로 맞춰지는거다. 이는 logger요소에도 똑같으며, 이렇게 아무것도 안적어주어서 level이
                    debug로 맞춰지는것도 똑같이 level끼리 패키지명에 따른 level구분되는것이 똑같이 적용되는거다. 즉, logger에서 하위패키지에 또
                    다른 level지정해주면 거기는 해당 지정된 level이 적용되는거다.
                    [직접해봄]    
                    [참조링크 : https://ckddn9496.tistory.com/79]    
                    [참조링크 : https://benfatto.tistory.com/47] / <logger>요소에서도 level off 사용한다.         
                    [참조링크 : https://www.nextree.co.kr/p5584/] / 여기는 off를 대문자로씀
                    [참조문헌 : 스프링부트 시작하기 초록책 93pg] / 여기는 off를 소문자로씀
                (4-4).이제 이 root 요소의 하위 태그인 <appender-ref>태그와 그 속성인 ref에 대해 보도록 하겠다.
                    이 부분은 위에 logger태그에서의 appender-ref태그에 정리해 놓았으니 여기에서 보도록 해보겠다.
                    [직접해봄]    
            (5).<property>나 <layout>, <file>, <rollingPlicy>, <springProperty>, <springProfile>, <file> 등과 같은경우는
                로그를 파일로 저장할때 쓰거나 아니면 profile을 이용해서 지정하거나 등과같은 역활들을 한다. 그런데, 이러한 추가 태그들
                에 대해서는 나중에 프로필이나 설정파일 사용하거나 아니면 로그를 파일로 저장하거나 등 실제로 필요할 때 알아야 하는경우에
                사용하도록 하자. 다만, 여기서 말한 프로필이나 설정파일 사용이 그 스프링부트에서 logback-spring.xml으로 사용해야지 추가 기능을
                설정할 수 있다는 말이 이것과 연결된다는것쯤은 알고있자. 
                [참조링크 : https://supawer0728.github.io/2018/04/07/spring-boot-logging/]    
                [참조링크 : https://goddaehee.tistory.com/206]    
                [참조링크 : https://pjh3749.tistory.com/262]    
                [참조링크 : https://aljjabaegi.tistory.com/413]    
        [추가사항]    
            1.properties파일에서 주석은 #을 붙여서 주석처리 한다고 한다. 그냥 #을 적게되면 해당줄은 모두 주석으로
                처리 되는것 같다.
                [참조링크 : http://java-wonyoung.blogspot.com/2013/01/properties.html] / 개념    
                [참조링크 : https://aljjabaegi.tistory.com/413] / 예시
                [참조링크 : https://coding-start.tistory.com/186] / 예시
            2.이 위에서 클래스패스(classpath)가 언급되어서 얘기해보도록 할텐데, 우선 이 클래스패스의 개념부터 보도록 하겠다.
                클래스패스란 말 그대로 클래스를 찾기위한 경로이다. 즉, 자바에서도 동일한 의미로 사용이 되는데 JVM이 프로그램을 실행할 때,
                클래스파일을 찾는 데 기준이 되는 파일 경로를 클래스패스라고 하는것이다. 근데, 그러면 궁금한거는 클래스패스에서 xml파일을
                읽어간다고 위에 보면 나와있는데, 이게 꼭 클래스패스라고 클래스파일만 찾아 읽어가는게 아니라, 다른 xml파일같은것도 이 클래스패스를
                기준으로 읽어갈 수 있는것같다.
                [참조링크 : https://effectivesquid.tistory.com/entry/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%8C%A8%EC%8A%A4classpath%EB%9E%80] / 클래스패스 개념    
                [참조링크 : https://mkil.tistory.com/385] / 클래스패스(classpath)에 위치한 xml파일을 읽어간다.    
                +
                추가로, 외부설정파일인 properties파일에도 classpath(클래스패스)가 나오는데 여기서도 resources바로 아래가 클래스
                패스라고 나와있다. 여기서도 이 클래스패스라는 경로를 나타내는 명을 가져다 쓰는것 같다.
                [직접해봄]    
            3.xml파일에서는 주석을 사용할 수 있는데, <!-- ~ -->처럼 작성하여서 이 ~안에다가 적어서 주석을 완성시키는것이다.
                그러나, 아래 참조링크에보면 ~ 안에 --는 적어서 넣을 수 없다고 한다. 또한, xml선언부 다음에 태그를 작성해야지
                정상적으로 적용이되고 에러가 나지 않는다고 한다.
                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
                [참조링크 : http://www.devkuma.com/books/pages/1224]    
            4.아래 참조링크를 보면, logback-spring.xml에 작성을 할때 대소문자를 구별하지 않는다고 한다. 즉, <logger>를 <LOGGER>와
                같은것으로 본다는거다. 또한, 아래 참조문헌에 보면 이상하게 <Patter>만 이렇게 대문자로 시작하고 있다. 나는 직접해봤는데
                이거를 <patter>으로 하던지 상관없이 정상적으로 작동했었다. 그리고 어딘가 참조링크에서는 camel 낙타표기법으로 적으라 하는데
                그거는 나중에 필요하거나 정리를 해야할 시에 다시 봐보도록 하자.
                [직접해봄]    
                [참조링크 : https://goddaehee.tistory.com/206]    
                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
            5.원래는 아래 참조링크를 보니, HTML이나 XML모두 시작태그와 종료태그가 있으면 상관없으나 만약 시작과 종료를 한꺼번에 표현해야하는
                태그면 해당 태그 끝에 "/"를 붙여주어야 하는것같다. 잘 보면, <br>과 같은것도 그런데, 사실 html은 이러한태그에 /를 필수적으로 붙여주지않더라도
                에러가 나지 않고, 오히려 이게 / 있는게 더 어색한 경우가 많다. 그러나 아래 참조문헌에 보면 <appender-ref ref="console"/>와 같이 xml에서는 이를
                반드시 지켜주지 않으면 에러가 나고 정상적으로 작동하지 않는것 같다. 만약 더 자세히 알아봐야 한다면 그때 다시 봐보도록 하자.
                [직접해봄]    
                [참조링크 : https://ehpub.co.kr/html5-6-%EC%95%88%EC%A0%84%ED%95%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9C%84%ED%95%B4-br-%ED%83%9C%EA%B7%B8%EC%97%90-%EC%A2%85%EB%A3%8C%EB%A5%BC-%ED%91%9C%EC%8B%9C%ED%95%98%EC%9E%90/]    
                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
            6.직접 해본건데, <appender>와 <logger>의 경우 이 태그를 적는 순서도 따져야 한다. 실제로 <appender>보다
                이 <logger>태그가 뒤에 있어야지 정상적으로 작동이 된다. 실제로 <logger>를 <appender>보다 앞으로 가져가니
                아예 에러가 발생했었다.
                [직접해봄]    
                [참조링크 : https://gs.saro.me/dev?tn=479]
.
.
.
3.실제 스프링부트에서 사용될때의 지식에 관해서 설명하도록 하겠다.
    (1).우선, LEVEL에 대해서 말해보도록 하겠다.
        (1-1).우선 LEVEL에 대한 기본 설명은 위에서 해놓았다. 근데, 실제 사용에서는 이 LEVEL을 어떻게 사용하느냐이다. 우선,
            간단하게 결론만 말하면, ERROR와 INFO만 로그로 기록해서 사용한다고 한다. 그 상세한 이유에 대해서는 아래에 설명하도록 하겠다.
            그리고 TRACE는 사용하는 경우를 못봤으며, DEBUG의 경우 개발하는 경우에 로그를 설정해서 사용하다가 실제 서비스에는 INFO와
            ERROR만 사용한다고 한다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://ahndding.tistory.com/12]    
            [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0] / DEBUG는 개발때에만 사용하고 실 서비스에서는 사용하지 않는다.    
            +
            우선적으로, FATAL이란것도 위에서 말했는데 왜 쓰지 않냐면, FATAL은 어플리케이션을 종료 상태로 만들 수 있는경우이며,
            ERROR와 FATAL이 가지는 공통적인 목적은 '의도하지 않은'이다. 그리고 이미 FATAL로그가 생길만한 일이 있으면 어플리케이션이
            중단이 되고 다양한 원인으로 작성되지 않을 확률이 다분하기에 이 경우는 사용하지 않고 대부분 ERROR로 적는것을 추천한다고 한다.
            또한, 내가 사용하는 logback은 FATAL레벨이 없다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://ahndding.tistory.com/12]    
            [참조링크 : https://luvstudy.tistory.com/133] / logback은 FATAL레벨이 없다고 한다.
            +
            이제 INFO로그에 대해 볼건데, INFO로그는 ERROR와는 조금 다른데, INFO는 서비스 시나리오나 요구사항에 사용한다고 한다. 즉,
            서비스의 목적을 달성했는지 분석하는 용도가 첫번째인데 이는 그냥 서비스가 정상작동하냐를 말하는것이고, 두번째는 요구사항으로 이는 외부
            API 호출을 로그로 관리하여 대략적인 통계로 활용한다는것이다. 또한, 예외가 발생했을떄도 이 INFO로그로 출력할 수도 있는데 그러한 경우에는
            내가 일부로 특정 예외를 사용하고 의도한 예외인 경우에는 INFO로 한다. 아래 참조링크에는 이에 해당하는 예시가 있다. 여기서 예외를 의도적으로
            사용하고 있다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://ahndding.tistory.com/12]    
            +
            추가로 WARN같은거는 동작에는 문제 없지만 나중에 에러가 발생가능한 경우를 의미하는데 이를 측정이나 기준이 있을까
            이느냐이며, 굳이 WARN일 떄도 알람을 제공해야하나이다. 또한, TRACE는 사용하는 로그의 의미가 없는것으로 알고있다. 그 외에
            DEBUG는 주로 개발할때 디버그용으로는 많이 사용하고 있지만 실제서비스에서는 DEBUG 레벨은 사용하지 않는다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0] / DEBUG는 개발때에만 사용하고 실 서비스에서는 사용하지 않는다.
            [참조링크 : https://velog.io/@ehdrms2034/%EC%8A%A4%ED%94%84%EB%A7%81-Boot-%EB%A1%9C%EA%B9%85-Logging] / DEBUG는 개발때에만 사용하고 실 서비스에서는 사용하지 않는다.   
            [참조링크 : https://ahndding.tistory.com/12]    
        (1-2).위의 (1-1).을 바탕으로 그래서 원래 실 서비스에서는 주로 INFO와 ERROR가 쓰이고 개발할때는 DEBUG도 같이 쓰이게 되는거다.
            그러나, 내가 서비스하려는것의 목표는 사실상 서비스가 정상작동하는지등의 시나리오나 요구사항 즉, 특정 api에 대한 통계 수치를 사용하진 않을것이다.
            이것은 주로 cs에서나 하는것으로 나는 ERROR로그만 잡아서 사용할 것이다.
            [직접해봄]    
    (2).sentry에 대한것
        [참조링크 : ]   
    (3).aop나 아니면, controlleradvice에 해당하는것.
        [참조링크 : ]              
.
.
.
4.
.
.
.
5.
.
.
.
[추가사항]
    1.System.out.println() 사용에 대해서 정리하도록 하자. 우선, 개발단계에서는 이 System.out.println을 많이
        사용하곤한다. 하지만, 이것을 사용하게되면, 굉장한 성능저하가 오기때문에 실제 서비스에서는 사용하지말아야한다고 한다.
        그 이유는 간략하게 이해만 되게 설명하자면(정확히는 아닐 수 있다.) System.out.println()메서드를 사용하게 되면 이 메서드는
        리소스를 많이 차지하게 되고, 그로인해 CPU를 많이 점유하기때문에 성능이 매우 떨어진다고 한다. 이 System.out.println()을
        파일이나 콘솔에 찍을때 완전히 출력되거나 저장할때까지 어플리케이션의 대기시간이 발생한다고 한다. 만약에 더 자세하게 많이
        알아야 한다면 그때가서 다시 정리하도록 하자.
        [참조링크 : https://ram2ram2.tistory.com/7] / System.out.println은 리소스를 많이 먹는다.   
        [참조링크 : https://donggov.tistory.com/53] / System.out.println은 리소스를 많이 먹는다.   
        [참조링크 : https://programmer93.tistory.com/46] / System.out.println은 IO리소스를 많이 먹는다.    
        [참조링크 : https://blog.fitz.software/81] / System.out.println은 CPU를 많이 점유하여 성능이 매우 떨어진다.    
        +
        그래서 실제 사용에서는 System.out.println()으로 로그를 사용하지 않고, 그 외의 용도로도 사용하지 않고 로그를
        남기는거에서 logback이나 다른 로깅 구현체등을 사용하게 되는것이다.
        [참조링크 : https://donggov.tistory.com/53]    
        [참조링크 : https://m.blog.naver.com/minjincodi/60063653]        
    2.https://enai.tistory.com/36 String 을 +로 연결@@@@@@@@@@@@@@@@@@