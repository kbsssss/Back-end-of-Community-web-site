SQLYOG사용법
.
1.커서에 따른 쿼리 실행
    아래 참조링크에 새로운 검사 편집기가 (나)에 해당하는 버튼인데, 이게 바로 쿼리
    편집기이다. 이 쿼리 편집기에서 쿼리문을 작성하고 쿼리를 실행하려 할때 두가지 방식이 있다.
    (다)에 해당하는 커서가 위치한 곳의 쿼리 하나를 실행하거나(F9), 모든 쿼리를 실행시키는 (라)버튼
    이 있다.(Alt + F9)
    [참조링크 : https://offbyone.tistory.com/57]
    +
    이 커서가 위치한 곳의 쿼리 하나를 실행한다의 내용인데(F9, 참조링크의 (다)) 
    실제 커서의 위치에 따라 이 F9를 눌렀을때 실행하는 쿼리가 달라진다.
        (1).커서가 스페이스로 인한 빈 공간이던, 엔터로 인한 줄바꿈이던 이런건 중요하지 않고
            만약에 이 스페이스나 엔터의 줄바꿈의 공간에 있으면(쿼리문 안에 있는게 아닌 쿼리문 사이에)
            어느것도 게의치 않고 바로 다음에 오는 쿼리문을 하나 실행한다. 또한 쿼리문 하나의 개념을
            아래에서 설명해주겠다.
            [직접해봄]
        (2).또한 커서가 쿼리문 사이에 있거나 더불어 쿼리문 맨끝(쿼리문을 구분해주는 세미콜론 앞)에 놓아도
            해당 쿼리문 사이에 있는거로 치고 사이에 속한 쿼리문을 실행한다.(그 쿼리문만)
            [직접해봄]   
        (3).마지막으로 모든 쿼리문의 맨끝에 커서가 위치하면, 즉 마지막 쿼리문의 세미콜론 다음으로
            커서가 위치하게 되면, f9를 눌러도 어떠한 쿼리도 실행되지 않는다.
            [직접해봄]   
    [추가사항]
        1.블록도 있다. 보니까,
            SHOW VARIABLES LIKE 'c%';         
            CREATE TABLE t_boardaa2baddbaa222a(
            	board_idx INT(11) NOT NULL AUTO_INCREMENT COMMENT '글 번호',
            	title VARCHAR(300) NOT NULL COMMENT '제목',
            	contents TEXT NOT NULL COMMENT '내용',
            	hit_cnt SMALLINT(10) NOT NULL DEFAULT '0' COMMENT '조회수',
            	created_datetime DATETIME NOT NULL COMMENT '작성시간',
            	creator_id VARCHAR(50) NOT NULL COMMENT '작성자',
            	updated_datetime DATETIME DEFAULT NULL COMMENT '수정시간',
            	updated_id VARCHAR(50) DEFAULT NULL COMMENT '수정자',
            	deleted_yn CHAR(1) NOT NULL DEFAULT 'N' COMMENT '삭제 여부',
            	PRIMARY KEY (board_idx)
            ); // 이 부분
            SHOW VARIABLES LIKE 'c%';  
            와 같은 쿼리문들이 있을때, CREATE부터 '// 이부분' 이라고 적혀져있는데까지 
            블록을 하고 F9을 누르니 이 부분만 쿼리가 실행되었다. 
            [참조문헌 : https://m.blog.naver.com/50after/220882981264]   
            [직접해봄]
        2.쿼리 편집기에 쿼리문이 한개만 있는 경우, 커서의 위치가 쿼리문의 세미콜론; 다음에 있다고 하더라도
            나머지 하나만 있는 쿼리문을 실행한다.
            [직접해봄]
.
.
.
2.하나의 쿼리문은 ';'로 구분한다.
    (1).말 그대로 하나의 쿼리문은 세미콜론으로 구분하는데, 예시들로,
        show variables like 'c%';(aws책 288pg)와 아래 참조링크에서 나온것으로
        use mysql; , show databases; 등이 있다. 또한, CREATE TABLE 테이블명( ~);
        도 결국에는 세미콜론(;)으로 마무리 지어진다.(스프링부트 시작하기 책 54pg) 
        [참조링크 : https://m.blog.naver.com/50after/220882981264]
    (2).세미콜론; 여부에 따른 쿼리문 실행
        쿼리문1; 쿼리문2; 처럼 되있을때 만약에 쿼리문1의 세미콜론이 없다면, 커서를 쿼리문2;에 두건
        쿼리문들 마지막에 두건, 어디에 두건, 무조건 쿼리문 에러가 나타난다.
        [직접해봄]
        +
        그러나, 쿼리문2의 세미콜론을 없애더라도 커서를 쿼리문1에 놓으면 쿼리문1이 실행되고, 쿼리문2에 두면 쿼리문2가
        실행되며, 쿼리문2의 맨마지막에 쿼리문2범위에 포함되지않는 부분에 커서를 두더라도, 쿼리문 실행하면
        쿼리문2가 실행된다. 즉, 마지막에 위치한 쿼리문에 대해서는 세미콜론이 없더라도 에러가 안나고, 심지어 마지막
        쿼리문의 범위 밖의 마지막에 커서가 위치해도 마지막 쿼리문을 실행한다는거다.
        [직접해봄] 
    
.
.
.
3.객체 브라우저는 쿼리문을 실행하고나서 F5를 누르거나, 아래 참조링크의 (바)에 해당하는
    객체 브라우저를 새로고침하는 키를 눌러주어야 한다. Sqlyog를 켰을때, 왼쪽에 테이블과 데이터베이스가
    나타나는 창을 객체 브라우저 창이라 하는데, 쿼리문을 실행하고 반영된 결과를 객체 브라우저에서 보려면 
    F5키를 눌러서 새로고침해야 한다고 한다. 카톡에도 물어보니 보통 이렇게 사용한다고 한다.
    +
    그러나, 데이터베이스 생성시에는 f5로는 객체 브라우저창에 뜨지 않는다.
    이 경우는 다시 연결해서 사용해야 한다.
    [참조링크 : https://offbyone.tistory.com/57] // (가)~부터 설명되있는것.
    [참조링크 : https://m.blog.naver.com/50after/220882981264]
.
.
.
4.쿼리문의 대문자 소문자의 내용
    (1).우선 먼저 테이블명과 데이터베이스명부터 하겠다.
        테이블명과 데이터베이스명은, MySql에서는 윈도우에서는 대소문자 구분이 안되는데,
        리눅스나 유닉스계열에서는 대소문자 구분을 한다고 한다. 그이유는 파일명과 데이터베이스명이
        디렉토리와 파일명이기 때문이다. 그리고 내가 사용하는 MariaDB도 리눅스나 유닉스계열인것같다.
        구분해주어야 하니. 만약 이부분 필요하면 나중에 다시보자.
        +
        기본적으로, lower_case_table_names의 값에 따라 데이터베이스나 테이블을 다르게 저장하는데
            {1}.lower_case_table_names의 값이 0인경우
                CREATE TABLE이나 CREATE DATABASE실행시 테이블명과 데이터베이스명을 대소문자를 구분해서 생성한다.
            {2}.lower_case_table_names의 값이 1인경우
                CREATE TABLE이나 CREATE DATABASE실행시 테이블명과 데이터베이스명을 모두 소문자로 생성한다.
                대문자로 생성시에는 이를 소문자로 변경하여 처리하기에 기존에 대문자가 포함되어 생성한 테이블과 데이터베이스는
                문제가 될 수 있다.
                +
                즉, 기존에 lower_case_Table_names값이 0일때 대소문자 구별이 있게 생성한 테이블이든 데이터베이스든
                생성이 되있으면 lower_Case_table_names의 값을 1로 바꿔도 기존의 것들은 대소문자를 구분하기에 이 마저도 
                없애려면 기존의 대문자들을 모두 소문자로 바꿔주어야 한다.
            {3}.lower_case_table_names의 값이 1인경우
                이는 아직 알 필요가 없을것같다. 
        lower_case_table_names의 값은 SHOW VARIABLES LIKE 'lower_case_table_names';의 쿼리문을
        통해서 확인할 수 있다. 만약 숫자를 바꾸고 싶으면 설정방법은 아래 참조링크에 자세히 나와있다. 그리고
        아무설정안했을때의 lower_case_table_names의 기본값은 0이였다.
        +
        lower_case_table_names값을 1로하는것보다는 그냥 기존의 0값으로 대소문자 구분해서
        사용하는게 좋을것 같다. 또한, 테이블명이나 데이터베이스명은 소문자로 적어주는게 좋을것같다고 한다.
        이 부분은 다른 예약어등이 대문자이니 그런것같다.
        [참조링크 : https://roqkffhwk.tistory.com/91]   
        [참조링크 : https://www.lesstif.com/dbms/mysql-14745775.html]   
        [참조링크 : https://runtoyourdream.tistory.com/22] / 테이블과 데이터베이스는 소문자로 적는게 좋다. 
    (2).컬럼명은 대소문자 구별하지 않는다. 즉, 다시말하면 컬럼명을 test로 저장하던, Test로 저장하던
        똑같은 컬럼명이라 여겨서 테이블생성때 오류가 난다. 그러기에 속성명도 되도록 소문자로
        쓰도록 하자.
        [직접해봄]
    (3).예약어(CREATE, TABLE, DATABASE같은거나 INT TEXT VARCHAR같은 데이터타입이나 DEFAULT NULL, COMMENT나 
        NOW()와 같은 MySql함수같은것등등..)의 경우에는 모두 대문자로 써주는게 좋다. 실제로 예약어 같은데서 대소문자를
        구분하지 않아도 논리에 영향을 주지 않지만, 쿼리문들의 가독성을 높이기 위함으로 대문자로 써준다고 한다.
        예약어를 대문자로 적어주는 이유
            1.가독성
            2.속도처리
                ->이 부분에 대해서는 나중에 필요하면 더 알아볼 필요가 있지만, 대략적으로
                대문자든, 소문자든 일관되게 쿼리문을 짜면 문제가 없을것으로 보인다. 나중에 필요시
                다시보도록하자.
        [참조링크 : https://runtoyourdream.tistory.com/22] / 예약어의 경우 대문자가 일반적이고, 테이블명 컬럼명등은 소문자로 구분되게 적어주기
        [참조링크 : https://stackoverrun.com/ko/q/2466528]    
        [참조링크 : http://www.gurubee.net/article/61534] / 쿼리문 대문자 소문자 속도
    (4).문자열의 저장되는 데이터의 경우는 대소문자를 당연히 구분하여 저장한다.
    (5).BINARY예약어에 대해 알아보겠다. 순차적으로 이해하자.
        {1}.BINARY를 쓸수있는 방법은 여러개다. 또한 LIKE문과도 쓸 수가 있다.
            1.WHERE BINARYㅁ필드명 = '키워드'; -> 여기서 ㅁ쓰여진부분 반드시 띄워서 써야한다.
            2.WHERE BINARYㅁ(필드명) = '키워드'; -> 여기서 ㅁ쓰여진부분 띄우거나 붙여도 상관없다.
            3.WHERE 필드명 = BINARYㅁ'키워드'; -> 여기서 ㅁ쓰여진부분 띄우거나 붙여도 상관없다.
            4.WHERE 필드명 = BINARYㅁ('키워드'); -> 여기서 ㅁ쓰여진부분 띄우거나 붙여도 상관없다.
            +
            추가로, LIKE 예약어를 사용하는곳에서도 완전히 똑같이 사용할 수 있었다. 위에서 1번에서처럼 LIKE에도
            WHERE BINARYㅁ필드명 LIKE ~와 같이 ㅁ가 띄워져있어야 하고 나머지도 LIKE안쓸때와 사용법이 같았다.
            +
            이에 대한 이해 설명은 아래 {2}에서 하겠다.
            [직접해봄]   
            [참조링크 : https://zetawiki.com/wiki/MySQL_%EB%8C%80%EC%86%8C%EB%AC%B8%EC%9E%90_%EA%B5%AC%EB%B3%84]   
            [참조링크 : https://limjunyoung.tistory.com/130]    
            [참조링크 : https://tipland.tistory.com/51]  
            [참조링크 : https://dalgoo.tistory.com/39]   
        {2}.binary라는 예약어를 쓰면, select할때 대소문자를 구분하여 보여주게 되는데, 여기서 대략적으로 알아야할게
            이건 내 방식대로 아는거지만, 이전에 where해서 like를 사용하던 사용하지 않던, 다 소문자로 바꿔서 비교한다는
            해석으로 하였다. 물론 틀렸을수도 있지만 일시적으로 이해하기 위해서다. 여기서는 필드명이나 그 키워드(아래예시)
            SELECT * FROM 테이블명 WHERE 필드명 = BINARY '키워드';와 같이 쓸때, 이해하는 관점에서 보면 이 대문자 소문자들을
            있는그대로 보고, 테이블내에 있는 값들도 소문자로 안바꾸고 있는그대로를 비교하는것같다.
            그리하여, 대문자와 소문자가 정확히 일치하는것만 결과에 표시한다.
            +
            또한, 아래 참조링크에는 인덱스와 키와 연관된 것은 필드명 옆에 BINARY예약어를 함께쓰면 오류가 난다고 하니
            되도록 LIKE에서나 LIKE를 안쓰는데서나 키워드옆에 BINARY를 붙여서 쓰도록하자. 이 부분에 대해 더 알아야한다면
            그때가서 다시보자
            +
            또한, 필드명옆에 BINARY붙이는거나 키워드 옆에 BINARY붙이는거 혹은 BINARY를 그냥 쓰거나 BINARY를 쓰고
            ()로 필드명이나 키워드를 감싸는거나 구체적인것에 대해서는 나중에 필요시 다시 보도록하자. 구글링을 해도
            잘 나오지 않는다. 결론적으로 LIKE여부상관없이 키워드 옆에 BINARY를 쓰도록하자.
            [참조링크 : http://www.webmadang.net/database/database.do?action=read&boardid=4003&page=1&seq=33]   
        [추가사항]   
            WHERE에 쓰이는 like와 % 그리고 like가 안쓰였을때에 관한 기본 내용에 대해 알아야 한다.
                1.like가 안쓰이고, WHERE 필드명='특정문자열'; 인 경우
                    이 경우, 반드시 필드값이 특정문자열과 정확히 일치하는것만 보여준다. 이때 소문자 대문자 상관없이
                    보여준다. 이때, 특정문자열에 소문자를 넣던 대문자를 섞던 상관없이 테이블의 스펠링만 일치하면 모두 보여준다.
                    [직접해봄]
                    +
                    추가로 문자열을 검색하는거면 당연히 ''를 특정문자열에 감싸야 오류가 안나고 만약에 int타입을 검색하는경우
                    예를들어 int데이터타입의 값3을 검색하는경우, WHERE num=3;, WHERE num='3'; 이 두 경우 모두다 num의 값이
                    3인 경우의 결과를 보여준다. 내 생각에 값을 insert할때도 num=3이나 num='3'둘다 오류가 안나고 잘 값이 들어갔는데
                    그 이유는 개인적으로 문자열인 ''이더라도 데이터타입이 int형이면 이를 int형으로 바꿔서 넣는것같다. 그렇기에 이
                    값을빼내서 dto객체에서 쓸때도 int형 타입에 값이 적절히 대입이된다. 즉, 이를 봤을때, select로 검색할때도,
                    WHERE num=3; 이던 WHERE num='3'이던 num의 데이터타입이 int형이면 이를 int형으로 바꿔서 검색해주는것같다.
                    [직접해봄]
                2.like가 쓰이는경우, 
                    (1).WHERE 필드명 LIKE '%특정문자열'
                        이 경우, 필드값이 무조건 특정문자열로 끝나는것만 보여준다. 이때 소문자와 대문자
                        상관없이 보여준다. 여기서도 마찬가지로 특정문자열에 소문자를 넣던 대문자를 섞던 상관없이 테이블의
                        스펠링만 일치하면 모두 보여준다. 또한 당연히 ''를 붙여야 한다. 문자열이니. 안붙이면오류난다.(''감싸서 써줘야함)
                        [직접해봄]
                    (2).WHERE 필드명 LIKE '특정문자열%'
                        이 경우, 필드값이 무조건 특정문자열로 시작하는것만 보여준다. 이때 소문자와 대문자
                        상관없이 보여준다. 여기서도 마찬가지로 특정문자열에 소문자를 넣던 대문자를 섞던 상관없이 테이블의 
                        스펠링만 일치하면 모두 보여준다. 또한 당연히 ''를 붙여야 한다. 문자열이니. 안붙이면오류난다.(''감싸서 써줘야함)
                        [직접해봄]
                    (3).WHERE 필드명 LIKE '%특정문자열%'
                        이 경우, 필드값이 앞뒤중간 상관없이 존재하기만 하면 보여준다. 이때 소문자와 대문자
                        상관없이 보여준다. 여기서도 마찬가지로 특정문자열에 소문자를 넣던 대문자를 섞던 상관없이 테이블의 
                        스펠링만 일치하면 모두 보여준다. 또한 당연히 ''를 붙여야 한다. 문자열이니. 안붙이면오류난다.(''감싸서 써줘야함)
                        [직접해봄]   
                [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=hongsun1992&logNo=220680537524&proxyReferer=https:%2F%2Fwww.google.com%2F] / 여기 '붙이다 만거는 오타다.'                      
                [참조링크 : https://bactoria.tistory.com/entry/MySQL-like%EB%AC%B8-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90-%ED%8F%AC%ED%95%A8%EB%90%98%EC%96%B4%EC%9E%88%EB%8A%94%EC%A7%80-%EA%B2%80%EC%83%89]    
    [추가사항]
        예약어,테이블,데이터베이스명,컬럼명 등을 어느 곳에서는 소문자만 쓰고 어느곳에서는 대문자만
        쓰고 등등을 할 수 있지만, 이는 아래 두가지와 같은 이유로
        1.쿼리문 가독성
        2.속도처리(이 부분은 아닐수도있다. 위에서 보듯이 그냥 일관적으로 쿼리문을 적어주면 상관없을듯하다.)
        일관성있게 적어주는게 좋다.
        [참조링크 : https://stackoverrun.com/ko/q/2466528]
.
.
.