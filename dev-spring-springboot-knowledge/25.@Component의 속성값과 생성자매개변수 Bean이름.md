@Component라는 어노테이션이 생기면서 두가지를 고려해야했다. 우선
1.속성값이 생기는데, 이는 빈 컨테이너에 어떤방식으로 저장되고, 쓰이나
2.@Component의 생성자 빈 주입방식인경우, @Autowired방식과는 어떻게 다른가다

1).이 @Component가 붙은 클래스의 생성자 매개변수를 이용하여 의존주입을 하는경우, @Autowired와 
변수에 의존주입 하는 방식이 같았다. 예시로, 빈 설정파일의 @Qualifier가 있는 빈 메서드의 경우
두 경우다(@Component의 생성자, @Autowired) @Qualifer같은 어노테이션이 따로 붙지않으면, 해당
@Qualifer의 값은 없는셈으로 쳤다.(어느정도냐면, 만약 A타입이 설정파일에 @Qualifer로 되있으면,
이 A타입의 다른 설정메서드같은게 없으면 아예 싱글톤으로 보고, @Component 생성자 매개변수 빈 주입에서도 이를 싱글톤으로
보아, 주입시에 @Qualifer이름이나 해당 빈 메서드의 이름을 안써도 A타입의 빈객체가 하나이니 알아서 주입된다. 단, 다른 설정메서드 같은것은 없다할때)

2). 그리고, 이것부터 알아야 한다. 만약 Hi라는 클래스에 @Component("yo")로 속성값을 준 경우는,
해당 클래스를 @ComponentScan으로 생성시에, Hi타입의 hi,yo라는 같은타입의 빈이 2개나 동시에 생성된다.
(이 경우, 해당 타입의 빈을 설정하거나 생성한거는 이게 다임) @Autowired와 @Qualifer로 설정파일에 쓴것과는 다른거임
예시를 보면, @Component("yo")로 준경우, 이를 @Autowired나 @Component의 생성자 매개변수로 빈 객체 주입하는경우,
변수이름이 @Component("yo")로 쓰여진 클래스의 클래스이름(앞글자 소문자)이거나 yo로 쓰지 않으면, 익셉션이 발생한다.
(같은타입의 빈 객체가 2개이니, 다른 설정은 고려하지 않음)