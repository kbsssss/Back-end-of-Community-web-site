.
.
.
0-1.xml파일의 선언부와 dtd명시에 대해 알아보겠다.
    (1).xml파일의 선언부
        <?xml version="버전" encoding="인코딩방식" standalone="yes 혹은 no"?>
        와 같은 형태로 선언부를 쓴다. 
            {1}.여기에서 버전에는 1.0이나 1.1을 쓸 수 있는데, 현재 xml의
                권고안의 버전은 1.0이므로 1.0을쓴다고한다. 다른 웹사이트나 참조문헌에도 1.0을썻다.
                [참조문헌 : 스프링부트 시작하기 초록책 69pg]   
                [참조링크 : https://sjh836.tistory.com/118]   
                [참조링크 : https://yayongi.tistory.com/entry/XML-%EC%84%A0%EC%96%B82] / xml 권고안의 버전은 1.0
            {2}.인코딩방식에 대한 얘기다. 여기서 encoding의 값을 따로 지정해주지 않으면
                기본값이 UTF-8로 지정이된다. 이 encoding속성의 의미는 이 xml문서를 읽을때 어떠한 인코딩
                방식으로 읽을지를 알려주는 속성이다.
                [참조링크 : https://live8.tistory.com/7]   
                +
                이것의 의미는, 내 생각에 아래 링크를 보면, xml파일도 파일을 저장할때 저장방식이 UTF-8이냐,
                아니면 euc_kr로 지정하여 저장할 수 있는데, 이는 해당 xml파일을 어떠한 문자 코드로 저장하느냐 인것같다.
                또한, 이를 브라우저나 아니면 다른데서 해석할때 어떠한 문자코드로 해석하느냐의 기준은 선언부의 인코딩방식에
                들어가는 값인것같다. 그렇기에 아래 참조링크를 보면, 이 선언부와 저장할때의 문자코드가 다르면 언어가 깨질 수도
                있는것같다. 또한, UTF-8이라하면 이 xml파일에서는 이모지도 모두 포함하는것이니 이 부분에 대해서는 신경쓰지
                않아도 될 것 같다.
                그리고 이 부분에 대해 다시 볼 필요가 있다면 그때가서 다시 봐보도록 하자.
                [참조링크 : http://www.devkuma.com/books/pages/1220]     
                [참조링크 : http://www.devkuma.com/books/pages/1221]    
                +
                또한, 인텔리제이 프로젝트에서 xml파일을 선택해서 보면, 문자코드 저장방식이 UTF-8이고 이를
                다른 파일들과는 다르게 바꿀수 없게 클릭이 안되는거로 되있다. 이 부분도 나중에 문제일시 다시보도록 하자.
                [직접해봄]
            {3}.standalone에 관한 얘기다. 작성된 XML 문서를 XML 파서가 해석할 때 외부 DTD 문서를 참고해야 된다는 것을 
                XML 파서에게 알려주는 목적으로 XML 선언의 standalone 속성을 사용하게 된다. 속성값이 'no'이면 XML 파서로 
                하여금 외부 문서를 참고해서 XML 문서를 해석하라는 뜻이고, 'yes' 이면 XML 파서가 해당 XML 문서를 해석할 때 
                외부 문서를 참고할 필요가 없다는 뜻이다.
                [참조링크 : https://yayongi.tistory.com/entry/XML-%EC%84%A0%EC%96%B82] 
                +
                이상하게 외부문서를 참고해서 XML문서를 해석하는 방식인가 보다, 아래 글에보면 DTD을 명시할텐데, 이 방식은   
                XML 문서를 해석할 때 외부 문서를 참고하는 방식인가 보다. 또한 아래 참조링크와 참조문헌에 봐도 아예 명시를
                안해줘서 기본값을 쓰거나 no를 써준다.(standalone명시 안할시에 기본값은 no이다.) 보통 standalone 속성을 생략하는 것이 보통으로
                생략되었을 경우 기본값 no가 적용된다.
                [참조링크 : https://mybatis.org/mybatis-3/ko/getting-started.html] / standalone 명시x
                [참조문헌 : 스프링부트 시작하기 초록책 69pg] / standalone 명시x
                [참조링크 : https://yayongi.tistory.com/entry/XML-%EC%84%A0%EC%96%B82] / standalone기본값
                [참조링크 : http://ehpub.co.kr/tag/xml-%EC%84%A0%EC%96%B8%EB%B6%80/] / standalone기본값
    (2).DTD명시
        {1}.마이바티스에서는 이렇게 사용한다.
            <!DOCTYPE mapper
              PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
              "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
            [참조링크 : https://xmlns.tistory.com/4]   
            [참조링크 : https://repacat.tistory.com/26]   
            [참조링크 : https://mybatis.org/mybatis-3/ko/getting-started.html]   
            [참조문헌 : 스프링부트 시작하기 69pg]
            +
            추가로 내가, 지금 셀럽마인 임시 프로젝트에 build.gradle에 implementation('org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.3')
            와 같이 작성하였고, 마이바티스 버전은 이때 3.5.5버전이 였다. 아래 참조링크에 보면 2020년 3월 제일 최신이 3.5.4이였고 그걸 적용할때도
            위와 똑같은 DTD명시문을 적어줬다. 문제가 될시에 다시 보도록 하자.
            [참조링크 : https://kimkh0096.tistory.com/entry/01-MyBatis-1-%EA%B0%9C%EC%9A%94-%EB%B0%8F-%EC%84%A4%EC%B9%98]
        {2}.xml파일은 존재 자체가 서로 다른 주체간에 정보를 전달하는게 목표다. 그렇기 때문에 작성자와 그것을 읽는 자간 서로
            이해할 수 있도록 작성 방법이 미리 정의되어 있어야 한다. 그것을 정해놓은 스펙 문서를 DTD라 하고, xml파일의
            선언부 다음으로 가장 윗 부분에 명시하여 해당 xml 문서가 어떤 스펙으로 작성되어 있는지를 알린다.
            즉, 정리해서 이해하자면, 해당 xml문서가 어떠한 작성 방법으로 작성되어있는지를 알려주고, 그러한 방법으로 해석할 수 있게하는것같다.
            [참조링크 : https://repacat.tistory.com/26]   
            [참조링크 : http://www.tcpschool.com/xml/xml_dtd_intro]   
.
.
.
0-2.<mapper>요소에 대해 알아보겠다.
    사용은 <mapper namespace="경로">의 형태로 사용한다. 또한, 이 경로에는 해당 매퍼 인터페이스의
    패키지 경로와 인터페이스명을 포함한 전체 경로를 적어주어야 한다. 경로 적는란에 다시 볼 필요가 있으면 나중에
    다시 봐보도록 하자. 그냥 파일명만 쓰는 곳도 있음. 근데 아래보니 패키지 경로안써주니 오류남
    [직접해봄] / 패키지 경로안써주니 오류나타남
    [참조링크 : https://bigstupid.tistory.com/23]   
    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
    [참조문헌 : 스프링부트 시작하기 초록책 69pg]   
    (1).이 <mapper>의 기능과 namespace의 역활에 대해 설명하겠다.
        이 해당 xml파일에 <mapper>는 sql쿼리문을 묶는 역활을 함과 동시에, <mapper>안에 적은 sql 쿼리문을
        실제로 마이바티스로 작동할 수 있게 해주는것 같다. namespace는 어느 매퍼 인터페이스와 매칭되는지를 
        지정해준다.그래서 해당 xml파일에 작성하는 모든 sql쿼리문은 <mapper>안에 적어야 한다고 한다.
        [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
        [직접해봄] 
    (2).한 개의 xml파일에 <mapper> 요소가 두개 이상 있을 수 없다. 
        오류가 난다고 한다. 즉, 하나의 xml 매퍼 파일에는 단 하나의 <mapper>
        태그만이 존재할 수 있다.
        [참조링크 : https://okky.kr/article/686087]   
        [참조링크 : https://heewon26.tistory.com/7]      
    (3).@Mapper 인터페이스는 모두가 제각각인 이름의 인터페이스를 만들 수 있는것처럼, xml 매퍼파일도 서로다른 xml파일에
        동일한 namespace는 만들 수 없다. 동일한 namespace가 2개일경우 오류가 난다고 한다. 또한, 위에서 본것처럼
        한 xml 매퍼파일에는 <mapper>를 두번이상 쓸 수 없으니, 하나의 매퍼 인터페이스는 하나의 xml 매퍼파일만
        갖을 수 있는거다.
        [참조링크 : https://seungjenote.tistory.com/entry/Spring-Mybatis-%EC%97%90%EB%9F%AC-5%EA%B0%80%EC%A7%80%EB%A7%8C-%EC%95%8C%EB%A9%B4-%ED%95%B4%EA%B2%B0]    
        [참조링크 : https://datajoy.tistory.com/135]
.
.
.
0-3.아래의 공통부분(insert,update,select,delete)에 대한 내용
    (1).주석처리는 <!-- -->로 하는데, 이 주석처리는, XML선언부 이후에만 사용할 수 있으며, <mapper>태그
        이전부터나 <mapper>태그 내의 어디든 사용하여도 주석처리가 된다. 즉 우리가 주로 인지하는 내용은 <mapper>내의
        <insert>문이나 <select>문 내의 내용들에 초점을 맞추는데, 이외에도 주석처리가 가능하다는것이다. 또한, 내 생각에
        우리가 주로 사용하는 범위에서의 내용들에 대한 주석처리(<!-- , -->)는 xml방식해석할때 적용되는것 같다. 왜냐하면,
        이 주석처리를 적용하는 부분이 xml방식에서이고 그러하기에 <insert>문같은것의 내에 주석이 있는경우 이를 배제하고 마이바티스식
        방식해석할때로 코드를 보내게되는것같다.(마이바티스식 방식에서는 주석처리같은거 안하는듯하다.) 또한, CDATA가 쓰여진 부분에 대해서도
        xml방식에서 <!--, -->를 주석처리하지 않고 문자열로 보기에 이 경우에도 주석의 기능을 하지 않는다.
        [직접해봄] / CDATA안에서는 주석사용안됨 , 또한, xml선언부 아래의 어떠한곳에서도 주석이 적용됨(CDATA제외)
        [참조링크 : https://sjh836.tistory.com/118]
    (2).매퍼 인터페이스를 구현한 클래스의 메서드를 실행시켰을때, 파라미터의 여부와 그에 따른, sqlSession.~()
        메서드의 실행과정 그리고, xml파일의 해석과 마이바티스식 분석 그리고 데이터베이스에 쿼리문을 보내기 까지의 전과정을 설명하겠다.
            1.우선, 처음, 매퍼 인터페이스를 구현한 클래스의 메서드를 사용하게 된다면, 이는 곧, @Override한
                매퍼 인터페이스의 메서드를 쓰는것과 같으며, 그 안에는 sqlSession.~()메서드를 실행하는것과 같다.
                또한, 만약에 매퍼 인터페이스의 메서드(구현한 클래스의 메서드에도)에 파라미터가 있다면, 이도 똑같이,
                sqlSession.~()메서드에 그대로 그 파라미터 값이 전달된다.
                [참조링크 : https://bigfat.tistory.com/95]
            2.이제 넘어가는것이 xml 파일인데, 여기서는 나름의 순서대로 체크를 하고 코드를 쓰는것같다.
                xml방식으로 우선 해당 매퍼 인터페이스의 메서드에 해당하는 xml파일의 코드를 해석하고 그다음 <mapper>태그 안의 해당 메서드에 해당하는 
                코드들을 마이바티스 방식으로 분석한 후 최종 쿼리문을 데이터베이스로 보내는것같다. 아래에 더 자세히 보겠다. (분명 다른 부분도 있으나 우선 이렇게 생각하자.)
                    2-1.xml방식으로 해석
                        우선적으로 매퍼 인터페이스의 메서드에 해당하는 코드를 xml방식으로 해석한다. 즉, <mapper>내에 해당 메서드에 해당하는
                        코드들을 xml방식으로 해석하고 나서 이 코드들을 마이바티스식 분석으로 보내는 거다. 더 자세히 내용을 얘기해보겠다.
                            1.<insert id="~" parameterType="~" resultType="~"> ~ </insert>외에 insert부분말고 update, delete, select가
                                들어가더라도 이 부분은 그냥  매퍼 인터페이스의 실행된 메서드명과 이 태그의 속성 id부분만 같다면 아무 작용도 하지 않는다.
                                [직접해봄]   
                                +
                                추가로, 이 <insert> <update> <select> <delete>에 관련된 태그는 xml방식으로 해석한다기보다,
                                그저 마이바티스식 분석을 할때 다른 쿼리문과 구분해주는역활을 하는것으로 보면될것같다.   
                            2.<,>,& 같은 특수문자들을 태그나 기타 xml방식으로 인식해서 적용해 버릴 수 있다고 한다. 그래서 에러나
                                다른 기타 상황이 생길 수 있는데 이를 막고자 CDATA라는 코드를 사용한다. 아래에 추가사항에 설명하겠다.
                                [참조링크 : https://java119.tistory.com/70] / <mapper>내에 있는 <,>,&를 xml에선 태그나 기타 xml방식으로 이해
                                [참조링크 : https://writemylife.tistory.com/m/65]       
                            3.동적쿼리의 사용은 통상 xml에서 해석하여 반영하는것으로 알고있다. 왜냐하면, 모르고 <![CDATA[ ~ ]]>를
                                ~ 안에 동적쿼리 <if test~>를 넣었더니, 마이바티스 분석에서 데이터베이스에 이 그대로를 전달하는거였다. 그러니 xml파서에서 처리할때
                                적용하는것으로 보아도 될것 같다. 자세하게 더 알아야 할 사항이 있으면 다시보고 아래에 더 구체적으로 봐보겠다.
                                (여기서는 <if>동적쿼리에 대해서만 다룬다. 만약 다른 동적쿼리들도 이와같은지는 직접 해봐야 안다. 또한, 파라미터로 보내지는 형들이
                                DTO, String, int형만 고려하도록 하겠다. 나머지는 적용이 필요하게 되면 사용하도록 하자.)
                                [직접해봄]
                                    (1).그럼 <if test="~"> ~~ </if> 동적쿼리에 대해 알아보겠다.
                                        {1-1}.<if test="~">~~</if>동적쿼리는 test속성안에있는 ~ 부분이 true/false의 결과값으로 나오는 boolean타입의 조건식이
                                            들어가게 되는데, 만약에 해당 조건식이 true면 <if>태그 내의 ~~ 부분의 내용을 그대로 마이바티스로 보내고 만약 false의
                                            값이 나오게 되면, 해당 ~~ 부분을 아예 마이바티스분석을 못하도록 감춰버리는것같다. 아예 쿼리문이 안나타난다.
                                            또한, 값이 true일때 <if>문은 마이바티스식 분석을 할때 아예 포함을 안시키거나 나타나지 않는것으로 보인다.(이 <if>코드부분이
                                            마이바티스방식 해석할때까지 넘어가게 되면 그대로 데이터베이스로 보내기 때문에 내 생각에 쿼리코드만 남고 이 <if>코드는 사라지는것같다.)
                                            또한, test속성값이 false인 경우 쿼리코드뿐만 아니라 <if>태그도 함께 사라지게 되는것같다.
                                            [직접해봄]   
                                            [참조링크 : https://goodteacher.tistory.com/249]    
                                        {1-2}.위의 test속성의 ~에 조건식을 작성할 때 보통 파라미터의 값을 기준으로 하는경우가 많다고 한다. 이때 파라미터를 참조할때는
                                            해당 파라미터 명을 그대로 가져다 쓰는데, 아래에 parameterType에 대해서 보면, int형은 애초에 xml파일 올때 interger로 변해서
                                            오고(다를경우 그때가서 다시 보자) String형은 그대로, 그리고 dto형의 경우도 그대로 xml파일로 보내게 된다. 이 얘기를 하는 이유는
                                            xml 파서(xml방식 해석)를 할때는 #{},${}형태가 아닌 이 파라미터명을 그대로 써야하기 때문이다.
                                            [참조링크 : https://goodteacher.tistory.com/249]    
                                            [참조링크 : https://taesikman1.tistory.com/24]  
                                                1.int형의 파라미터를 받아오는경우 xml파일로 받아오기전에 integer형으로 보내져서(아래 설명참조) 참조하게 되는건데 이때도 그냥 int형일때의
                                                    파라미터명을 그대로 쓰면 된다고 한다. 아마 xml파일에서 알아서 자동적으로 값을 넣어주는것같다.
                                                    예시)
                                                        <if test="boardIdx!=0">
                                                            WHERE board_idx=${boardIdxa} AND deleted_yn='N' ORDER BY board_idx DESC
                                                        </if>
                                                    boardIdx라는 int형을 매퍼 인터페이스 파라미터로 부터 받은것이다.
                                                    [직접해봄] / boardIdx로 해봄
                                                    [참조링크 : https://taesikman1.tistory.com/24] / 여긴 parameterType이 String이지만 int(_int상관없다)도 이와 같다.   
                                                2.String형의 파라미터를 받아오는경우 xml파일에서는 그대로 와서 사용하는것 같다. 실제로 매퍼 인터페이스의 메서드의 파라미터로
                                                    xml파일이 넘어올때 String형의 경우 아무 변환도 일으키지 않고 그대로 쓰는것으로 알고있다.(아래 parameterType참고)
                                                    이 경우에도 매퍼 인터페이스의 파라미터타입에서 넘겨온 파라미터명을 그대로 쓴다.
                                                    예시)
                                                        <if test="boardIdx!=null">
                                                            WHERE board_idx=${boardIdxa} AND deleted_yn='N' ORDER BY board_idx DESC
                                                        </if>
                                                    boardIdx를 받아오는것을 <a href=>로 쿼리스트링을 받아오던, form태그의 GET이나 POST방식으로 받아오던
                                                    어차피 String형태로 받아오는것이기에 이걸 컨트롤러의 @RequestParam으로 String형으로 받아온것을 쓴것이다. 
                                                    [직접해봄] / boardIdx를 컨트롤러에서 String형으로 받아서 해봄
                                                    [참조링크 : https://taesikman1.tistory.com/24]
                                                3.DTO형의 파라미터를 받아오는경우 xml파일에서 그대로 와서 사용하게 되는데, 위의 String형과 같게, 매퍼 인터페이스의 메서드의 파라미터로
                                                    xml파일로 넘어올때 아무 변환도 일으키지 않고 그대로 사용하게 된다. 그러나 xml 동적쿼리(if문의 test속성)에서는 위의 파라미터명과는
                                                    조금 다르게 쓰이는데, 여기서는 필드명으로만 적어주어서 사용하게 된다. 아마도 알아서 get메서드라든지 방법을 써서 dto형의 값을 갖고와서
                                                    test속성에 쓰게되는것같다.
                                                    예시)
                                                        <if test="title!=null">
                                                            ~
                                                        </if>
                                                    boardDto의 파라미터타입으로 위의 title은 이 dto의 필드명중 하나이다.
                                                    [직접해봄] / 위의 예시문
                                                    [참조링크 : https://velog.io/@ednadev/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%A7%88%EC%9D%B4%EB%B0%94%ED%8B%B0%EC%8A%A4-MyBatis] / 여기에 parameterType이 user일때 예시문있다.    
                                    (2).위와같은 동적쿼리의 내용특성상 CDATA내에 동적쿼리(<if>)를 쓰게되면 그대로 문자열로 마이바티스식 분석으로 넘어가
                                        버리기 때문에 동적쿼리를 사용할 수 없게 된다. 따라서 동적쿼리를 사용하고 싶다면, <,>를 사용하는 부분에만 CDATA를
                                        적용하여 사용하면 된다.
                                        [참조링크 : https://sdevstudy.tistory.com/6]   
                                        [참조링크 : https://writemylife.tistory.com/m/65]   
                            [추가사항]
                                1.CDATA의 개념과 사용에 대해 알아보자.
                                    (1).<![CDATA[ ~ ]]>와 같이 사용하며, 해당 기능은 xml파서일때 즉, xml방식으로 해석할때
                                        이 코드 부분이 감싼 ~는 그냥 문자열로 취급한다는것이다. 그렇게 한 후에 마이바티스식 분석으로
                                        넘어가서 쓰이게 되는거다. 그래서 <,>,&등을 xml파서부분에서 오류없이 넘어가서 마이바티스에서
                                        등호나 기타 등의 기능으로 쓸 수 있는것이다. 또한 마이바티스식 분석에서는 이 코드 부분을 아예 없는취급하는것 같다.
                                        아래 더 살펴보겠다.
                                        [참조링크 : https://java119.tistory.com/70]       
                                    (2).사용코드는 <![CDATA[ ~ ]]>로 사용하게 된다. 이 코드는 <select> <insert>등의 태그 내의
                                        쿼리코드를 전체를 감싸서 사용할 수도 있고, WHERE 쿼리코드만 감싼다던지, 아니면 글자 하나 > 부등호
                                        표시만 감싼다던지 자유롭게 사용이 가능하다.
                                        [참조링크 : https://sdevstudy.tistory.com/6] / < 글자 하나만 감쌈
                                        [참조링크 : https://epthffh.tistory.com/entry/Mybatis-%EC%97%90%EC%84%9C-CDATA-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0] / 쿼리문 전체 감싸기  
                                    (3).xml파서에서 특수문자(<,>,& 등등) 부분을 해석하여 에러가 날 수 있으므로,
                                        그런이유에서 <![CDATA[ ~ ]]> 를 특수문자가 없는 경우에도 하나의 규칙같이 전부
                                        CDATA를 쓰는곳이 많아졌다.
                                        [참조문헌 : 스프링부트 시작하기 초록책 69~88pg]   
                                        [참조링크 : https://epthffh.tistory.com/entry/Mybatis-%EC%97%90%EC%84%9C-CDATA-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0]
                                2.위에서 보는 xml방식으로 해석한다는것을 xml파싱(parsing)라고 한다.
                                    xml방식과같이 분석하여 적용하는것을 파싱이라고도 하고 아예 컴파일과 파싱을 같은의미로 부르는 경우가 있는것같다.
                                    또한 세번째 참조링크를 보면, 파싱은 컴파일을 하기위해 컴파일전 의미있는 단위로
                                    잘라서, 해석한다음 컴파일이 가능하게되어 컴파일 후에 실행가능한 상태가되는 의미로도
                                    이해해도 될 것 같다. 또 다른 참조링크들을 보면 파싱과 컴파일을 같은 의미로 쓰기도 한다.
                                    아래의 내용을 예로들면, 쿼리문을 DBMS에 보내고나서 DBMS에서는 이 쿼리문을 컴파일 한 후에 실행하게 되는데,
                                    이때 compile이 아닌 파싱이라고도 한다. 
                                    [참조링크 : https://java119.tistory.com/70]   
                                    [참조링크 : https://sdevstudy.tistory.com/6]  
                                    [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=truelite&logNo=20159615998&proxyReferer=https:%2F%2Fwww.google.com%2F]   
                                    [참조링크 : https://java119.tistory.com/39] / DBMS에서 쿼리문을 컴파일할때 파싱이라고도 한다고 나와있다.
                                    [참조링크 : https://madplay.github.io/post/difference-between-dollar-sign-and-sharp-sign-in-mybatis] / DBMS에서 쿼리문을 컴파일할때 파싱이라고도 한다고 나와있다.
                                3.xml파일의 동적쿼리에서 <,>등을 쓰고싶을때나, 쿼리문에서 CDATA없이 <등을 쓰고 싶을때
                                    (1).xml의 동적쿼리에서 <,>를 쓰고싶은 경우에, 즉 <if test="value<0">와 같이 동적쿼리문에서(xml 파서방식이니) 부등호를 사용하고
                                        싶은경우에는, <는 lt >는 gt <= or =<는 lte >= or =>는 gte로 대신해서 쓰면 알아서 해당하는 부호로 해석하게 된다.
                                        xml파서 방식일때 이 test속성안의 <,> 도 태그로 해석하기 때문에 사용하지 못한다. test속성말고 다른 동적쿼리 사용시는 그때가서 알아보기
                                        또한, 여기 test속성값에서 &lt, &gt, &lt;, &gt;같이 적어주니 오류났었다.
                                        [직접해봄]   
                                        [참조링크 : https://kimtaekju-study.tistory.com/168]    
                                        [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=admass&logNo=220548334257&proxyReferer=https:%2F%2Fwww.google.com%2F]
                                    (2).동적쿼리의 test의 속성값에서 쓰는게 아닌, 쿼리문에서 <,>부등호를 쓰고 싶은경우에는 추가로 &와 ;를 붙여야 제대로
                                        작동한다. 즉, 위의 <는 &lt;, >는 &gt;, =<는 &lt;= 그리고 =>는 &gt;=로 써야지 마이바티스식 분석에서 부호로 여기고 해석한다.
                                        보니까, test속성값으로 lt나 gt는 xml파서에서 해석하지만 그 외의 쿼리문에서의 gt나 lt는 문자열로 그냥 보는것같다.
                                        또한, 어디서는 &lt, &gt만 적어도 된다고 써있으나 실제로 해보니 ;까지 붙여줘야 제대로 작동한다.
                                        [직접해봄]   
                                        [참조링크 : https://reference-m1.tistory.com/308]
                                    (3).추가적으로 > 부호에 대해서는 xml파서에서 태그로 인식하지 않아서 해석하지 않고 그대로 마이바티스식 분석으로 넘겨 버린다.
                                        그렇기에 마이바티스식 분석에서는 이를 부등호로 해석하여 사용한다. >의 경우는 이럴수도 있나보다.
                                        [직접해봄]
                                    (4).<if test="~">
                                            ~~
                                        </if>
                                        여기서 ~~에 <,>를 써도 xml방식에서 태그로 인식하고 오류를 발생시키는데, 그 이유가 위의 test의 속성 ~이
                                        boolean값이 참이면 해당 <if> 태그들만 사라지고 마이바티스방식으로 분석할때 ~~분석코드를 보내고 또는 ~의
                                        boolean값이 false이면 <if>태그들을 포함한 ~~에 대한 내용도 모두 사라져서 마이바티스 방식으로 분석할때 해당 내용들이 안보이나
                                        이는 마이바티스 분석방식으로 보내기전에 처리하는것으로 이 여부에 상관없이 ~~에 <,>와 같은 xml파서가 태그등으로
                                        해석할만한게 있으면 그대로 xml파서방식으로 해석하는것같다. 이 부분 다를수도 있으나 이렇게 이해하면 될것같다.
                                        [직접해봄] / 직접 ~~에 <,>쓰니 xml방식에서 태그시작으로 인식함
                                        +
                                        물론, gt lt같은것은 xml파서일때 동적쿼리 test속성값에서 부등호의 기능을 갖는 의미가 있는것이고 마이바티스방식의 분석에서는 이는 그냥
                                        문자열에 불과하기 때문에, 마이바티스방식의 분석에서 부등호와 같은 특수문자를 쓰려면 꼭 CDATA를 사용해주거나 위의 &lt;, &gt;와 같이 써주어야 한다.
                                        [참조링크 : https://kimtaekju-study.tistory.com/168]    
                                        [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=admass&logNo=220548334257&proxyReferer=https:%2F%2Fwww.google.com%2F] 
                                4.매퍼 인터페이스의 메서드의 파라미터 타입에 기본타입이 들어가게 되면, 알아서 xml으로 넘길때 auto-boxing으로
                                    래퍼파일에 값을 넣어서 전달하게 된다고 한다. 또한, 이 래퍼파일들은 기본적으로 get메서드가 없다고 한다.
                                    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / 매퍼 인터페이스의 메서드의 파라미터 타입이 기본타입인경우 auto-boxing으로 래퍼객체로 만들어서 xml에 전달한다. 또한 래퍼파일들은 get메서드가 없다고 한다.                                                 
                    2-2.마이바티스 방식으로 해석
                        xml파서로서 해석한 후에 <mapper>내의 매퍼 인터페이스의 메서드명과 <>태그의 id에 해당하는 내의 쿼리문에 대해 마이바티스
                        식 분석으로 해석하게 되는것 같다. 위의 xml방식에서 넘어오는것에 대해 한번더 정리하자면, CDATA에 관련된 문구는 마이바티스식 분석에서는
                        나타나지 않고, <if>문도 나타나지 않는 것으로 알고 있다. 또한, 마이바티스식 분석에서는 또 나름의 분석과정이 있는데 이 과정을 보겠다.
                            (1).우선적으로, parameterType(<select>,<insert>,<update>,<delete>에 모두 있는 속성)과 resultType(<select>에만 있는 속성)의
                                 기능인 parameterType은 매퍼 인터페이스의 파라미터의 형과 같은지 그리고 resultType은 매퍼 인터페이스의 반환형과 같은지를
                                 (자세한건 아래에 parameterType과 resultType참고) 비교하는 작업을 이곳에서 하는것 같다.
                                 [직접해봄] / 형이 다를 경우 에러가 발생했었다.'
                            (2).${}나 #{}가 쿼리문에 있을때 그리고 #{}와 ${}가 동시에 쿼리문에 있을때를 상황으로 마이바티스방식의 처리 방식을 살펴보겠다.
                                물론, 이를 이렇게 될거다 라는 사실에 근거한 재해석이기 때문에 나중에 문제가 되거나 다를시에 다시 보도록 하자.
                                1.쿼리문에 ${}만 있는 경우(Statement객체 생성)
                                    (1-1).이 경우에는, statement객체만 생성시키는것 같다. 그런 다음, 이 statement객체에 해당 xml파일의 쿼리문만을 담고,
                                        ${} 부분에 대해서는 값을 넣어준다음에 RDBMS로 값이 넣어진 쿼리문을 그대로 RDBMS에 보내게 되는거다.
                                        [참조링크 : https://mine-it-record.tistory.com/300] / RDBMS로 쿼리문 전달 , 실제 수행 쿼리문
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / RDBMS로 전송된 쿼리문에는 ${}에 값이 들어가진채로 전송되는거다.  
                                        [참조링크 : https://devbox.tistory.com/entry/Comporison] / RDBMS로 전송된 쿼리문에는 ${}에 값이 들어가진채로 전송되는거다.     
                                        [참조링크 : https://java119.tistory.com/39] / ${}사용시에 Statement객체 생성
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / ${}사용시에 Statement객체 생성
                                    (1-2).그러고나서, DBMS에 보내진 쿼리문은 컴파일을 수행한후에, 해당 쿼리를 실행한다. 여기서
                                        위의 (1-1)에서 보듯이, DBMS로 쿼리문을 보내기전에 이미 ${}에 대한 값을 모두 넣어서 DBMS로 보내니,
                                        만약에 ${}값이 매번 달라진다면, DBMS도 이를 매번 다른 쿼리문으로 보고 매 달라진 ${}값에 대해 컴파일을
                                        진행하여야 한다. 그렇기에 이 부분에서 PreparedStatement에 비해 #{} & ${}의 값이 변동적인경우 성능이 떨어진다는 이야기도 있으나
                                        Mysql은 둘의 큰 차이가 없다고 한다. 또한, 직접적으로 언급되있지는 않으나, 만약 ${}값이 변하지 않는경우 이 경우도
                                        컴파일은 딱 한번만 진행하고 그 이후로는 안하는것같다. 그러나 이를 캐싱이라고는 하지 않는것같다.
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / ${}값이 넣어진 쿼리문이 DBMS로 보내지기때문에 ${}의 값이 5번 변하면 당연히 DBMS에서 다른 쿼리문으로보고 컴파일도 각각 1번씩 5번 하게 되는거다. 
                                        [참조링크 : https://devbox.tistory.com/entry/Comporison] / Statement도 DBMS에 쿼리보내지면 1.컴파일 2.쿼리수행의 과정을 거친다.
                                        [참조링크 : https://rh-cp.tistory.com/71] / 여기에서도 ${}값이 달라지면 달라질때마다 컴파일을 해야한다 나와있는거보니 같은 ${}값인경우 컴파일은 한번만 진행해도 되는것으로 알고있다. 또한, ${}를 사용할때도, ${}값이 변동적이지 않은거에 사용하라고 한다.
                                        [참조링크 : https://mine-it-record.tistory.com/300] / 여기도 ${}값이 변동적이지 않을때 사용하라고 한다.
                                    (1-3).아래에 있는 PreparedStatement와는 다르게, Statement가 보낸 쿼리문은 이미 ${}에 값이 넣어진
                                        상태로 DBMS에 보내지는것이기 때문에 DBMS입장에서는 쿼리의 기능에 대한 고정이 이루어지지 않았다.(고정의 의미 아래 preparedStatement참고)
                                        그렇기에, 얼마든지 사용자가 어떻게 ${}에 값을 넣느냐에 따라 값이 아닌 쿼리문 자체의 기능을 바꾸어 놓을 수가 있다.(컴파일할때 쿼리문의 기능이 고정되는것 같으니) 
                                        그렇기에, 사용자가 직접 입력하는 문구에 대해서는 가급적 사용하지 않는것이 좋다. 예를들면 ${}에 ''나 WHERE 등등 넣으면 해당 값이 쿼리의 기능을 사용하는것으로
                                        DBMS에서는 간주할 수 있다.
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / SQL주입에 취약하다.
                                        [참조링크 : https://logical-code.tistory.com/25] / 쿼리주입을 예방할 수 없기에 사용자 입력하는 값에 대해서는 사용을 지양  
                                        [참조링크 : https://rh-cp.tistory.com/71] / SQL 주입을 막기위해 사용자가 입력하는 값을 받지 않는게 좋다함 
                                        [참조링크 : https://madplay.github.io/post/difference-between-dollar-sign-and-sharp-sign-in-mybatis] / 쿼리 주입된 예
                                    (1-4).동적쿼리를 사용하는 경우에 ${}를 많이 사용하게 된다고 한다. 테이블이나 컬럼에 값을 넣고싶은경우,
                                        따옴표가 붙지않는 값이 필요하기 때문이다. 또한, 이 외에도 ORDER BY에도 ${}의 사용이 필요하다.
                                        [참조링크 : https://java119.tistory.com/39] / OREDER BY를 사용할때도 ${}가 필요하다고 한다.
                                        [참조링크 : https://mine-it-record.tistory.com/300] / 테이블 및 컬럼명에 사용
                                2.쿼리문에 #{}만 있는 경우(preparedStatement객체 생성)
                                    (2-1).이 경우에는, preparedStatement객체를 생성시키는데, 이 preparedStatement객체에 해당 xml파일의 쿼리문을 담는데,
                                        #{} 부분에 대해서는 ? 로만 넣어주고 preparedStatement객체에서 그대로 RDBMS에 쿼리를 보내준다. 또한, preparedStatement객체는
                                        set메서드로(preparedStatement 객체의 메서드임), 쿼리문의 해당 #{}의 순서와 갯수에 맞게 preparedStatement객체 자신에 값을 저장한다.
                                        그런다음에, 쿼리문(#{}가 ?로 표현된)을 DBMS로 보낼때, 이 저장한 값들도 함께 보내게 된다고 한다. 또한, preparedStatement의 set메서드를
                                        사용하는 코드에서 파라미터에 1,2, 이렇게 숫자가 있는데 이는 #{}가 쓰여진 순서대로 번호가 메겨진것이다.
                                        [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / preparedStatement객체의 set메서드를 통해 #{}에 해당하는 값들을 preparedStatement객체에 저장한다
                                        [참조링크 : https://cocodo.tistory.com/11] / preparedStatement의 set메서드의 숫자는 #{}순서대로 번호가 메겨진거다.
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / #{}에 해당하는 실제값이 DBMS로 쿼리문 처럼 전송된다.
                                        [참조링크 : https://madplay.github.io/post/difference-between-dollar-sign-and-sharp-sign-in-mybatis] / #{}가 쿼리문에 있을경우 preparedStatement객체 생성
                                    (2-2).위의 (2-1).에서 preparedStatement객체에 관한 설명을 할때, int나 String형은 #{}사용시에, 그대로 값을 1:1 매칭시켜주어서
                                        get메서드가 사용되지 않는것으로 보고있다. 아래 참조링크만 봐도, get메서드대신 그냥 그 변수 그 자체가 쓰이는것으로 보고 있다.
                                        또한, 아래의 참조링크를 보면, DTO의 경우는 반드시 DTO의 get메서드를 사용하여 값을 받아오는것으로
                                        보고 있다. 당연히 integer형의 경우도 알아서 값을 내와서 DTO의 get메서드자리나 String의 변수자리에 놓이는것 같다.
                                        [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / 보면, 파라미터타입이 int,String은 나와있지 않지만, DTO의 경우 DTO의 get메서드를 통해 값을 가져온다고 나와있다.
                                        [참조링크 : https://cocodo.tistory.com/11] / 여기를 보니 int나 String은  DTO의 get메서드가 쓰이는자리에 그대로 변수(int나 String의)가 쓰이는것 같다.
                                    (2-3).DBMS에 쿼리문과 #{}에 해당하는 값들이 보내지고 나서의 과정
                                        #{}가 포함된 쿼리문이 DBMS로 보내지면 이에 대한 값도 DBMS로 보내지게 된다. 그러면, 아래 두번째 참조링크를 보면 우선적으로 컴파일을 하고
                                        그 다음에, ?에 해당하는 값을 바인딩한다음에 그러고 나서 해당 쿼리문을 실행하게 된다. 아래에도 설명해 놓았지만, 이러한 과정때문에 SQL 주입이
                                        예방되는것인데, 컴파일을 하고 나서 값 바인딩하기전에 해당 쿼리문의 기능들을 DBMS에서 확정짓는것으로 알고있다. 즉, 컴파일하고 나서 값 바인딩하기전에
                                        쿼리문을 인식하고 값 바인딩하게되면 DBMS에서도 이를 문자열로 인식하기에 SQL주입이 이루어질 수 없다는 것이다. 그렇기에
                                        쿼리주입이 잘 예방되고 #{}값이 변해도 성능상 이점이 있기에, 사용자가 입력하는 부분의 값을 나타내는데 유용하다고 한다.
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / 컴파일하고 나서 값 바인딩하기전에 쿼리문의 기능이 확정된다.
                                        [참조링크 : https://devbox.tistory.com/entry/Comporison] / 1.쿼리문장분석 2.컴파일 3.실행 이 DBMS로 넘겨진 쿼리문에 대한 과정인데, 1.쿼리문장분석은 없는셈치고 봐도 되며, PreparedStatement에서 보낸 쿼리문은 컴파일을하고 ?에 대해 값 바인딩도 추가로 한다.    
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / 여기도 DBMS로 쿼리문 보내지면 컴파일하고 값 바인딩하고 실행되는 순서로 나와있다. 이는 preparedStatement 객체에서 보내졌을때 얘기다.
                                        [참조링크 : https://rh-cp.tistory.com/71] / 쿼리주입이 잘 예방되고 #{}값이 변해도 성능상 이점이 있기에, 사용자가 입력하는 부분의 값을 나타내는데 유용하다고 한다.
                                    (2-4).#{} 및 PreparedStatement에서 말하는 캐싱의 의미
                                        #{} 및 PreparedStatement에서 말하는 캐싱이라는 의미를 알기전에 먼저, 위에서 보면 DBMS에서는 쿼리문을 받으면 #{}에 대해서는
                                        ?로 받게된다. 이를 먼저 컴파일하고 나서 ?에 대한 값 바인딩을 하고 그러고 쿼리문을 실행하게 되는데, 그렇기에 #{}의 값이 바뀌더라도
                                        DBMS에서는 이를 같은 쿼리문으로 보고 컴파일을 처음 한번만 진행하는것으로 알고있다.(당연히, 다른 쿼리문 자체가 바뀌면 컴파일을 실행하게 된다.)
                                        그렇기에, #{}값이 매번 바뀌더라도 DBMS에서는 컴파일을 진행하지 않고 바로 쿼리문을 실행하기에 ${}에 비해 더욱 성능이 좋다고 알려져있다. 
                                        이때 이러한 기능 자체를 캐싱이라고 한다.
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / preparedStatement의 캐싱 개념
                                        [참조링크 : https://java119.tistory.com/39] / 여기서 말하는 컴파일(파싱)이 미리 되어있다는 것도 preparedStatement 캐싱의 개념이다.
                                        [참조링크 : https://madplay.github.io/post/difference-between-dollar-sign-and-sharp-sign-in-mybatis] / preparedStatement의 캐싱 개념
                                    (2-5).또 한가지 해본것은 #{}를 ''으로 감싸게 되면 에러가 일어난다. 내가 볼때 해당 #{}가 있는 쿼리문은
                                        ?가 되어서 DBMS로 보내지는데 이렇게 ?로 보내지게 되면 DBMS에서는 아~ 이거는 ''가 감싸진 문자열이겠구나로 인식을 해서
                                        컴파일이 되고 나중에 값이 바인딩이 되는건데, 처음 DBMS에 왔을때부터 '?'형태면 ?의 기능과 이것을 감싼 '' 와의 기능 충돌이있어서
                                        에러가 나는 것 같다.
                                        [직접해봄] / '#{}'를 하게되면 에러가 난다.
                                3.#{}와 ${} 함께 비교하거나 공통되어진 내용정리
                                    (3-1).#{}, ${}는 Mysql에서는 성능상의 큰차이가 없다.
                                        위의 (2-4).의 내용을 보면, 쿼리 캐시를 사용하기에 성능과 효율이 좋다고 나와있다. 또한, 바로 아래에 보면 트래픽 상의 성능과 효율이
                                        그렇기에 조금 좋다고 나와있는데, 이 부분은 크게 신경쓰지 않아도 될 것 같다. 나중에 필요시 다시 보도록 하자. 또한 첫번째 참조링크에도 MySql에서는
                                        이 쿼리 분석 작업이 그다지 무겁지 않아서 PreparedStatement가 꼭 다른거에 비해 효율이 좋다고 할 수도 없다고 한다. 또한 두번째 참조링크에서도 실제로 #{}가
                                        캐싱기능이 있어서 ${}보다 효율이 좋다고 했는데 이는 ${}특성상 값이 달라지면 매번 파싱작업을 하기때문이라고 했었다. 그러나 두번째 참조링크에서 이를 1만번 정도
                                        쿼리문을 테스트했는데 #{}와 ${}의 값이 매번 달라져서 1만번 쿼리문을 작성했는데도 큰 차이가 없었다. 단, Mysql에서만 그러하였다.
                                        [참조링크 : http://blog.naver.com/PostView.nhn?blogId=gksdbwjd2725&logNo=221235120546&parentCategoryNo=&categoryNo=9&viewDate=&isShowPopularPosts=true&from=search] / #{}가 네트워크 트래픽 측면에도 이점이 있으나, Mysql에서는 쿼리 분석작업이 그다지 무겁지 않아서 PreparedStatement가 무조건 효율적이라고 볼수 없다고 한다.
                                        [참조링크 : https://devbox.tistory.com/entry/Comporison] / #{}는 값이 달라져도 캐싱때문에 컴파일이 생략되고 ${}는 특성상 값이 달라지면 매번 컴파일을 하게 되는데, 이 차이때문에 1만번이나 같은 쿼리문으로 테스트해봤지만, Mysql에서는 큰 차이가 없었다고 한다.  
                                    (3-2).(3-1)의 내용을 근거로 그러니, 무조건 #{}를 쓰면 DBMS마다 캐싱할 수 있는 한계가 정해져있어서 제대로된 작업에 캐싱을 못할 수도 있으니,
                                        Mysql같은 경우에는 #{}와 ${}가 성능상의 차이도 없어서, #{}는 따옴표가 필요하거나 SQL 주입예방에 필요한 경우 쓰도록 하며, ${}는 따옴표가 있으면
                                        안되는 부분에 용도에 맞게 사용하면 될것같다. 추가로, ${}는 SQL 주입이 될 수 있기에, 사용자가 입력하는 값을 넣지않는것만 고려하면 될 것 같다.
                                        [참조링크 : https://devbox.tistory.com/entry/Comporison] / 모든 쿼리를 PreparedStatement로 하게 되면 또다른 문제가, 각 DB마다 SQL캐싱할 수 있는 한계가 있기 때문에 정작 정작 캐싱되어야 할 쿼리가 캐싱이 안될 수 있기 때문에상황에 맞는 #{}의 사용이 필요하다고 한다.   
                                    (3-3).추가적으로 ${~}를 칼럼명에 쓰고 그에 대한 값으로 #{~}를 쓰이기도 한다.
                                        예를들면, ${~}=#{~}와 같은경우 ${~}에 해당하는 칼럼명과 그 값 #{~}이 =에 대한 관계를
                                        맺고 있는것이다. 이 외에도 다양하게 함께 쓰이는경우가 많다.
                                        [참조링크 : https://marobiana.tistory.com/60]
                                4.쿼리문에 #{}와 ${}가 있는 경우
                                    (4-1).이 부분에 대해서는 자세히 나와있는 경우가 없어 주어진 정보대로 예상한것이다. 그러니 나중에라도 더 자세히 봐야하거나
                                        바꿔야할 부분이 있다면 다시 보도록 하자. 우선적으로 아래의 첫 참조링크를 보면, PreparedStatement는 Statement를 상속하고 있다.
                                        또한 두번째 참조링크를 보면, ${}만 넣은 쿼리문의 경우 DBMS에서 해당 쿼리문 전체가(이미 ${}는 값이 들어간 상태니) ?가없는 PreparedStatement
                                        으로 본다고 한다. 즉, 이러한 것을 봤을때 만약 #{}와 ${}가 쿼리문에 함께 있는경우, ${}에 대한 값이 들어간 쿼리문을(#{}는 아직 안건들임 + 마이바티스내부에서 이러한
                                        과정들을 처리하는것으로봄) PreparedStatement 객체가 담게되며, 여기서 부터는 기존의 PreparedStatement방식으로 쿼리문들이 처리가 되는것 같다.
                                        [참조링크 : https://devbox.tistory.com/entry/Comporison]   
                                        [참조링크 : https://marobiana.tistory.com/60]   
    (3).마이바티스의 <mapper>내의 쿼리문에서 #{~},${~}의 작동원리와 개념설명
        1.#{~}의 작동원리와 개념설명
            {1}.동적쿼리(위의 if문의 경우, 다른 동적쿼리는 안해봤으나 필요할 경우 그때가서 다시 봐보자)의 안에서 쓰이는 경우
                1-1.파라미터 타입이 String형 인 경우
                    아래의 참조링크를 보면, 파라미터타입이 String형이면서 <if>문 안에 쓰이는 경우 get메서드를 이용해서 값을 받아오기에
                    String형은 get메서드가 없어서 에러가 발생한다고 나와있다. 또한, 다른 참조링크들을 봐도 전부 그렇게 나와있다. 그러나 내
                    마이바티스가 최신이여서 그런지(xml방식에서 마이바티스방식으로 넘어왔을때 마이바티스방식에서 해석방식이 최신버전이여서 좀 다를수도),
                     <if>문 안에 #{변수명}, #{다른 어떠한 명}, #{value}을 넣어도 모두 정상적으로 작동하였다. 또한, 본래 참조링크들을 보면, #{변수명}은
                    get방식으로 값을 받아오기때문에 #{value}로 하면 알아서 값이 매칭된다고 나와있다. 그러나 마이바티스가 최신이여서 그런지 #{변수명}, #{value},
                    #{다른 어떠한 명}도 모두 get방식이 아닌 그대로 값을 매칭시켜주는것같다.
                    [직접해봄] / <if>문 안에서 #{변수명}, #{다른 어떠한 명}, #{value}모두 정상 작동했다.
                    [참조링크 : http://blog.naver.com/PostView.nhn?blogId=roropoly1&logNo=221184569655&parentCategoryNo=&categoryNo=9&viewDate=&isShowPopularPosts=true&from=search] / 여기서는 동적쿼리 <if>안에서는 #{변수명}일시 get방식으로 값을 얻어오기 때문에, #{value}해야 값이 get방식을 안쓰고 매칭된다고 나와있다
                1-2.파라미터 타입이 int,_int형(기본 타입) 인 경우
                    아래 참조링크를 보면, long이나 int형(기본형은 다 해당되는듯 하다.) 기본타입들은 <if> 동적쿼리 안에
                    #{변수명}을 적을시 getter 방식으로 값을 갖고온다고 한다. 그렇기에, 에러가 안나려면 #{value}로 해주어야 값을
                    그대로 매칭해준다고 한다. 즉, getter를 쓰는게 아니라 그냥 값을 매칭시켜주는방식인거다. 그러나, 실제로
                    내가 직접해보니 마이바티스가 최신이여서인지는 모르겠으나, #{변수명}, #{value}, #{다른 어떠한 명} 모두 값이
                    잘 매칭되어서 실행이 됬었다. 마이바티스가 최신버전이라 그런걸수도 있고 만약에 이 부분이 나중에 다시 문제가
                    된다면 다시 봐보도록 하자.
                    [직접해봄] / <if>쿼리문 내에서 #{변수명}, #{value}, #{다른 어떠한 명}이든 모두 정상 작동했다.
                    [참조링크 : https://gdtbgl93.tistory.com/95] / 기본자료형(long 등등)도 <if>쿼리문 내에서의 #{변수명}은 get메서드를 이용해서 받아온다.
                    [참조링크 : https://everydaycoding.tistory.com/category/Springframework] / 원시타입, 즉, int나 long타입같은거도 <if>쿼리문 내에서 #{value}쓰면 알아서 값이 잘 매칭이된다는말
                    +
                    위에서 xml방식에서 보듯이, 여기는 int타입의 매퍼 인터페이스의 파라미터타입을 받으면, 자동으로 xml방식해석전에
                    integer객체에 담아서 변형시켜서 받기에, 여기서도 마이바티스방식에서 값을 매칭시킬때, 자동으로 integer객체에서
                    값을 갖고와서 매칭시켜주는것으로 생각하면 될것 같다.
                1-3.파라미터 타입이 DTO형 인 경우
                    이 경우에는, 아래에 보듯이, <if>문 안이 아니더라도 DTO를 사용하는 경우에는 #{변수명}과 같이 쓰며
                    이를 사용할때, DTO의 get메서드를 가져다가 값을 대입하는거로 나와있다.(위의 preparedStatement보면 이해 더욱 잘됨)
                    그러니, <if>문 안이더라도 #{변수명}처럼 변수명을 써야하는것은 똑같으며, 값을 연결시켜줄때도 DTO의 get메서드를 사용하여
                    연결시켜줄것으로 보고 있다. 즉, <if>문에 상관없이 사용법이나 적용되는 방법이 같은것으로 보고있다. 만약에 조금
                    다른 부분이 있거나 틀린 부분이 있으면 나중에 필요시 다시 보도록 하자.
                    [직접해봄] / <if>문 안에 파라미터 타입이 DTO인 경우 사용해봄
                    [참조링크 : https://velog.io/@ednadev/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%A7%88%EC%9D%B4%EB%B0%94%ED%8B%B0%EC%8A%A4-MyBatis] / <if>문안에 파라미터타입이 DTO인 경우   
            (2).동적쿼리 내가 아닌 일상 쿼리문에서 쓰이는 경우
                2-1.파라미터 타입이 String형 인 경우
                    아래의 참조링크에서도 보듯이, <if>의 동적쿼리문안이 아니면 get메서드를 사용하지 않는것 같다. 그러하기에,
                    아래의 참조링크는 #{변수명}이 된다고 적어놨지만, 직접해보니 #{변수명}, #{다른 어떠한 명}이 3가지 모두 정상작동하였다.
                    즉, 어차피 매칭되는값은 하나이기에, 무엇을 적든 get메서드를 사용하지않고 바로 값을 넣어주는것같다.
                    [직접해봄] / #{변수명}, #{value}, #{다른 어떠한 명} 모두 해봤더니 잘 되었다.
                    [참조링크 : http://blog.naver.com/PostView.nhn?blogId=roropoly1&logNo=221184569655&parentCategoryNo=&categoryNo=9&viewDate=&isShowPopularPosts=true&from=search] / if문의 동적쿼리내에서 #{변수명}을 사용시에는 get메서드를 쓰지않는다.     
                2-2.파라미터 타입이 int,_int형(기본 타입) 인 경우
                    위에도 적어놨듯이, 매퍼 인터페이스의 메서드의 파라미터가 int형이면 xml로 넘겨줄때 즉, xml방식을 적용하기 이전에
                    이미 integer객체로 변환이 되어서 적용이 된다. 이 경우에는 따로 찾아본 내용은 없지만, 위의 <if>문 안에서의 int,long에 대한
                    내용을 보면, <if>문이 아닐때는 일반적으로 #{변수명}, #{다른 어떠한 명}, #{value}모두 값을 1:1 매칭해주는것 같다. 만약
                    다르거나 다시 봐야할 부분이 있다면 그때가서 고려하도록 하자.
                    [직접해봄] / #{변수명}, #{다른 어떠한 명} 모두 해봤더니 잘 되었다.
                    [참조문헌 : 스프링부트 시작하기 초록책 81pg] / <if>문이 아닌데서 #{변수명}으로 쓰이는모습
                2-3.파라미터 타입이 DTO형 인 경우
                    파라미터 타입이 DTO인 경우, 해당 필드값을을 쓸때 #{필드명}으로 가져다 쓰는것 같다. 이 필드명은 반드시
                    맞춰주어야 매칭이 되는것 같다. 위의 마이바티스 방식 preparedStatement에 관한글을 보면 더 쉽게 이해가 될것이다.
                    만약 다른 내용이 있다면 그때가서 다시 정리하며, 또한 이 <if>동적쿼리문 안이 아니더라도, 이 #{변수명} 값들을
                    연결시켜줄때 기존 DTO의 get메서드를 이용하여 값을 연결시켜준다. 이 부분도 위의 preparedStatement를 보면 더욱
                    잘 이해가 될것이다.
                    [직접해봄] / <if>문이 아닌곳에서 DTO를 사용해봄  
                    [참조문헌 : 스프링부트 시작하기 초록책 88pg, 76~77pg] / <if>가 아닌데서 DTO가 쓰인경우 
                    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / 여기에 봐도 DTO의 get메서드를 사용 
            (3).#{}에 대한 추가내용들
                3-1.아래 참조링크를 보면, 쿼리문에 #{}가 있는 경우 컴파일 - 바인딩 - 쿼리문실행의 3단계를 거치는데(자세한건 위의 글 참고) 이 컴파일 과정에서
                    아예 해당 쿼리문의 원본의 기능이 고정이 되어서, 값이 바인딩되어 들어올때 hi, 'title'와 같은 문자열을 넣어도 SQL 주입이 예방되는거다.
                    즉, 고정될때 해당 쿼리의 기능들을 이미 고정시키고 나머지 값 바인딩되는것들은 문자열로만 취급한다는거다.
                    [참조링크 : https://www.podo-dev.com/blogs/107]
                3-2.#{}를 사용하는 경우에는, DBMS에서 값이 바인딩이 될때 무조건 ''가 감싸져서 값이 바인딩이 된다. 그러고나서 해당 쿼리문이 실행이되는거다.
                    또한, boolean형은 안해봤지만, 그건 그때 필요하게되면 다시 하도록 하고 DTO의 필드타입이 int이거나 애초에 파라미터타입이 _int,int인 경우는
                    ''가 붙었는지 안붙었는지는 일반 쿼리문으로는 확인이 어려우나 ''가 무조건 붙는것으로 알고있다. 이 부분도 나중에 문제가 된다는 다시 보도록 하자.
                    [직접해봄] / 실제로, DTO의 필드타입이 String형인것과 매퍼인터페이스의 파라미터타입이 String형인경우 모두 ""가 붙은 값이였다.  
                    [참조링크 : https://logical-code.tistory.com/25] / #{}는 값에 ''를 감싸서 나온다.
                    [참조링크 : https://logical-code.tistory.com/25] / #{}는 값에 ''를 감싸서 나온다.
                    [참조링크 : https://java119.tistory.com/39] / #{}는 값에 ''를 감싸서 나온다.
        2.${~}의 작동원리와 개념설명
            {1}.동적쿼리(위의 if문의 경우, 다른 동적쿼리는 안해봤으나 필요할 경우 그때가서 다시 봐보자)의 안에서 쓰이는 경우
                1-1.파라미터 타입이 String형 인 경우
                    아래의 참조 글을 보면, <if>문내에서의 ${변수명}도 get메서드를 이용하여, String은 get메서드가 애초에 없기에 에러가 난다고 한다.
                    그러기에, #{value}를 적어주어야 매칭이 된다고 하는데, 여기서도 ${value}에 대한 내용은 없다. 그러나 직접해본결과, ${변수명}, ${다른 어떠한 명}, ${value}
                    이 3가지 경우 어떤것이든, 값이 매칭되었었다. 즉, 마이바티스가 최신버전이여서 그런지 모르겠으나, get메서드를 사용하지 않고 바로 매칭시켜주는것같다. 여기서도 보듯이
                    참조 글의 상황에 경우는 ${value}가 되는지 안되는지는 알아볼 수가 없다.
                    [직접해봄] / ${변수명}, ${다른 어떠한 명}, ${value} 이 모든것에 대해서 값이 제대로 작동하였다.
                    [참조링크 : https://aljjabaegi.tistory.com/457] / 파라미터타입이 String형인경우, <if>내에서 ${변수명}도 get 메서드를 사용하기에 에러가 난다고 나와있다.
                1-2.파라미터 타입이 int,_int형(기본 타입) 인 경우
                    위의 ${}가 파라미터타입이 String형인 경우에도, <if>동적쿼리문 안에 쓰면 get메서드 방식을 사용하기에 오류가 난다고
                    나와있다. 짐작에, int형 타입도 아무리 xml에 넘어올때 integer로 넘어온다고 하여도 integer는 get메서드가 없기에 오류가
                    날꺼라고 가정을 하겠다. 그러나 직접 해보니, 마이바티스가 최신버전이여서 그런지, <if>동적 쿼리문 안에 ${}가 있어도 정상적으로
                    작동하였다. ${변수명}, ${다른 어떠한 명}, ${value} 이 모든게 정상작동한것으로 보아, 값은 get방식이 아닌 그대로 1:1매칭 시켜준
                    것으로 보아도 될것같다. 나중에 다시 볼 필요가 있을시에 다시 보도록 하자.
                    [직접해봄] / ${변수명}, ${다른 어떠한 명}, ${value} 이 모든것에 대해서 값이 제대로 작동하였다. 
                    [참조링크 : https://aljjabaegi.tistory.com/457] / 파라미터타입이 String형인경우 ${}의 경우 get메서드를 요구하기에 에러가 난다고 한다.
                    +
                    여기서는 애초에 ${변수명}은 안되니 ${value}가 했더니 되었다 라는것을 쓸 수가 없다. 이러한 글이 없고,
                    지금은 ${}안에 어떠한 명을 써도 되기 때문이다.
                1-3.파라미터 타입이 DTO형 인 경우
                    이 부분도 아래의 <if>문이 아닐때와도 크게 차이가 없는것 같았다. 실제로 DTO형을 파라미터 타입으로 받아
                    왔을때, 이를 DTO의 각 필드를 사용하려면, ${필드명}을 써서 사용이 가능했고, DTO에서 값을 가져오려면 get메서드 방식
                    밖에 없으니, get메서드 방식으로 보아도되며, 아래의 <if>문 내가 아닌경우가 비교했을때, 차이점이 없어보였다.
                    만약, 나중에 필요사항이 있다면 다시 봐보도록 하자.
                    [직접해봄] / DTO형으로 해당 필드명들과 같은명으로 ${명}을 써서 사용해보았다.  
            (2).동적쿼리 내가 아닌 일상 쿼리문에서 쓰이는 경우
                2-1.파라미터 타입이 String형 인 경우
                    이 경우에는, ${변수명}, ${다른 어떠한 명이든}, ${value} 이 모든것에 대해서 그냥 1:1 대입하는 방식으로
                    값이 들어가는것 같았다.(이게 get 메서드로 받아오는지 바로 대입이 되는지는 나와있지않으나, String형은 get메서드가 없다.) 위의
                    <if>문 안에서의 ${}의 받아오는 방식도 바로 값을 매칭시키는 방식같다.
                    [직접해봄] / ${변수명}, ${다른 어떠한 명이든}, ${value} 이 3개 모두 정상적으로 값이 넣어지고 작동되었었다.
                2-2.파라미터 타입이 int,_int형(기본 타입) 인 경우
                    우선적으로 일반적으로 다른 참조링크보면 다 잘 쓰이고 있으며, 그 외에도  ${변수명}, ${다른 어떠한 명}, ${value}
                    와 같은 방식으로 직접 해보았는데도 정상적으로 잘 작동하였다. ${}가 int타입에 대해서는 어떻게 값이 매칭된다고 나와있지는 
                    않으나, get메서드 방식은 아니며 일방적으로 1:1 매칭되는 방식인것 같다. 만약 나중에 다른 부분이 있거나 수정할 부분이
                    있으면 그때 다시 보도록 하자. 또한 값 매칭시킬때 integer에서 값을 갖고와서 매칭시키는거다.
                    [직접해봄] / ${변수명}, ${다른 어떠한 명}, ${value} 이 모든것에 대해서 값이 제대로 작동하였다.   
                2-3.파라미터 타입이 DTO형 인 경우
                    직접 DTO들의 필드명을 각각 사용할때 ${필드명}에 따라 사용하였고, 모두 정상작동하였다. 또한, ${}안에
                    사용하려는 필드명을 넣어야 하는것 같으며, 다른 참조링크들을 찾아보아도 이것이 get방식으로 받아오는건지는
                    나오지 않았었다. 하지만, 애초에 DTO에서 값을 받아오려면 get메서드 방식밖에 없으니 get메서드를 사용해서 받아왔다고
                     생각해도 무방할것 같다. 이 부분 나중에 필요할시에 다시 보도록 하자. 
                    [직접해봄] / DTO형으로 해당 필드명들과 같은명으로 ${명}을 써서 사용해보았다.
                    [참조링크 : https://sinna94.tistory.com/entry/MyBatis-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%82%BD%EC%9E%85%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EB%93%A4?category=696828] / ${}에 DTO의 필드사용시 ${변수명}으로 적는 내용   
            (3).${}의 경우에는 DTO의 필드의 타입이 int형이건, String형이건 파라미터타입이 int형이건, String형이건 그 ${} 값을
                DBMS에 보내게 될때 ''를 붙이지 않고 보내게 된다. 그렇기에, 쿼리에 반영될때 ''가 붙지않은 값이 반영이 되는거다. 실제로
                DTO의 필드타입이 String형인 경우를 해봤고 나머지 int형 필드타입이나, 파라미터타입이 Int,String형도 이와 같을 것으로 보고있다.
                [직접해봄] / DTO의 String형 필드를 ${}로 사용해보니 실제로도 ''가 없는 값만 나오게 됬다. INSERT문의 컬럼명에 사용해보았고, DTO의 int형이나 파라미터타입이 int형,STring형은 모두 해보진 못했으나 역시 ''가 없는 값만 표현될것으로 보고있다.
                [참조링크 : https://java119.tistory.com/39] / ''가 붙지않는다.
                [참조링크 : https://mine-it-record.tistory.com/300] / ''가 붙지않는다. 거기에 DBMS에 보낼때 예시가 있는데 여기서도 ''가 붙지않았다.
                [참조링크 : https://madplay.github.io/post/difference-between-dollar-sign-and-sharp-sign-in-mybatis] / ''가 붙지않는다.
    (4).parameterType에 관해서 정리해 보도록 하겠다.
        (3-1).string,int, dto의 대해서만 정리하고, 나머지 string,int의 배열이나 dto배열
            혹은 map이나 그 외의 타입들에 대해서는 필요한 경우 다시 정리하도록 하겠다.
            [직접해봄]
        (3-2).parameterType별로 정리내용
            기본적으로 xml파일의 이 parameterType과 매퍼 인터페이스를 구현한 클래스의
            메서드의 파라미터의 타입과 같은것으로 적는다는 가정으로 진행한다. 그리고 그렇게 해야한다.
            왜냐하면, 이 parameterType의 기능이 매퍼 인터페이스의 메서드의 파라미터의 자료형과 맞지
            않으면 오류를 낸다. 근데 resultType처럼 그 외의 기능은 없는것같다. 자세한것을 아래 설명하겠다.
            [직접해봄] / 매퍼 인터페이스의 파라미터 자료형이 int형이고 parameterType은 String으로 하니 에러남
                1-1.타입이 int형인경우(+기본형 타입)
                    1.이 경우 매퍼 인터페이스의 메서드의 파라미터의 타입이 int형인 경우로 한정하자.(Integer타입말고)
                        [직접해봄]
                    2.매퍼 인터페이스의 메서드의 파라미터 자료형이 int일때, xml파일의 parameterType이 int(별칭이 int이고 자료형은 Integer)이거나
                        아니면 _int(별칭이 _int이고 실 자료형은 int)여도 오류 안나고 잘 작동한다.
                        [직접해봄]
                    3.매퍼 인터페이스의 메서드의 파라미터 형이 기본타입형인경우(또한 이 형과 parameterType형이 맞아야함)
                        오토박싱(auto-boxing)으로 자동으로 이를 wrapper객체로 생성하여 xml파일에 전달되게 되는거다.
                        그러니, int형인경우 integer타입으로 오토박싱되서 xml파일에 전달되는거다. 
                        [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]
                        +
                        아래 참조링크를 보면, 매퍼 인터페이스의 메서드의 파라미터 타입에 따라, sqlSession.select~()이 메서드에서
                        알아서 기본형 타입인경우 wrapper타입으로 생성해줘서 xml파일로 보내는것같다.
                        [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
                1-2.타입이 String형인경우
                    파라미터타입이 string으로 매퍼 인터페이스의 파라미터의 자료형이 String인 경우, 
                    다른 변형을 일으키지 않고 그대로 xml방식을 하는곳으로 보내는것 같다.
                    [직접해봄]
                1-3.타입이 DTO형인 경우
                    이 경우에도, DTO형을 그대로 갖고와서 사용하는것으로 보인다. 더 자세히 말하면, xml분석에 이 DTO형을
                    그대로 보내서 사용하는것으로 보인다.
                    [직접해봄]   
                [추가사항]
                    wrapper 타입과 String형은 getter메서드가 존재하지 않는다.
                        자세한 내용은 위에 동적쿼리 내에 #{},${}사용여부에 보면 자세하게 나와있다.
                        [직접해봄]                    
        [추가사항]
            1.parameterType의 별칭은 기존의 resultType의 별칭 사용을 위한 설정의 값을 그대로 같이 쓰는것같다.
                그렇기에, DTO의 경우는 따로 별칭 설정을 하지 않았다면 패키지부터 모든 경로를 적어주어야 한다.
                [참조링크 : https://wondongho.tistory.com/72] / 별칭설정 후에 resultType과 parameterType에 사용할 수 있다.
                [참조링크 : https://babolsk.tistory.com/995] / parameterType의 별칭이라 적었는데 resultType과 같은것같다. 
            2.parameterType은 <select>, <update>, <insert>, <delete>에 모두 공통으로 쓰이는 기능이다.
                [참조링크 : https://sjh836.tistory.com/128 ]     
                [참조문헌 : 스프링부트 시작하기 81pg ~ 88pg] / 여기에도, <insert>,<update>,<delete>,<select>에 모두 parameterType이 쓰였다.
    (5).Mysql은 칼럼 타입에 따라 숫자 데이터에 다르게 반응한다.
        좀 더 자세히 보도록 하겠다. 우선  Mysql의 컬럼의 데이터타입이 TEXT, VARCHAR, CHAR(다른 타입들은 안해봤지만 비슷할 것으로 본다. 필요시 그때 정확히 해보기) 
        인 경우에 숫자 데이터와 관계를 갖을때(내 경우에는, INSERT문제 컬럼 - 대입할값 의 방식만 했으나 다른것도 크게 다르지 않을듯 하다. 이것도 그때가서 필요하면 다시 해보기. 왜 다르지
        않을것으로 보냐면, 해당 관계를 맺는 칼럼이 TEXT, VARCHAR, CHAR같은거면 컴파일할때 숫자에''를 붙이고 쿼리문을 실행하게 되는것 같다.) '숫자'도 당연히 되지만, 숫자 이렇게
        숫자 값만 적어도 그래서 쿼리문이 정상작동하였다. 컬럼의 타입이 INT형인 경우는 우선 당연히 본래 숫자 의 값 즉, 따옴표 없이 이 값으로만 관계를 맺는게 맞다.(스프링부트 시작하기 초록책
        81pg에도 그렇게 나와있다.) 그러나 '숫자' 처럼 숫자 값에 따옴표를 붙여도 정상 작동하는데, 이는 DBMS에서 컴파일 할 때 반대로 ''를 없애주는 것 같다. 이 INT는 INSERT문에서 해당 컬럼에
        값을 넣는 부분에 '숫자'로 해본것이나 selectBoardDetail을 수행하기위해 SELECT쿼리문의 WHERE 부분에 boardIdx='숫자'처럼 썻을때도 됬었다. 즉, 애초에 컴파일할때 '숫자'에서 이 ''를
        지워주는것으로 보아 다른 어떠한 관계도 INT형 컬럼에 ''를 쓰는것은 허용이 될 것 으로 보인다. 또한, hit_cnt 즉 조회수를 올리는 쿼리문이 작성되는 것에서
        INT형 타입의 컬럼에 컬럼명=컬럼명+'1'을 했는데 이 또한 정상적으로 1을 더하게 되는 값이 나왔다. 또 컬럼명='3' + '1'도 정상적으로 작동하였다.
        즉, INT형 타입의 컬럼은 +와 같은 관계자에서 각 값들이 모두 '숫자'이건 일부가 '숫자'이건 컴파일에서 ''를 제거하고 +연산도 가능하게 하는 것 같다. +외에도
        더 알아볼 연산이 있다면 그때가서 알아보도록 하고 이 내용들에 대해서 틀리거나 다른 부분이 있으면 필요시 그때가서 다시 정리하도록 하자.  
        [직접해봄] / INT, TEXT, VARCHAR, CHAR에 대해 위의 내용대로 해봄
.
.
.
.
