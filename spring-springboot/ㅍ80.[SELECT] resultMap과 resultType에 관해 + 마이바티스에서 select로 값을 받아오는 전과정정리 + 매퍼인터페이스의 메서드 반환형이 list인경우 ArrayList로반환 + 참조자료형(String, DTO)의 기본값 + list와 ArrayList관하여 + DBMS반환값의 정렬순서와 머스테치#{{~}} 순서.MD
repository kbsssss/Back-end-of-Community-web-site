
.
.
.
1-1.<select>에 대하여
    주로 사용하는 형식 : <select id="메서드명" parameterType="값" resultType="값">
    resultMap은 위에 설명되어 있으니 제외하고, 주로 사용되는 속성은 id, parameterType,resultType이다.
    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
    [참조링크 : https://sjh836.tistory.com/128]
        {1}.<select>는 말 그대로 쿼리문을 작성하는데 있어서, select 쿼리문을 사용하는곳에 쓴다.
            [참조링크 : https://sjh836.tistory.com/128]   
            [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
        {2}.id는 필수속성으로 유일한 id값을 적어야 하는데, 이는 해당 namespace에 속하는
            매퍼인터페이스의 메서드명과 동일하게 적어주어야 한다.
            [참조링크 : https://bigstupid.tistory.com/23]   
            [참조링크 : https://linux.systemv.pe.kr/mybatis%EC%97%90-dao-%EC%99%80-mapper/]   
            [참조문헌 : 스프링부트 시작하기 초록책 69pg]  
        {3}.resultType
            여기있는 resultType에 대해서는 Map이나 arraylist, list 그리고 string, int배열에 관해서는 모두 배제하고
            DTO와 int, String형에 대해서만 고려하고 글을 작성하겠다. 나머지 것들에 대해서는 필요하면 다시 보도록 하자.
                1.이 resultType에는 사용하려는 클래스의 패키지명을 포함한 클래스명을 전체 모두 적어주거나, 아니면
                    별칭(alias)을 적어주어야 한다. 보통 DTO는 전체 다 적어주고, String같은것도 java.lang.String처럼
                    적어주어야하나, 일부 자주 이용하는 형태에 대해서는 미리 별칭이 정의되어 있어 string만 적어주어도 된다.
                    또한, 원시형자료형(primitive type)인 int는 기본자료형으로 클래스형은 없는것같으나 이도 별칭이 따로 정해져있다.
                    int나 integer는 별칭만 쓰는것같고, 이 int의 전체경로를 알 필요가 있으면 그때 다시 보도록 하자.
                    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / resultType에 패키지를 포함한 전체 클래스이름 혹은 별칭을 적어준다.  
                    [참조링크 : https://aljjabaegi.tistory.com/457] / resultType에 패키지포함 클래스명이나 별칭적기
                    [참조링크 : https://araikuma.tistory.com/475] / 일부 자주 이용하는 형태는 별칭이 정리되어있음
                    +
                    DTO도 따로 별칭을 등록하는 방법도 있긴한데, 그건 나중에 필요할시 찾아보자.
                2..resultType은 우선, 매퍼 인터페이스의 메서드의 반환형과 호환이 가능한지(int,string,DTO)를 먼저 체크한다. 즉,
                    만약 인터페이스의 메서드 반환형과 다르다면, 에러(익셉션)를 발생한다. 하지만, resultType이 주는 기능은 이것이 다인것같다.
                    그 외에 기능은 따로없으며, 나머지는 다른곳에서 모두 처리한다. 만약 더 알아야 할 부분이 있다면 다시 보도록 하자.
                    [직접해봄]
                3.여기서는 resultType을 쓰는것에, DTO, int, String형만 고민 하기로 하자. map에 관해서는 요새 사용하지 않는다고 한다.
                    또한, 그 외에 것들의 타입들도 필요하면 다시보도록 하자. 제일 많이쓰이는 부분은 DTO이다.
                    [참조문헌 : 스프링부트 시작하기 61pg] / 여기서도 map은 요새 잘 사용하지 않는다 한다.  
                4.int,string 배열의 사용은 나중에 필요할시 따로 보기로 하고(찾아보니 이 배열 잘 안쓰는듯하다. + 배열을써도 아마 매퍼 인터페이스의 메서드 반환형
                    에 적용해서 사용하는것일꺼다.), resultType이 int나 String일때도, 따로 이를 resultType으로 쓰기보다는 dto를 위주로 사용하기로 하자. 
                    dto로 처리시 camelcasesnakecase 가 추가로 붙어져서 dto파일에 맵핑되는건데, 그렇게 큰차이는 없는것으로 보인다.(camelcasesnakecase가 문제시
                    이를 빼면된다.) 또한, 딱히 찾아봐도 int,string으로 써야한다는 문구도 없다. 필요하면 다시 정리하도록 하자.
                    [직접해봄]    
            [추가사항]  
                기본적으로 여기서 짚고 넘어가야할 부분이 있는데, resultType이 DTO, String, int일때와 매퍼 인터페이스를 마이바티스로 구현한 클래스의
                @Override된 메서드의 반환형태, 그리고 이 메서드 안에서 sqlSession으로 selectOne혹은 selectList그리고 selectMap과의 과정을 이해해야 한다.
                우선적으로 selectMap에 대한 내용은 빼도록 하겠다. 아마 이것은 resultType이 Map과 관련된 형태일때 쓰이는것같다.
                    (1).resultType이 DTO, int, String인 경우 그냥 이를 매퍼 인터페이스의 해당하는 메서드의 반환형과 일치하는지 일치하지 않으면
                        익셉션을 발생시키는지의 여부만 따지는 거다. 그러고는 그냥 데이터베이스에서 반환되는 값을 가져오기만 한다.
                        물론, resulltType이 DTO이고 매퍼인터페이스의 메서드의 반환형이 DTO 혹은 List<DTO>인경우 상관없으며, resultType이 int이건, _int이건
                        매퍼인터페이스의 메서드의 반환형이 int이건 Integer이건 상관없는것같다.
                        [직접해봄] / resultType이 int,_int이건 매퍼인터페이스의 메서드의 반환형이 int,Integer이건
                    (2).실제로 매퍼 인터페이스의 메서드의 반환형이 list<DTO>형태이면 매퍼 인터페이스를 구현한 클래스의 오버라이드한 메서드에서 
                        sqlSession.selectList로 값을 받아오는데(이 selectList된것도 반환형이 List<>여서지 resultType에서 정한게 아니다. 즉, 매퍼 인터페이스의
                        반환형이 List<DTO>이냐 <DTO>이냐에 따라 데이터베이스에서 반환하는 개체를 맵핑시키는거지 resultType은 아무 관련이 없는듯하다.) 이 
                        sqlSession.selectList 메서드 안에서 데이터베이스에서 반환되는 값을 list<DTO>형에 맞춰서 값을 매칭시켜서 sqlSession.selectList의
                        반환값으로 반환하게 된다.
                        [참조링크 : https://bigfat.tistory.com/95] / 여기에 Override한 메서드로 selectList등이 나와있다.
                        +
                            {1}.매퍼 인터페이스 반환형이 List<DTO>인 경우 만약 반환되는 개체가 0개인경우 아래 추가사항에 적어놨지만, 데이터베이스에서는 null을 반환하지만,
                                sqlSession.selectList에서는 List<DTO>형의 빈 배열객체로 맵핑이되어 반환값을 반환한다. 즉, List<DTO>의 각 요소들이 null 상태인것같다. 더 자세한건 아래 요약정리3을 보고,
                                참조자료형은 기본값이 null이라고 한다.(String이나 DTO형이나)
                                [참조링크 : https://bigfat.tistory.com/95] / 여기는 dao이지만, 매퍼인터페이스를 구현한 클래스도 이와 같을것으로 본다.
                                [참조문헌 : 자바책 195pg] / 여기서 보면, 참조자료형(Company형)이 아무값도 입력받지 못하면 null이라고 나와있다.
                                [참조링크 : https://linuxism.ustd.ip.or.kr/94] / 참조형 변수의 기본값은 null
                                [참조링크 : https://colossus-java-practice.tistory.com/9] / String형의 기본값은 null
                            {2}.매퍼 인터페이스 반환형이 List<DTO>인 경우 만약 반환되는 개체가 1개인경우 그대로 매퍼인터페이스를 구현한 클래스의 메서드가 그 sqlSessionList()메서드
                                안에서 데이터베이스에서 받아온 값 해당 1개의 arrayList<DTO>형태로 반환해주는것으로 알고있다. 이는 마이바티스에서 자동매핑해주는것으로 매퍼 인터페이스의 메서드의
                                반환형이 DTO이거나 List<DTO>인경우에만 해주는것으로 알고 있다. 
                                [직접해봄]
                            {3}.마지막으로, 매퍼 인터페이스의 반환형이 List<DTO>인 경우 만약 반환되는 개체가 2개 이상인 경우 그대로 매퍼인터페이스를 구현한 클래스의 메서드가
                                그 sqlSessionList()메서드  안에서 데이터베이스에서 받아온 값 해당 2개 이상의 arrayList<DTO>형태로 반환해주는것으로 알고있다. 이는 마이바티스에서 자동매핑해주는것으로 매퍼 인터페이스의 메서드의
                                반환형이 DTO이거나 List<DTO>인경우에만 해주는것으로 알고 있다.
                                [직접해봄]                          
                        +
                        list<>는 인터페이스다. 실제로는 이를 구현한 arrayList등을 사용하여 마이바티스에서는 값을 매칭하고 반환하는것같다. 그리하여, 이것또한
                        메서드의 반환형은 인터페이스형인데 반환되는 값의 형은 이 인터페이스를 구현한 클래스의 형이다. 이 부분도 알아야할 필요가
                        있다면 다시 자세히 보도록 하자. 아래의 참조링크도 list 인터페이스 참조자료형에 arrayList형을 넣는다.
                        [참조링크 : https://woo-yaa.tistory.com/16]   
                        [참조링크 : https://solbel.tistory.com/253]
                        +
                        그리고, mybatis.configuration.map-underscore-to-camel-case=true 가 쓰여서 dto의 camel-case와 데이터베이스의 snake표기법이
                        서로 매칭시켜주는 역활도 이 sqlSession.selectList 혹은 sqlSession.selectOne메서드에서 list<DTO>형 혹은 DTO형에 맞게 값을 매칭시켜줄때
                        작동하는것으로 알고 있다.
                        [직접해봄]
                    (3).이번에는 매퍼 인터페이스의 메서드의 반환형이 DTO형태라면 매퍼 인터페이스를 구현한 클래스의 오버라이드한 메서드에서
                        sqlSession.selectOne로 값을 받아오는데 이 sqlSession.selectOne안에서 데이터베이스에서 반환되는 값을 DTO형에 맞춰서
                        값을 매칭시켜서 sqlSession.selectOne의 반환값으로 반환하게 된다.
                        [참조링크 : https://bigfat.tistory.com/95] / 여기에 Override한 메서드로 selectOne 등이 나와있다.
                        +
                            {1}.매퍼 인터페이스 반환형이 DTO인 경우 만약 반환되는 개체가 0개인경우 그대로 매퍼 인터페이스를 구현한 클래스의 메서드가 그 sqlSession.selectOne()메서드
                                안에서 데이터베이스에서는 반환할 개체가 없으니 null을 반환하게 되어 받아온 null을 BoardDto boardDto인경우 sqlSession.selectList에서
                                실제로, null을 그대로 반환하던지 아니면 DTO형이되 값이 null인것을 반환하던지 할것이다. 그 둘의 차이는 없다. 더 자세한 것은 아래 요약정리3을 보자.
                                [참조링크 : https://bigfat.tistory.com/95]
                            {2}.매퍼 인터페이스 반환형이 DTO인 경우 만약 반환되는 개체가 1개인경우 그대로 매퍼 인터페이스를 구현한 클래스의 메서드가 그 sqlSession.selectOne()메서드
                                안에서 데이터베이스에서 받아온 1개 개체의 값들은 DTO형태에 맞게 맵핑시킨다음에 반환값으로 해당 맵핑된 DTO를 반환하게 된다.
                                [참조링크 : https://bigfat.tistory.com/95]
                            {3}.매퍼 인터페이스 반환형이 DTO인 경우 만약 반환되는 개체가 2개 이상인경우 그대로 매퍼 인터페이스를 구현한 클래스의 메서드가 그 sqlSession.selectOne()메서드
                                안에서 데이터베이스에서 받아온 2개 이상의 개체의 값들은 DTO형태로는 맞출수가 없으니 이 부분에서 익셉션이 발생하는것같다.
                                [참조링크 : https://bigfat.tistory.com/95]                                   
                        +
                        그리고, 위와 마찬가지로 mybatis.configuration.map-underscore-to-camel-case=true 가 쓰여서 dto의 camel-case와 데이터베이스의 snake표기법이
                        서로 매칭시켜주는 역활도 이 sqlSession.selectOne메서드에서 DTO 형에 맞게 값을 매칭시켜줄때 작동하는것으로 알고 있다.
                        [직접해봄]
                    (4).이번에는 매퍼 인터페이스의 메서드의 반환형이 String형태라면 매퍼 인터페이스를 구현한 클래스의 오버라이드한 메서드에서
                        sqlSession.selectOne로 값을 받아오는데 이 sqlSession.selectOne안에서 데이터베이스에서 반환되는 값을 그냥 있는 그대로
                        반환하게 된다. 나머지 컨트롤러나 Service, ServiceImpl 그리고 매퍼 인터페이스의 메서드의 반환형도 String으로 써서,
                        컨트롤러에서 String list = boardService.selectBoardList()의 형태로 값을 받아서 Model.addAttribut("list",list)로 똑같이
                        사용했었다. 사용방법들이 잘 나오지 않아 이렇게만 사용했는데, 나중에 진짜 사용하게 될시 아니면 필요할시에 더 정확하게 찾아보자.
                        [직접해봄]
                        +
                            {1}.만약 데이터에서 반환되는 개체가(당연히 개체가 반환되더라도 개체에서 반환되는 값은 1개다.) 0개 인경우, 데이터베이스에서는 값이 없을경우,
                                null을 반환하고 컨트롤러에서는 결국 String list = boardService.selectBoardList()가 String list = null;이 되게되어,
                                해당 list 변수에는 null 값이 들어가게 된다. 또한, String형의 경우 아무값도 초기화하지 않으면 기본값이 null이고 null값을 받을 수 있다.
                                [직접해봄]   
                                [참조문헌 : 자바책 195pg] / 여기서 보면, 참조자료형(Company형)이 아무값도 입력받지 못하면 null이라고 나와있다.
                                [참조링크 : https://linuxism.ustd.ip.or.kr/94] / 참조형 변수의 기본값은 null
                                [참조링크 : https://colossus-java-practice.tistory.com/9] / String형의 기본값은 null                                
                            {2}.데이터베이스에서 반환되는 값이 1개인 경우, 데이터베이스에서 반환되는 값을 그대로 반환하게 되어,
                                String list = 반환된값 으로 작용하게 되어 그대로 list에 값이 들어가게 된다.
                                [직접해봄]   
                            {3}.데이터베이스에서 반환되는 개체가 2개인 경우, 데이터베이스에서 반환되는 값을 우선은 받는데, sqlSession.selectOne메서드에서
                                둘중에 어느 값을 반환해야 할지 몰라서 익셉션이 발생하는 것으로 알고 있다.
                                [직접해봄]   
                                [참조링크 : https://bigfat.tistory.com/95]                                
                    (5).마지막으로 resultType에서 int와 _int를 쓰는경우를 정리해 보겠다. 우선,
                        resultType에서 별칭int는 실제 integer형을 의미하고 _int별칭은 실제 int형을 의미한다.
                        또한, resultType은 매퍼 인터페이스의 메서드의 반환형과 비교하여 다를경우 익셉션을 발생시킨다 얘기하였는데, 여기서는 
                        resultType이 int이건 _int이건 매퍼 인터페이스의 메서드 반환형이 int이건 Integer이건 예외체크에는 상관없는듯 하다.
                        즉, 매퍼 인터페이스의 메서드 반환형이 int이고 resultType이 int이며, 매퍼 인터페이스의 메서드 반환형이 Integer이고 resultType이 _int일때
                        잘 작동하였다.
                        [직접해봄]
                        +
                        resultType에서 별칭 int를 쓰건 _int를 쓰건 둘중 어느것을 쓰는것은 상관이 없으나 매퍼인터페이스의 메서드 반환형이 
                        무엇이냐는 의미가 있다. 아래의 것들은 모두 resultType이 int이건 _int이건 똑같이 작용하는거다.
                            [참고링크 : https://fabxoe.tistory.com/143] / 마이바티스는 resultType이 int(Integer형)이건 _int(int형)이건 같게처리한다. 또한, resultType이 int이건 _int상관없이 매퍼 인터페이스의 메서드 반환형이 Integer이기만 하면 null값을 받을 수 있다.
                            {1}.우선, 매퍼 인터페이스의 메서드 반환형이 Integer인 경우를 보겠다.
                                (1-1).반환되는 개체가 없어 값이 0개인경우
                                    이 경우는, 아래 요약정리3에서 보듯이 sqlSession.selectOne에서 null값을 반환하게 된다. 그리고, 매퍼 인터페이스의 반환형이 Integer이기
                                    때문에, 이를 받을 수 있어, 컨트롤러의 Integer list의 list가 null값을 가질 수 있게되어 오류가 발생하진않는다.
                                    [참조링크 : https://bigfat.tistory.com/95]
                                (1-2).반환되는 값이 1개인경우
                                    이 경우는, sqlSession.selectOne메서드에서 Integer형이면서 해당 데이터베이스에서 반환되는 값을 가진 Integer형을
                                    만들어서 반환하는것같다.(자바 책에서 보듯이 Integer형 변수에 바로 정수값을 넣을수는 없다.) 그리고나서, 머스테치에서
                                    {{list}}로 쓸때도, 알아서 Integer형 변수에서 값을꺼내는 메서드로 해당 정수값을 꺼내는것같다.(실제로 바로 쓸 수 없기때문)
                                    [직접해봄]   
                                    [참조문헌 : 자바책 375~377pg]   
                                {1-3}.반환되는 값이 2개 이상인경우  
                                    이 경우는, sqlSession.selectOne메서드에서 Integer형이면서 해당 데이터베이스에서 반환되는 값을 가진 Integer형을   
                                    만들어서 반환해야 하는데, 값이 2개이상이니 예외가 발생하게 되는거다.                       
                                    [직접해봄]
                            {2}.다음은, 매퍼 인터페이스의 메서드 반환형이 int인 경우를 보겠다.
                                {2-1}.반환되는 값이 0개인경우
                                    이 경우에는, 아래 요약정리3에서 보듯이 sqlSession.selectOne에서 null값을 반환하게 된다. 그러나, 매퍼 인터페이스의 반환형이 Int이기
                                    때문에, 이는 바로 예외를 발생시키게 된다.
                                    [직접해봄]
                                {2-2}.반환되는 값이 1개인경우
                                    이 경우는, sqlSession.selectOne메서드에서 그대로 데이터베이스에서 받아온 값을 그대로 반환값으로 쓰게되서
                                    해당 값을 매퍼 인터페이스의 메서드의 반환값으로 쓰게 되서 적용하게 된다.
                                    [직접해봄]
                                {2-3}.반환되는 값이 2개 이상인경우    
                                    이 경우는, sqlSession.selectOne메서드에서 받아온 값을 그대로 반환하게 되있는데, 
                                    값이 2개 이상이니 예외가 발생하게 되는거다.
                                    [직접해봄]                                                               
                 [요약정리 & 추가정리]
                    1.필요한 부분을 정리해보면, 1.매퍼 인터페이스가 있고, 2.이를 마이바티스로 구현한 클래스가 있고, 3.이 구현한 클래스안에 @Override한 메서드가 있고
                        해당 @Override한 메서드 안에는 또 반환되는값이 sqlSession.select~() 형태로 해당 메서드에서 반환하는 값으로 @Override메서드의 반환되는 값으로 쓰이는거다.
                        그러면, 쿼리문을 이용한 resultType으로 인해 받아오는 값들은 그대로 거기에 있고 그다음 필요할시에 sqlSession.select~()메서드에서 맵핑을 해서 나오거나
                        (DTO, List<DTO>의 경우) 아니면 그냥 값(String,int)을 반환하여 @Override한 메서드의 반환값으로 쓰이게 되는 구조다.
                        [참조링크 : https://bigfat.tistory.com/95]
                    2.resultType의 별칭은 아래 참조링크에 정리되어 있다.
                        [참조링크 : https://java119.tistory.com/45]   
                        [참조링크 : http://www.devkuma.com/books/pages/740]   
                        [참조링크 : https://araikuma.tistory.com/475]  
                    3.직접 resultType이 int, _int, string, DTO일때 상관없이 모두 데이터베이스에서 반환할 값이 없을때 
                        null이 반환되어 데이터베이스에서 받아온 값이 null이 되게 된다.
                        [참조링크 : https://tomining.tistory.com/152] / 데이터베이스에서 select쿼리문으로 반환할 값이 없으면 null을 반환한다. 이는 resultType이 int인것외에도 항상 그러는듯하다.  
                        [참조링크 : https://araikuma.tistory.com/475] / 검색결과값이 하나도 없는 경우 데이터베이스에서는 null을 반환한다.
                        문제는 그 다음인데, 매퍼 인터페이스의 메서드의 반환형에 따라서 sqlSession.selectOne이나 sqlSession.selectList메서드에서 다르게 맵핑하여
                        반환값을 반환한다는거다. 
                            (1).매퍼 인터페이스의 메서드의 반환형이 List<DTO>일때
                                만약 데이터베이스에서 반환되는 개체가 없어서, null이 반환된경우에 sqlSession.selectList 메서드에서는 그냥 null값을
                                반환하는게 아니라, List<DTO>형의 빈 배열을 반환값으로 낸다.
                                실제로,
                                List<BoardDetailDto> list = boardDetailService.selectBoardDetailList();
                                        if(list.size()==0){
                                            System.out.println("배열이 비어있다.");
                                        }
                                와 같이, 컨트롤러에 적용했더니, 해당 출력문이 출력됬었다.
                                [직접해봄]
                                +
                                처음에는 
                                serviceImpl에서 
                                if(boardDetailMapper.selectBoardDetailList()==null){
                                    System.out.println("반환값이 null이다.");
                                }
                                이렇게 그냥 List<DTO>도 sqlSession.selectList에서 null값만 반환되는줄알고 이렇게 했는데 막상
                                실행해보니 저 출력문이 나타나지 않았다. 어느 글에서 봤는데 List<DTO> list==null인 경우는 아예 DTO도 조차
                                선언되지 않은거라고 했다. 그래서 null이 성립이 안되었던것같다.(이 부분 필요시 더 자세히 보기)
                                또한, 애초에 list<DTO> list==null인 상태면, list.isEmpty()나 list.size()조차도 익셉션을 발생시킨다한다.
                                [참조링크 : https://ssamdu.tistory.com/9] / List<DTO> list가 null이면 .size()나 .isEmpty()같은 메서드 예외발생시킴
                                [직접해봄]
                                +
                                (위의 내용들 깔끔하게 정리)
                                1.우선적으로 아래의 참조링크를 보면, 자바의 자료형에 따른 초기화를 하지 않을시에 기본값이 나와있다. 참조자료형의 기본값은 null으로
                                    찾아봤지만, 나오지 않아 제네릭클래스 혹은 제네릭 배열클래스도 참조자료형이라 여기고 초기화가 안됬을때 기본값이 null이라고 보았다.(
                                    이 부분 틀릴수 있으니, 나중에 필요시 다시보기) 그런데 웃긴건, 자바나 스프링부트에서 int형이건,String형이건 List<>이건 변수에 초기화를 안하면
                                    System.out.println이나 if문 안에 아예 못쓰도록 되있었다. 이 점 인지하고 가자.
                                    [직접해봄] / 스프링부트, 자바 모두 초기화안할시에, if문 system문 등에 사용이안됨
                                    [참조링크 : https://enjoyplaying.tistory.com/18] / 자바의 자료형에 따른 기본값
                                2.LIST<BoardDto> list = new ArrayList<BoardDto>라고 한다고 하면, 이 문장의 의미는 list는 ArrayList<BoardDto> 인스턴스를 담고 있되,
                                    요소는 아직 아무것도 없는거다. 즉, 각각의 요소는 자료형이 BoardDto이나 null상태인것이다.  이 상태에서 list.size()를 하게되면(list의 추가된
                                    요소 전체 개수를 반환한다.) 값이 0이 나오고 list.isEmpty()를 하게 되면(해당 배열에 요소가 1개라도 있으면 boolean값으로 false, 0개이면 true를 반환한다.),
                                    true를 반환한다. 이 .size()와 .empty()메서드는 list의 값이 null인 경우에는 아예 익셉션을 발생시킨다. list의 값이 null인 경우에는   
                                    List<BoardDto> list 에서 아예 ArrayList<BoardDto>로 초기화를 하지 않았거나, List<BoardDto> list=null; 로 null값을 넣어줬을때 인경우다.
                                    [직접해봄] / list에 null값이 들어간다.
                                    [참조링크 : https://ssamdu.tistory.com/9] / list가 null인데 .size()나 .isEmpty()메서드를 사용하면 에러가 발생한다.
                                3.또한 스프링부트 시작하기 초록책 컨트롤러의 List<BoardDto> list에서 list에 들어가는 실제 값은 ArrayList<BoardDto> 클래스의 인스턴스이다. 
                                    list자체는 인터페이스로 인스턴스가 생성이 될 수가 없기에, 자료형만 list로 해놓고 실제로는 ArrayList<BoardDto>의 클래스의 인스턴스가 들어가는것이다. 
                                    아래의 참조링크를 봐도 list에 들어가는 값들에 ArrayList를 대입하는 것으로 보아 주로 list인터페이스에 대입하는 인스턴스가 ArrayList이고, 자바 책에도 
                                    ArrayList가 가장 많이 쓰인다고 나와있다. 위에서 list.size()나 list.isEmpty()를 쓰는것도 전부 list인터페이스에
                                    있는 메서드로 ArrayList클래스에서 @Override하여 사용할 수 있게 되는것으로 본다.
                                    [직접해봄]   
                                    [참조문헌 : 자바책 409pg] / 가장 많이 쓰이는 객체 배열이 ArrayList
                                    [참조문헌 : 자바책 222pg] / ArrayList클래스의 주요 메서드로 size()와 iesEmpty()가 있다.
                                    [참조링크 : https://woo-yaa.tistory.com/16]   
                                    [참조링크 : https://ssamdu.tistory.com/9]   
                                4.List list나 List list = new ArrayList()처럼, 제네릭을 사용하지 않고도 사용할 수 있으나, 사용방법이 조금 더
                                    복잡하기 때문에, 잘 사용하지 않는다고 한다. 자바 책을봐도, 제네릭이 붙은것을 항상 사용하는 것으로 나와있다. 그러니, 이 부분에
                                    대해서는 나중에 필요할 시 다시 보도록 하자.
                                    [참조링크 : https://coding-factory.tistory.com/551]   
                                5.추가로 ArrayList<E> 클래스의 경우에 new ArrayList<BoardDto>를 하게되면, BoardDto를 담을 수 있는 객체 배열이 만들어지게
                                    되는것이다. 단, 배열의 각각의 요소는 주어진 정보로 보았을때 BoardDto형이고 값들은 아직 들어가있지 않는 null인것으로 볼 수 있다.
                                    또한, List<E> 즉, List<BoardDto> 의 경우는 ArrayList<T>와 같은 형태로보되, 메서드들은 아직 구현되지 않은것으로 보면 ㄴ될 것 같다
                                    [직접해봄]   
                                [결론]
                                    매퍼 인터페이스의 메서드의 반환형이 List<DTO>인 경우에, 만약에 DBMS에서 해당하는 조건이 없어서 반환하는 값이 null이게 되면,
                                    sqlSession.~()메서드에서 null값을 반환하는게 아니라 ArrayList<DTO>인데 요소는 null 상태인 값을 반납하게 되는거다. 즉, 
                                    List<BoardDto> list = new ArrayList<BoardDto> ();의 경우에 list는 null의 값을 갖는것은 아니게 된다. 그렇다면, 
                                    위의 내용에서,
                                    List<BoardDetailDto> list = boardDetailService.selectBoardDetailList();
                                        if(list.size()==0){
                                            System.out.println("배열이 비어있다.");
                                        }                                   
                                    의 경우 DBMS에서 반환하는 값이 null밖에 없는 경우에 if조건문이 성립하여서 "배열이 비어있다."가 정삭적으로 출력되는거다.
                                    또한, 위의
                                    if(boardDetailMapper.selectBoardDetailList()==null){
                                        System.out.println("반환값이 null이다.");
                                    }     
                                    의 경우에는, 여기도 DBMS에서 반환하는 값이 없어서 null만 반환되는건데, 이 경우에 sqlSession관련 메서드에서 ArrayList<BoardDto>의
                                    요소가 빈 배열 인스턴스를 반환하는 것이기에, null과는 같지않아 System.out.println이 출력되지 않는것이다.    
                                    [직접해봄]                              
                            (2).매퍼 인터페이스의 메서드의 반환형이 DTO일때
                                이 경우에는 아래의 출력문이 그대로 출력되었다.(데이터베이스에서 반환되는 개체가 없었을때)
                                serviceImpl에서 
                                if(boardDetailMapper.selectBoardDetailList()==null){
                                    System.out.println("반환값이 null이다.");
                                }
                                이 경우에는 실제로 sqlSession.selectOne메서드에서 null이 반환된건지 아니면 null값이 들어있는
                                DTO형이 반환된것인지는 모르나 그 부분을 크게 중요할것 같지 않다.
                                [직접해봄]
                            (3).매퍼 인터페이스의 메서드의 반환형이 String일때
                                이 경우에는 아래의 출력문이 그대로 출력되었다.(데이터베이스에서 반환되는 개체가 없었을때)
                                serviceImpl에서 
                                if(boardDetailMapper.selectBoardDetailList()==null){
                                    System.out.println("반환값이 null이다.");
                                }
                                이 경우에는 실제로 sqlSession.selectOne메서드에서 null이 데이터베이스에서 받아온 값 그대로 반환한것같다. 
                                [직접해봄]                                   
                            (4).매퍼 인터페이스의 메서드의 반환형이 Integer일때
                                이 경우에는 아래의 출력문이 그대로 출력되었다.(데이터베이스에서 반환되는 개체가 없었을때)
                                serviceImpl에서 
                                if(boardDetailMapper.selectBoardDetailList()==null){
                                    System.out.println("반환값이 null이다.");
                                }
                                이 경우에는 실제로 sqlSession.selectOne메서드에서 null이 데이터베이스에서 받아온 값 그대로 반환한것같다. 
                                [직접해봄]       
                            (5).매퍼 인터페이스의 메서드의 반환형이 int일때
                                이 경우는 데이터베이스에서 반환된 null을 sqlSession.selectOne에서 그대로 값으로 반환하는데,
                                이 경우에는 매퍼 인터페이스의 메서드의 반환형이 int이기 때문에 이를 구현한 클래스의 @Override의
                                메서드의 반환형도 int여서 sqlSession.selectOne에서 반환한 null값때문에 오류를 일으키는것같다.
                                [직접해봄]  
                    4.String과 int형 그리고 Integer형은 나중에 실제 사용하게 되면 그때 더 자세하게 알아보도록하자.
                        위의 사용법들은 DTO와 list<DTO>기반으로 내가 직접한거라 예시를 찾아볼 필요가 있다.
                    5.이 resultType에 대한 속성은 <insert>,<update>,<delete>,<select>의 태그중에 select에만 있는 속성으로 알고있다.
                        아래 참조링크에도 그렇게 나오고, 스프링부트 시작하기 초록책에도 <select>에만 resultType이 나와있다.
                        아래 (4).의 추가사항에도 나와있다.
                        [참조문헌 : 스프링부트 시작하기 초록책]   
                        [참조링크 : https://sjh836.tistory.com/128]   
        (4).resultMap에 대해서 잠깐 보고가겠다.
            {1}.resultMap은 resultType대신에 쓸 수 있는것으로, 보니까 <select>문에 쓰이고 그 외에
                <insert>, <delete>, <update>문에는 쓰이지 않는것 같다. 만약에 쓰이게 된다면 다시와서
                다시 정리해보도록하자.
                [참조링크 : https://m.blog.naver.com/10hsb04/221718179519]
            {2}.간단하게, 기능을 설명하자면 마이바티스는 구현된 매퍼 클래스에서 값을 반환하기 전에 알아서
                List<dto>, dto등을(String이나 int형의 배열은 제외하자. 그건 사용하게 되면 그때보기) 데이터베이스에서
                갖고온값과 매핑을 시켜주는데, resultType은 DTo클래스가 갖고있는 setter메서드로 자동 맵핑되고, resultMap방식은
                일일히 직접 명시해줘서 맵핑을 해주는 방식이다. 또한, DTO방식밖에 모르는데,
                만약에 사용해야 한다면 아래 링크로 더 자세히 알아보자. 
                [참조링크 : https://dorongdogfoot.tistory.com/124]   
                [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
                [참조링크 : https://reference-m1.tistory.com/178]
            {3}.아래 참조링크를 보면, resultMap에서는 서로 맵핑해주려는 필드값들이 대소문자를 구분했었는데,
                resultType은 대소문자를 구분하지 않았다고 한다. 어차피 카멜 표기법과 스네이크 표기법을 통합해주는 방식을
                사용하여 문제는 없지만 이렇다는것만 알고 넘어가자.
                [참조링크 : https://m.blog.naver.com/10hsb04/221718179519]   
            {4}.그러나, 주로 resultType을 사용하고 resultMap은 잘 사용하지 않는거로 알고있다.
                만약에 나중에 사용해야 하는 경우가 나온다면 어떤 경우인지 알고 다시 정리하도록 하자.   
        [추가사항]
            resultType 혹은 resultMap은 <select>문에만 쓰이는것으로 <insert>, <delete>, <update>에는 쓰이지 않는다고 한다.
                만약에 이를 다시 봐야하는 상황이 오면 다시 정리하도록 하자. 위의 요약정리&추가정리의 5.에도 정리해 놓았다.
                [참조링크 : https://m.blog.naver.com/10hsb04/221718179519]     
.
.
.
1-2.SELECT에 대하여
    (1).SELECT문을 사용하는 기본 구조에 대해 먼저 알아보겠다. 기본적으로
        (구조)
        SELECT 필드이름
        FROM 테이블이름
        [WHERE 조건]
        (실제예)
        SELECT 
            board_idx,
            title,
            hit_cnt
        FROM
            t_board
        WHERE
            deleted_yn='N'
        와 같은 구조를 갖는다. 
        [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]    
        [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=dd1587&logNo=221159671370&proxyReferer=https:%2F%2Fwww.google.com%2F]    
        [참조문헌 : https://eongeuni.tistory.com/21]    
            (1-1).FROM은 테이블의 이름을 명시하여 어떠한 테이블에서 필드를 갖고올것이냐를 지정하는
                것으로, 위의 실제 예에서 보는것처럼 ''를 붙이지 않고 테이블명만 적어주어야 한다. 또한,
                SELECT와는 다르게 *와 같은값을 사용하는것을 본적이 없으며, 꼭 테이블 명을 써주어야 하는것으로
                알고있다. 또한 위치도 SELECT 키워드 바로 뒤에 명시한다고 한다. 보니 테이블명도 ,로 여러개 쓸 수
                있는것 같으나 그건 그때가서 필요할때 다시보기
                [직접해봄] / ''를 테이블명과 함께쓰면 에러가 난다.
                [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]    
                [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=dd1587&logNo=221159671370&proxyReferer=https:%2F%2Fwww.google.com%2F]    
                [참조링크 : https://velog.io/@ss-won/DatabaseMySQL-MySQL-SELECT%EB%AC%B8%EC%97%90-Function-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0]    
            (1-2).SELECT 다음에 쓰는 필드이름에는 선택할 필드, 즉, 갖고올 컬럼을 적는것이다. 여기에는 또한
                ''를 적으면 안되는것으로 알고있고, 다른 참조링크와 스프링부트 시작하기 초록책 69pg를 봐도 SELECT다음의
                필드이름에 ''가 안붙여져 있다. 그러나 ''를 붙이고 직접해봤는데 에러가 나진 않는다. 그래도 왠만하면''를
                적지않는 방향으로 나아가자. 또한 ,를 사용하여 여러필드를 적을 수 있고 마지막 필드에 대해서는 , 를 붙이지 않는다.
                [직접해봄] / 필드이름에 ''를 붙였는데도 에러가 나지않았다.
                [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]   
                [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=dd1587&logNo=221159671370&proxyReferer=https:%2F%2Fwww.google.com%2F]     
                +
                resultType에도 설명해놨지만, 기본적으로 매퍼인터페이스의 메서드의 반환하는 형에 대해서는 List<DTO>나 DTO, String, Int
                에 대해서만 고려하기로 했다. 개체라는것도 고려하면 좋을 것 같다. 즉, 여기서 SELECT에 대해서 이해할때도 이 주어진 4개의 형에 대해서 고민하도록하고 필요한경우에는
                그때다시 가서 정리하도록 하겠다. SELECT다음에 아무 필드명을 적지않고 *를 적게되면 모든 필드에 대해서 값을 가져오라는 뜻이다.
                [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=dd1587&logNo=221159671370&proxyReferer=https:%2F%2Fwww.google.com%2F]   
                [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]   
                +
                여기엔, 추가로 SELECT 다음에 오는 값들에 대해 데이터베이스에서 SELECT 쿼리문에 대한 결과값 반환시에 어떻게 컬럼명과
                값들에 반영되는지에 대해 추가로 알아보겠다.
                    1.단일 컬럼명만 적혀져 있는경우
                        ex)
                        SELECT board_idx FROM ~ WHERE ~
                        이 경우에 제일먼저 데이터베이스에서 SELECT 쿼리문에 대한 WHERE절을 만족하는 개체에 대해서만 적용하게된다.
                        그럼 만족하는 개체에 대하여 반환할 목록을 작성하게 되는데, 반환되는 컬럼명에 board_idx를 그대로 반영하여 board_idx를
                        컬럼명으로 쓴다. 또한, 각 개체마다 board_idx의 컬럼명에 해당하는 것의 값을 반환하여 SELECT리스트에 나타내게 되는것이다.
                        근데 여기서는 board_idx가 아닌 board_idxa처럼 해당 테이블에 속한 컬럼명이 아니면 에러가 나게된다.
                        [직접해봄]    
                    2.''로 값이 따옴표된것만 있는경우
                        ex)
                        SELECT 'board_idx' FROM ~ WHERE ~
                        이 경우에 제일먼저 데이터베이스에서 SELECT 쿼리문에 대한 WHERE절을 만족하는 개체에 대해서만 적용하게된다.
                        그럼 만족하는 개체에 대하여 반환할 목록을 작성하게 되는데, 반환되는 컬럼명에 '값'이 단일로만 있다면 이 값만을
                        그대로 반영하여 컬럼명으로 쓰이게 된다. 즉, ''만 없애고 그 안의 값만을 컬럼명으로 쓰게 되는거다. 그 후에 각 개체마다
                        값을 반환해 주어야 하는데, 이 경우에는 'board_idx' 자체가 값이기 때문에 문자열 board_idx가 반환되는 값이게 되는거다.
                        (당연히 ''는 안써져있다.) 그렇기에 모든개체에 대해 board_idx라는 컬럼명의 값들은 모두 board_idx가 되는거다.
                        [직접해봄]
                    3.컬럼명과 숫자와 연산이 함께 있는경우
                        ex)
                        SELECT board_idx + hit_cnt - 100 FROM ~ WHERE ~
                        이 경우에 제일먼저 데이터베이스에서 SELECT 쿼리문에 대한 WHERE절을 만족하는 개체에 대해서만 적용하게된다.
                        그럼 만족하는 개체에 대하여 반환할 목록을 작성하게 되는데, 반환되는 컬럼명에 위에 해당하는 board_idx + hit_cnt - 100이 
                        그대로 적용된다. 즉, ''가 붙지않은 해당 테이블의 필드명과 사칙연산과 나머지연상(/,*,%,+,-) 그리고 숫자에 대해서는 그대로
                        반환할 컬럼명에 그대로 쓰이는것 같다. 그 다음 값을 반영할때는 개체마다 개체의 ''가 붙지않은 값들과 일치하는 필드에 대해 해당 테이블의 
                        값을 불러와 숫자들과 사칙연산및 나머지연상을 모두 끝낸 값을 해당 개체의 값으로 반환한다. 여기서는 board_idx나 hit_cnt모두 int와 smallint
                        형이였는데 board_idx+hit_cnt+100억도 됬었고, hit_cnt가 smallint형이였는데도 hit_cnt+1억도 됬었다. 즉, 우선 컬럼명과 숫자의
                        연산결과에 대해서는 컬럼명이 int와 smallint에 대해서만 해봤으며, 나중에 필요할 시 다른형도 해보고, int형이나 smallint형의 범위와는 상관없이
                        SELECT에서 반환하는 값에 대해서는 다른방식의 형으로 해당 숫자값을 반환하는것같다. 이것도 여기까지만 알고 나중에 필요시 다시 보도록 하자.
                        또한, 여기서도 board_idxa + hit_cnt -100처럼 썻더니 에러가 났다. 즉, 여기서도 ''가 없는 값에 대해서는 컬럼명과 동일해야지 아니면 에러가난다.
                        [직접해봄] / 사칙연산과 나머지연산도 모두 직접해보았다. 
                        [참조링크 : https://blog.yena.io/studynote/2018/10/02/MySQL-SELECT(2).html] / SELECT로 컬럼을 선택할 때, 컬럼의 값에 사칙연산과 나머지 연산을 이용한 값을 반환할 수 있다.
                        +
                        추가로,이런 연산이 있는 경우 ()로 묶어주어 가독성이 좋게 하기도 한다고 한다. 직접해보니, 사칙연산과 나머지연산도
                        전부작동했으며, SELECT (hit_cnt*100+board_idx%100) FROM ~ 도 되는것을 보니, 위의 int형과 smallint형 됬던것처럼
                        똑같은 조건으로 가능한것 같다. 다만 다른점은, SELECT 쿼리문 반환값을 만들때 컬럼명이 (hit_cnt*100+board_idx%100)로 
                        ()가 포함되서 나온다는거다.
                        [직접해봄]   
                        [참조링크 : https://victorydntmd.tistory.com/137]       
                    [추가정리]    
                        1.SELECT ~ FROM - 에서 ~에서 ''가 붙지않은 값은 해당 테이블의 필드명으로만 쓰이는것같다. 여기서 ''가 붙지않은 값에 대해
                            해당 테이블의 필드명과 일치하는게 없으면 에러가 발생하였었다. 만약 다른 사항이 있으면 그때가서 정리해보도록 하자.
                            [직접해봄]   
                        2.이외에 나머지 추가 알아야할 필요한 사항들에 대해서는 필요할 때 다시 정리하도록 하자.
            (1-3).WHERE절은 사용하게 되면, FROM의 해당 테이블에서 WHERE다음의 조건에 해당되는 개체만의 SELECT 다음에 적는 필드를 반환한다고 한다. 
                1.즉, 여기서 봤을때 SELECT로 반환하는 값들은 개체단위라는것을 알 필요가 있어보인다. 그렇다면, 통상
                    개체의 여러 다른 컬럼을 활용하여 WHERE을 설정하는 경우가 많을 것이다. 또한 WHERE절에서 사용하는 컬럼명에 대해서 ''를
                    사용하니 에러가 났었다. 또한, WHERE절은 사용해도 되고 사용하지 않아도되나 사용하지 않을경우 특정 테이블의 개체중에서
                    해당하는 SELECT다음의 필드의 값을 모두 반환하게 된다.
                    [직접해봄] / WHERE절에서 사용하는 컬럼명에 대해서 ''를 사용하니 에러가 났었다.
                    [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select] / WHERE에 대한 내용 , WHERE는 써도되고 안써도되는 것   
                    [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=dd1587&logNo=221159671370&proxyReferer=https:%2F%2Fwww.google.com%2F]   
                    [참조문헌 : 스프링부트 시작하기 69pg, 81pg] / 실제 예
                    +
                    또한, WHERE 절에는 여러 개의 조건을 같이 명시할 수도 있는데, 여러개의 조건을 사용할 경우 AND나
                    OR연산자를 이용하여 연결한다. AND의 경우는 AND로 묶어진 조건들이 모두 성립하는 개체에 한해 SELECT다음에
                    적혀진 필드값을 반환하고, OR로 묶여있는 경우 OR로 묶여있는 조건들 중에 하나만이라도 성립한다면, 성립하는
                    해당 개체의 SELECT 다음에 적혀진 필드값을 반환하게 된다. 또한, WHERE절에 쓰여진 필드들이더라도 SELECT 바로 다음에
                    WHERE에 썻던 똑같은 필드를 사용할 수 있다. 즉, 동시에 사용도 가능하다. 근데 이건 아래 순서얘기를보면 동시가 아니다.
                    [참조문헌 : 스프링부트 시작하기 초록책 81pg]   
                    [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]   
                    [참조링크 : https://inforyou.tistory.com/28]   
                    [참조링크 : https://velog.io/@p4stel-dev/MYSQL-%EC%A1%B0%EA%B1%B4%EC%A0%88%EC%9D%98-%EC%A1%B0%ED%95%A9]    
                    +
                    데이터베이스에서 SELECT ~ FROM ~ WHERE의 쿼리문 순서별 해석과 함께 WHERE에 대해 이해해야 할 부분이 있는데
                    FROM에서 특정 테이블을 선택하고 모든 개체들이 선택된 상태에서 WHERE 조건절이 들어가면 해당 조건절에 만족하는 개체들만
                    또 목록들이 선택된다.(당연히 WHERE가 없으면 해당 테이블의 모든 개체가 선택된다.) 이때 WHERE 에는 해당 테이블에 속한
                    컬럼명으로 조건을 만들 수 있는데, 각 개체별로 해당 컬럼이 이 WHERE절을 만족해야 개체가 선택되는거다. 이 외에 다른 방법들이
                    있는경우 그때가서 생각해 보자.
                    [직접해봄]   
                    [참조문헌 : 스프링부트 시작하기 초록 책 69pg]   
                    [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]  
                2.WHERE절에는 해당 테이블의 컬럼들을 사용할때, 다음과 같은 비교 연산자를 사용하여 조건식을 나타낼 수 있다.(그 외에 다른것 있을시 그때 정리하기) 
                    바로 =,<,>,<=,>=,<>이다.(그 외에는 필요할 시 더 찾아 보도록 하겠다.) =는 같다. >는 왼쪽값이 크다, <는왼쪽같이 작다,
                    >=는 왼쪽같이 크거나같다, <=는 왼쪽값이 작거나 같다. 그리고 <>는 다르다의 의미이다. 여기서 이 <와 >를 사용하기 위해서는
                    xml파서를 고려해주어야 하는데, ,xml파서의 내용을 보고오니 CDATA를 이용하거나 &gt;와 같이 사용해야 한다고 다른 정리글에 나와있다.
                    이 점 참고하도록 하자. 또한, <>는 같지않다의 의미와 같다. 즉, =의 반대의미로 직접사용해보았다. 거기에, 위의 비교연산자 5개는
                    board_idx,hit_cnt로 int형과 smallint형만 직접 해봤지만 tinyint형이나 mediumint형에도 무리가 없을것이 애초에 비교연산자쓸때 해당 필드에
                    속하는 값을 필드대신에 놓고 그러고나서 타입상관없이 순수 값만을 비교하기에 상관없을것으로 보인다.(아닐경우 수정) 날짜형 데이터타입사용은 그때가서 필요할시에
                    다시 정리하도록하자. 마지막으로 이 =나 <> 비교연산자로 CHAR뿐만이아닌 TEXT형 VARCHAR형 모두 정상작동하였다. 이 문자형 데이터타입도 내가 쓰고자 하는
                    형의 문자형은 모두 되는것으로 보아 여기도 해당 필드의 값을 필드대신 넣고 그다음에 연산자로 비교하기에 가능한것 같다.
                    [직접해봄] / =<,=>로 =의 위치를 바꿔서 직접 사용해봤는데(다들 <=,>=로 사용하길래), 에러가 발생했다. 이 경우에는 =>이나 =<를 아예 다른 의미로 해석하는것같다. + 추가로 바로 위의 내용들해봄
                    [참조링크 : https://blog.yena.io/studynote/2018/10/02/MySQL-SELECT(2).html]    
                    [참조링크 : https://jjeongil.tistory.com/917]   
                    [참조문헌 : 스프링부트 시작하기 초록책 69pg]       
    (2).SELECT문으로 선택한 결과를 정렬하는 방법
        여기에서는 SELECT문으로 선택한 결과를 ORDER BY절을 사용하여 정렬하는 방법을 설명하도록 하겠다.
        즉, 다른말로 하면 한 필드를 기준으로 잡고 이 필드의 오름차순이나 내림차순으로 개체들의 순서를 나열하는거다.
        그러니 사용시에, ORDER BY 명령어를 사용하여 나타내야만 하며, 그 뒤에는 필드명 ASC 또는 필드명 DESC라고 사용 하며,
        아예 ORDER BY 라고만 붙여주어도 된다.(기본값 ASC) 아래 참조링크를 보니 필드명이 하나가 아닌 여러개의 필드명을 ORDER BY로 사용하기도
        한다는것 같은데 그건 그때가서 필요한 경우에 다시 보도록 하자. 또한, ORDER BY는  WHERE절이 있는 SELECT문에 대해서는 WHERE절의 다음에 쓰며,
        WHERE절이 없는 경우에는 FROM 다음에 쓰는것으로 보인다.
        [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select] / FROM 다음에 ORDER BY를 쓰는 예시 , 
        [참조문헌 : 스프링부트 시작하기 초록책 69pg] / 예시 ,    
        [참조링크 : https://eongeuni.tistory.com/21] / ORDER BY하고 필드명 여러개인 경우도 있다 ,
            (2-1).ORDER BY가 사용되지 않은경우 
                ORDER BY가 사용되지 않고 SELECT문을 쓰는경우에는, 데이터베이스의 테이블에 있는 순서대로 그대로
                값을 반환한다. 즉, 테이블에는 위에서 아래로 순차적으로 개체들이 정리되있고, INSERT로 값을 넣으면
                제일 최신 개체는 테이블의 맨 아래에 저장된다. 이 순서대로 그대로 값을 반환한다는 것이다.
                [직접해봄]
            (2-2).ORDER BY 필드명 DESC
                해당 필드의 내림차순으로 결과값을 반환받고 싶을때에 사용한다. 숫자형 데이터타입에 쓰는 경우, 맨위의 값이 제일 높고 그 아래로 갈 수록
                점점 값들이 작아지면서 내림차순으로 값을 반환할때 사용한다. 
                [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]    
                [참조링크 : https://eongeuni.tistory.com/21]      
            (2-3).ORDER BY 필드명 (ASC)
                해당 필드의 오름차순으로 결과값을 반환하는건데, 오름차순이란 말 그대로 맨위의 값이 차순으로 따졌을때 제일낫고 그 다음 아래로 갈 수록
                차순으로 따졌을때 점점 값이 갈 수록 증가하게 되는거다. ORDER BY라는 예약어를 사용하고 필드명만 적어주는경우 ORDER BY의 기본값인 오름차순을
                적용하고, 그냥 ORDER BY 필드명 ASC라고 적어주어도 된다. 즉, ASC를 적어주지않더라도 ORDER BY기본값이 ASC여서 ASC를 적용한다.
                [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select] / 실제 예 , ORDER BY의 기본값은 ASC이다.  
                [참조링크 : https://eongeuni.tistory.com/21]      
            (2-4).이 ORDER BY명령어와 테이블의 collation 값과의 연관성도 알아야 한다.
                우선적으로, 테이블의 collation은 애초에 데이터베이스의 문자열 셋 정리할때, 그때 지정한 collation값이
                테이블의 collation값에 반영이 되는거다. 내가 해놓은 collation 문자셋은 utfmb4_general_ci인데, 이는 utfmb4_unicode_ci
                와는 다른점이 무엇이냐면, 우선 공통점은 숫자나,한글,영어,일본어,중국어등에 대해서는 정렬 방법이 같으나 이모지, 잘 안쓰는 외래어에 대한
                정렬은 utf8mb4_unicode_ci에만 되있는거다. 그럼, SELECT로 테이블에서 필요한 값들을 갖고오고, ORDER BY 예약어를 사용하게되면, 
                이때의 정렬기준이 테이블의 collation에 따라 맞춰가게 되는거다. 근데, 우리가 ORDER BY로 사용하는 것은 숫자형 데이터이므로, 한글,
                영어, 일본어, 중국어에 사용하는것도 아니고 넘어서 이모지에 사용하는것도 아니니, utf8mb4_unicode_ci가 아닌 utf8mb4_general_ci
                에 대한 고민을 할 필요는 없어보인다.
                [직접해봄]    
            (2-5).통상 이 ORDER BY 예약어를 쓰는 경우는, 숫자에만 주로 사용하는것으로 알고있으며, 만약에 다른 유형의 데이터에도 사용한다면 그때가서 보도록하자.
                또한, SMALLINT나 INT에 대해서는 직접해보아서 ORDER BY가 잘 쓰였으나, 그 외에 MEDIUMINT나 TINYINT에도 무리없이 적용될 것으로 보고있다.
                만약에 이 또한 문제가 될시에 그때가서 다시보도록 하자. 또한, 다른 설명글에서 숫자형 데이터타입에서 이 4가지 유형이 주로 쓰이는것으로 알고있다.
                [직접해봄]       
            (2-6).ORDER BY하고 필드명을 적어주는 란에, '필드'처럼 따옴표를 붙여줘도 그대로 정상작동하고 에러가 나지 않았다.
                그렇지만, 아래의 참조문헌이나 다른 참조링크를 봐도 대부분 ORDER BY하고 컬럼명 적는란에 ''를 안붙이니 실제 사용할때는
                붙이지 않는게 좋겠다.
                [직접해봄] / 따옴표 붙여서 직접해봄
                [참조문헌 : 스프링부트 시작하기 초록책 69pg]   
                [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]  
                [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=dd1587&logNo=221159671370&proxyReferer=https:%2F%2Fwww.google.com%2F]    
            (2-7).아래 참조링크를 보면, ORDER BY를 시간데이터 타입의 필드에도 사용을 한다. 아래 참조링크는 년-월-일 순으로 나와있는데, 여기서
                오름차순으로 적용을 하니 맨위의 값이 제일 나중의 시간이고 아래로 갈 수록 점점 현재에 가까워지는 시간이다. 그럼, 내림차순으로
                하면, 맨위가 제일 최신의 시간일테고, 아래로 갈 수록 점점 나중의 시간의 값을 나타내는것으로 보고 있다. 이 시간데이터타입에 대해서
                정렬을 적용하는 것은 나중에 필요하게 될 시에 어떠한 시간데이터타입에 어떻게 적용되는지, 더 정확하게 보도록 하자. 
                [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]   
            (2-8).추가로 ORDER BY 예약어는 SELECT문에만 사용하는것이라 한다.
                [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]   
            (2-9).마지막으로 알아야 할 것은, 바로 WHERE에서는 해당 개체별 컬럼명의 값을 사용하고, SELECT ~ FROM -에서도 ~에 
                쓰이는 컬럼명도 해당 테이블에서 가져다 사용하여 나타내는거다.(컬럼명 사용하는방법말고 다른 방법있으면 그때정리) 그러나,
                이 ORDER BY 컬럼명 에서는 SELECT ~ FORM ~ WHERE ~으로 반환되는 값과 컬럼명을 그대로 가져다 쓴다. 즉, 개체에서 무언가를
                가져다 쓰는게 아닌 SELECT로 반환하는 리스트들의 컬럼명을 그대로 가져다 쓴다는거다. 그렇기에 아래 직접해본걸봐도, 실제 테이블에
                있는 create_datetime을 무시하고 별칭으로 사용된 create_datetime을 사용하고 있다. 만약 ORDER BY 컬럼명에서 테이블에 있는 컬럼명이고
                해당 SELECT로 반환되는 값의 컬럼명은 아닌경우, 그냥 ORDER BY 자체를 무시한다. 직접 해봤다.(이는 SELECT로 반환되는 값의 컬럼명만 고려한다는걸
                확인차 한것이니 이 이상 의미부여는 필요하면 하자.)
                [직접해봄] / SELECT board_Idx AS create_datetime FROM iu WHERE deleted_yn='N' ORDER BY create_datetime;   
            [추가사항]
                여기서 알고 넘어가야할 것이 있다. SqlYog에서 int형 같이 숫자타입의 컬럼에 내림차순을 했다고 가정해보자.(실제로, smallint나
                int형 모두 직접 해봤는데 정상 작동하였다.) 즉, SELECT hit_cnt ~ ORDER BY hit_cnt DESC와 같이 했다고 가정해보면 예상되는 결과값은 아래와 같이 뜬다.
                hit_cnt 
                16
                14
                13
                그리고 올림차순의 경우에는 아래와 같은 예시이다.
                hit_cnt 
                1
                3
                5
                이걸 하는 이유는, 이렇게 여러 개체의 반환되는 값들에 대해서는 매퍼 인터페이스의 메퍼드의 반환형이 List<DTO>형 으로 써서 받는경우인데,
                첫번째 DBMS에서는 위의 예시들처럼 결과값을 반환하고 이를 SqlSession.~ 메서드에서 ArrayList<DTO> 인스턴스에 DBMS에서 보내진 순서대로
                값을 매칭시키는데, 아마도 맨 위의값(위의 예시와 같은 순서에 맨 위의 개체를 순서로)부터 차례로, ArrayList<DTO>인스턴스에 요소별로 처음부터 차례로 해당하는
                값을 채워넣는것같다. 그리고 나서, 머스테치에서 {{#list}}와 같이 사용할때도 사용되는 순서가 ArrayList<DTO>의 첫 요소부터 순서대로 사용하게 되는것같다.
                [직접해봄] / 위와 같은 순서대로 직접 써봤다.
                +
                또한, 데이터베이스의 테이블에 INSERT로 값을 넣을때도
                1
                2
                3
                4
                와 같은 순서로 데이터가 쌓이게 된다. 즉, 최신으로 등록된 개체일 수록 테이블에서는 아래에 그 개체와 컬럼들의 값이 등록이 되게 되는 것이다.
                위의 오름차순과 내림차순으로 받아온값이 {{#list}}로 까지 순서가 반영되는 흐름과 같은 흐름이다. 즉, 만약에 오름차순 내림차순 없이 그냥 ORDER BY없이
                위의 1번부터 4번 개체의 값을 받아오라고 하면 #{{~}}에도 1번부터 4번까지의 순서로 값을 반영하게 된다.
                [직접해봄]
    (3).AS 별칭 
        Mysql에서는 테이블과 필드에 임시로 별칭(alias)를 부여하고 사용할 수 있는데, SELECT문에서 이렇게 사용한다고 한다.
            하지만, 테이블에 AS로 별칭을 사용하는것에 대해서는 나중에 필요할 시에 다시보도록 하고, 또한 여기서 쓰이는 AS 별칭
            사용법이 SELECT문에 주로 쓰이는 방식같다. 다른 쿼리문에도 사용되게 되면, 그때가서 정리하도록 하자.
            예시)
            1.필드에 별칭 사용
            SELECT 필드이름 AS 별칭 FROM 테이블이름;
            2.테이블에 별칭 사용 
            SELECT 필드이름 FROM 테이블이름 AS 별칭;
            [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select] / AS 별칭을 SELECT문에서 사용한다. , 테이블에도 AS 별칭을 사용한다.
            [참조링크 : https://cogito87.tistory.com/71] / 별칭 AS는 SELECT에서 쓰인다.
                (3-1).구체적인 사용법은 위의 예시에서, SELECT 필드이름 AS 별칭처럼 사용을 하게 되는데, 이렇게 될 시에
                    데이터베이스에서 SELECT로 값을 반환할때 컬럼명에 필드이름이 아닌 별칭을 대신해서 반납하게 되는거다.
                    즉, 이렇게 되면 DBMS에서 SELECT로 반환되어 SqlSession.~메서드에서 DBMS에서 온 값을 DTO혹은 list<DTO>
                    로 매칭하려할때, 이 별칭과 일치하는 DTO의 필드명과 값이 매칭되는거다. 즉, 아예 컬럼며이 바뀌어서 반환되는것으로
                    그 이상의 의미는 없는것 같다.
                    [참조링크 : https://cogito87.tistory.com/71]     
                    [참조링크 : https://ttend.tistory.com/611]   
                    [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select]    
                (3-2).이 AS 별칭에서 별칭란에 쓰는 규칙에 대해 정리해 보도록 하겠다.
                    1.우선적으로 스프링부트 시작하기 초록책만 봐도 AS created_datetime처럼 ''를 붙이지 않고 사용한다. 그러나 실제로
                        ''를 붙여서 AS 'created_datetime'처럼 사용했는데도 에러없이 정상적으로 작동하였다. 다른 참조링크들도 영문의 경우에
                        따로 ''를 붙여서 사용하진 않는것 같다. 그러니 영문을 쓸땐, ''를 붙이지 말고 사용하도록 하자. 여기서 영문은,
                        단순 영문이나 영문_영문이나 둘다를 포함해서 말한거다. 
                        [직접해봄] / 영문 별칭에 ''를 붙이건 ''를 안붙이건 상관없이 잘 작동하였다. 
                        [참조문헌 : 스프링부트 시작하기 초록책 69pg] / 영문 별칭에 ''사용안함  
                        [참조링크 : http://www.tcpschool.com/mysql/mysql_basic_select] / 영문 별칭에 ''사용안함    
                        [참조링크 : https://ttend.tistory.com/611] / 영문 별칭에 ''사용안함                         
                    2. a-z,A-Z,0-9,$,_와 같은 문자를 별칭으로 쓸 수 있다고 나온다. 더불어, 이 앞서말한 문자들은 ASCII코드에
                        해당하는 문자들이며, 여기에 해당이 안되는 ASCII코드들도 별칭에 쓸 수 있는 지는 나와있지 않다. 이 부분에
                        대해서는 나중에 필요시에 다시보도록 하며, ASCII코드가 아닌 한글이나 공백을 사용하는 경우에는 따옴표를 반드시
                        붙여야 된다고 한다. 그러나, 우리가 여기서 고려할것은 영문과 _에 대한 컬럼에 대해서니, 공백,한글,숫자,대문자영문, 
                        그 외에 다른 것들의 사용에 관해서는 나중에 필요할 시에 다시 보도록 하자.
                        [참조링크 : https://soranta.tistory.com/5] / a-z,A-Z,0-9,$,_를 별칭에 사용할 수 있다.
                        [참조링크 : https://victorydntmd.tistory.com/137] / 별칭 이름이 ASCII가 아닌 문자인 경우 별칭에 따옴표를 붙여주어야 한다. ASCII는 한글을 포함하지 않는다.
                        [참조링크 : https://cogito87.tistory.com/71] / 별칭에 공백이 있다면, 꼭 ''를 써주어야 한다.                   
                    3.또한, 별칭에 해당 FROM 테이블명의 테이블에 속한 컬럼명으로 써도 된다. 즉, 자세히 말하자면. 
                        보면, 별칭은 주로 영문과 영문+_조합으로 사용을 할텐데, 여기서는 해당 테이블의 컬럼명으로 적어도 되는 것 같다.
                        또한, 그 외에 어느것으로든 별칭을 만들어 사용할 수 있는것 같다. 
                        [직접해봄]   
                        [참조문헌 : 스프링부트 시작하기 초록책 69pg] / DATE_FORMAT을 쓰고 실제 해당테이블에 있는 created_datetime으로 별칭씀  
                (3-3).이 SELECT 필드명 AS 별칭 FROM 테이블명 ~에서 AS가 적용되는 원리와 필드명에 들어가는 종류에 따라 정리해보도록 하겠다.
                    우선, SELECT ~ AS에서 ~에 들어가는 값은 여기에선 DATE_FORMAT과 ''가 없는 컬럼명, ''가 있는 컬럼명 그리고 ''가 없는 컬럼명과
                    숫자와 연산자 그리고 ''가 없는 컬럼명이 함께 있는 경우를 다루어보았다.(이에 대한 상세확인은 위아래 적혀져있다.) 이 경우, 각각
                    A에 뭐가 들어가냐에 따라서 기본 반환할 값의 컬럼명이 정해지는데, AS로 별칭을 사용하게되면, A에 따라서 컬럼명이 정해지고 별칭이
                    적용되는건지, 아니면 A에 따라서 컬럼명이 정해지고 개체별로 그에 대한 반환값이 정해지고나서 해당 컬럼명을 별칭으로 바꾸는건지는 몰라도
                    순서는 그렇게 중요하지 않은것같다. 따라서 이러한 원리로 SELECT ~ AS 별칭 에서 이 별칭이 적용되는 원리는 이러한 순서중에 이루어지는일이다.
                    만약, 구체적으로 컬럼의 반환값이 정해지기 전후에 언제 별칭이 적용되는지 알아야 된다면 그때가서 다시 하도록 하자.
                    [직접해봄]    
                (3-4).SELECT문 다음에 필드명 옆에 AS라는 별칭을 사용할때, 여러개의 필드명이 나열되어도 각각에 모두 AS 별칭을
                    사용할 수 있었다. 
                    [참조링크 : https://ttend.tistory.com/611]    
                    [참조링크 : https://cogito87.tistory.com/71]   
                    [참조링크 : https://victorydntmd.tistory.com/137]   
                (3-5).이 SELECT 필드명 AS 별칭 FROM ~ WHERE - ORDER BY - 의 쿼리문이 사용되는 순서가 FROM에서 테이블을 선택하고 WHERE의
                    조건을 만족하는 개체만을 선별하고(WHERE없을 시 모든 개체 선택) 그 다음 SELECT로 컬럼명과 반환할 값을 나열하고 ORDER BY로
                    순서를 정하게 된다. 그렇기에, where에는 별칭사용이 안되고 order by에는 별칭사용이 가능하다. 즉, WHERE에서는 해당 개체의 컬럼명만
                    사용이 가능하고, SELECT ~ AS로써 쓰인 별칭은 사용이안된다. 또한, ORDER BY의 경우는 별칭사용이 가능한데, SELECT 쿼리문 해석순서도
                    순서이지만, 애초에 ORDER BY 필드명에서 이 필드명은 SELECT ~ WHERE ~로 반환한 값들의 리스트의 컬럼명만을 쓰기 때문이다.(위에 상세히정리)
                    그렇기에, 별칭을 그대로 ORDER BY의 필드명에 쓸 수 있는거다. 또한 직접해보니 별칭이 사용된 컬럼명도 ORDER BY로 사용할 수 있었다.
                    즉, SELECT hit_cnt AS a ORDER BY hit_cnt 도 정상적으로 작동했었다. 이때 ORDER BY에 a와 hit_cnt둘다 쓸 수 있었다. 즉, 예외적으로 별칭이
                    사용된경우 원래 컬럼명도 그대로 ORDER BY에 쓸 수 있는것 같다.(이것도, SELECT ~ AS -에서 ~에 ''가 없는 단일컬럼명만 쓰일때 그리고 단일컬럼명은 된다는것을\
                    해본것이며, 이 이상은 필요한경우 다양한 ~에 대해 다시 정리하도록 하자.)
                    [직접해봄]    
                    [참조링크 : https://victorydntmd.tistory.com/137] / WHERE에는 AS 별칭사용안된다.
                    [참조링크 : https://victorydntmd.tistory.com/137] / ORDER BY에는 별칭사용 가능   
    (4).Mysql의 date_format()에 관하여 알아보겠다.
        Mysql에 있는 DATE_FORMAT()의 기능은, DATE_FORMAT(A,B)와 같이 사용하는 구조이다.
        기능은, A에는 날짜형 데이터타입의 값이 들어가게 되고, B에는 형식이 들어가는 형태이다.
        구체적으로 무슨말인지 아래에 상세하게 설명하겠다.
            (4-1).바로 위에 적은 A에 들어갈 수 있는 데이터타입에 대해 설명하겠다.
                우선적으로, A에는 NOW(),날짜형 데이터타입 필드명(DATE,DATETIME을 말함, YEAR은 나중에 사용시에 다시 정리) 그리고 문자열
                이 들어갈 수 있다.(더 있을시 그때가서 또 정리하자.) 문자열이 들어가는것으로 보아, NOW()가 반환하는 문자열값이나, 날짜형 데이터타입 필드명이 반환하는 문자열
                값으로 쓰여지는것같다. 즉, 위의 3가지 경우 전부 결론적으로 값이 문자열로 반환되고 나서 이 값을 DATE_FORMAT()에서 적용시켜서
                사용되는것으로 보인다. 즉, 순서가 NOW(),날짜형 데이터타입 필드명의 경우 문자열을 받아오고(꼭, 날짜형 데이터타입이 아닌 일반
                문자형 필드도 되는지는 확인안해봤으나 이건 나중에 필요할 시 다시 해보도록 하자.), 그냥 문자열을 넣은경우는 그 다음 DATE_FORMAT()
                를 적용시킨다는 거다.
                [직접해봄] / 문자열을 직접 넣어서 해보았다.
                [참조문헌 : 스프링부트 시작하기 초록책 69pg] / created_datetime 컬럼명 사용   
                [참조링크 : https://j07051.tistory.com/606] / NOW() 함수 사용  
                [참조링크 : https://devjhs.tistory.com/89] / NOW() 함수 사용
                [참조링크 : https://lightblog.tistory.com/155] / 여기서도 해당 테이블의 컬럼명으로 사용  
                +
                근데 이 문자열이라는 것도 '0000-00-00 00:00:00'(년도-월-일 시:분:초)와 같이 문자열 형태를
                맞춰야 하는것으로 볼 수 있다. 무슨말이냐면은, NOW()도 '0000-00-00 00:00:00'와 같은 고정된 형태로 값을 반환하고 날짜형
                데이터타입(DATE,DATETIME)도 '0000-00-00 00:00:00'로만 고정된 형태로 값을 반환한다. 또한, 최소한 0000-00-00와 같이
                년도-월-일은 적혀져 있어야 에러가 안난다. 직접 해보니, 0000처럼 년도만 있거나, 0000-00처럼 년도와 월만 있는 경우 쓰면
                에러가 나고, 0000-00-00처럼 년도-월-일 이 3가지가 모두 있어야 에러가 안난다. 이때 00:00:00 시:분:초에 해당하는 문자열은
                0000-00-00인 년-월-일만 쓰게되면, 00:00:00인 시:분:초는 00:00:00의 문자열을 갖는것으로 간주된다. 또한, 년-월-일인 0000-00-00를
                적지않고, 00:00:00인 시:분:초만 적어주면, B의 값에 상관없이 에러가 난다. 그러하기에, 날짜형데이터타입이 TIME인 필드명은
                A의 자리에 적을 수 없는것이다. 정리하자면, 최소한 0000-00-00 는 적어주어야 하며, 0000-00-00 00, 0000-00-00 00:00처럼
                추가로 시간만 적어주거나, 시간:분만 적어주어도 정상적으로 작동한다. 이때에도 시간만 적어준경우 분과초는 00:00으로 간주하고
                시간과 분까지 적어주면 초는 00인것으로 간주한다. 결과적으로 B에 어떠한 형태가 들어오든 A는 A만의 주어진 형식에만 맞추면 될것으로
                보인다.(0000-00:00 가 되냐는둥, '0000-00-00 '처럼 공백 넣는것도 되냐는둥은 나중에 필요할 시에 다시 해보도록 하자.)
                [직접해봄]            
                +
                또한, NOW()는 내가 알기론, 월,일,시,분,초에서 1자리 숫자인경우 두번째 자리 숫자로 0으로 채우는것으로 알고있다.
                또한, 이 날짜형 데이터타입의 컬럼에 들어가는 값들도 전부 NOW()를 걸쳐서 들어가는것으로 알고있다. 또한, 내가 직접
                A자리에 문자열을 썼을때도 월,일,시,분,초에 각각 1자리가 있더라도 나머지 두번째 자리는 0으로 채우는 방식으로 썼었다.
                통상적으로 이렇게 처리하기로 여기고 만약에 다르게 적어야 하는경우 그때가서 다시보도록 하자. 또한, 날짜형 데이터타입의 컬럼에도
                NOW()가 아니더라도 다른 방식으로 넣으되, 월,일,시,분,초에 값이 1자리일때 두번째 자리에 0이 안쓰는경우에도 다시 정리하도록 하자.
                [직접해봄]    
            (4-2).DATE_FORMAT(A,B)에서 이번엔 B에 관하여 알아보도록 하겠다. 여기서는 위에서 A에 관한 설명에서 주어진 A의 값 형태(0000-00-00 00:00:00)로만
                설명하도록 하겠다.(다른 유형이 있을시에 그때가서 정리) 이 B에는, 여러가지 %값들이 들어갈 수 있다. 사실 변수로는 %값만 들어갈 수
                있는것 같으며(다른게 있을 시 그때가서 정리), 그 외에 다른 문자들은 문자열로 해석이되어서 자유롭게 작성이 가능한것 같다. 직접해보니, 한글을
                넣으건, %d에 바로 d를 붙여서 %dd를 쓰건, %~의 변수를 제외하고는 알아서 다 문자열로 처리하는것 같다. 그럼 대표적으로 쓰이는 %값과 DATE_FORMAT(A,B)에서
                A의 값과 어떻게 매칭되는지 알아보도록 하겠다. 
                1-1.%Y - 4자리 연도를 나타냄(2020, 1985)
                1-2.%y - 2자리 연도를 나타냄(89,95)
                2-1.%m - 숫자 월을 나타냄, 무조건 두자리(01,08,12)
                2-2.%c - 숫자 월을 나타냄, 한자리인 경우 한자리만(1,8,12)
                3-1.%d - 숫자 일을 나타냄, 무조건 두자리(01,25,31)
                3-2.%c - 숫자 일을 나타냄, 한자리인 경우 한자리만(1,15,8,31)
                4-1.%H - 숫자 시간을 나타냄,무조건 두자리이며 24시간으로 표현(08,15,23)
                4-2.%l - 숫자 시간을 나타냄, 한자리인 경우 한자리만 표현하며 12시간으로만 표현(18:00:00여도 %l하면 6으로 표현됨)(1,5,11)
                5.%i - 숫자 분을 나타냄, 무조건 두자리(01,35,59) / 한자리의 분을 나타내는 것은 아래 참조링크에 없었다.
                6-1.%S - 숫자 초를 나타냄, 무조건 두자리(01,25,59) / 직접해봄
                6-2.%s - 숫자 초를 나타냄, 무조건 두자리(01,25,59) 
                대문자와 소문자의 값이 다르게 매칭되니 조심하도록 하자. 또한 아래의 참조링크에도 %s와 %S차이점이 안나와있는데,
                스프링부트 시작하기 초록책 69pg를보면 %s로 소문자를 쓰니, 나도 되도록 소문자 s를 쓰도록 하자. 나중에 이 부분 필요할
                시에 다시 찾아보도록 하자. 제일 많이쓰는 형태는 '%Y,%m,%d,%H,%i,%s'의 형태인것 같다. 추가적으로 필요한 % 변수명을 사용하고
                싶다면 아래 참조링크를 참고하도록 하자.
                [직접해봄] / 직접 B란에 '%Y..hi..%m.%dd %Hㅇ:%i:%s' 와 같이 작성하였는데도, 정상 작동하였다.
                [참조문헌 : 스프링부트 시작하기 초록책 69pg]   
                [참조링크 : https://j07051.tistory.com/606]   
                [참조링크 : https://devjhs.tistory.com/89]   
            (4-3).이 DATE_FORMAT(A,B)의 B에는 %관련한 문자들이 모두 대입이 되고, DATE_FORMAT(A,B)의 결과값을 B 값 그대로
                반환하는것으로 보이기에, 반환되는 값은 String형으로 쓰이기에 반드시 B에 ''를 감싸서 써주어야 한다. 물론, 애초에
                DATE_FORMAT(A,B)에서 B에 따옴표가 없으면 이 자체에서 에러를 일으키게 하는걸 수도 있다.
                [직접해봄] / ''를 B에 붙이지 않았더니 에러가 났다.
            (4-4).DATE_FORMAT(A,B)에서 A에 NOW(),필드명,'2020-12-12'와 같은 날짜형 데이터를 써주면  SELECT문으로 반환할값의
                컬럼명을 정할때 위의 A에 뭐를넣던 그 값 그대로 DATE_FORMAT(A,B)자체가 컬럼명이 되게 된다. 또한, B에는 ''하고 %문자가
                들어가게 되는데, 이 또한 무얼 들어가든 그대로 컬럼명에 쓰이는것으로 보인다.
                [직접해봄]   
            (4-5).다음은 DATE_FORMAT(A,B)의 기본 작동원리에 대해 알아보겠다.
                이것을 알려면 우선, SELECT문으로 개체별 값을 받아오는것의 과정에 대해 다시 한번 이해해야 한다. 무슨말이냐면,
                데이터베이스에서는 SELECT ~ FROM ~ WHERE ~ ORDER BY ~라는 쿼리문이 있는 경우 일종의 처리 과정을 거쳐서 최종적으로
                값을 반환하는데, 우선 FROM으로 어느 테이블인지 찾고, WHERE로 해당 조건을 만족하는 개체에 대해서만 개체 목록을 꾸린다.(WHERE가 없으면
                당연히 해당 테이블의 모든 개체가 해당된다.) 그런다음 선택된 개체들에 한해서 SELECT 다음에 있는 컬럼명들에 해당하는 값을 나열하게 되는건데,
                DATE_FORMAT(A,B)은 (4-4)에서처럼, 반환할 SELECT값 리스트에서 컬럼명이 DATE_FORMAT(A,B)로 정해지고 그리고 나서, 개체마다 B의 값을 반환값으로
                사용하게된다.      
                [직접해봄]        
    [추가사항]    
        SELECT 쿼리문을 이해하는데 있어서 SELECT 내에 예약어들이 어떠한 순서로 반영되는지를 알아야 SELECT의 기능과 이 쿼리문
            내의 다양한 예약어들에 대해 더 잘 이해할 수 있다. 아래 링크를보면, SELECT쿼리문의 경우 명령어의 순서가 WHERE -> SELECT라고 한다. 
            또한, 이로 봤을때 만약, SELECT hit_cnt AS abc FROM iu WHERE deleted_yn='N' ORDER BY hit_cnt DESC라고 한다면 예상되는 쿼리문 순서는 
            다음과 같을 것으로 보고있다. FROM -> WHERE -> SELECT -> ORDER BY 여기서 ORDER BY는 SELECT 명령어 순서중에 가장 마지막에 처리된다고 한다.
            이러한 각각의 과정을 거치며 하나하나 과정들의 자세한 내용은 위에서 찾아보도록 하자.
            [참조링크 : https://victorydntmd.tistory.com/137]       
.
.
.
