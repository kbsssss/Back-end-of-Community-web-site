.
.
.
1.스프링부트 시작하기 초록책64pg~66pg의 @Controller에 대해 정리하겠다.
    1-1.@Autowired로 BoardService로 서비스를 자동주입을 하려 하지만, 이는 인터페이스형으로 구현체 빈이 대신 주입된다.
        아래 예시를 보면, @Autowired으로 자동주입을 해줄때, BoardService는 인터페이스형인데, 여기에 실제 들어가는것은 
        이 BoardService 인터페이스형을 구현한 클래스의 빈이 대신 주입된다. 이를 스프링부트에서 해준다. 또한, 내가 아는 지식
        안에서는 1개의 서비스 인터페이스당 1개의 구현체였는데, 만약에 구현체가 2개이상되는 경우 다시 정리하도록 하자.
        혹은 인터페이스형을 안쓰는경우에도 다시 정리하도록 하자.
        (스프링부트 시작하기 초록책64pg의 예시)   
            @Autowired
            private BoardService boardService; 
        [참조링크 : https://onlyformylittlefox.tistory.com/13]   
        [참조문헌 : 스프링부트 시작하기 초록책 64pg] / 예시
        +
        인터페이스형의 의존주입에 대해서 검색하여도 나오지 않는것을 보니, @Service 관련해서만 스프링이나 스프링부트에서
        이루어지는 기능같다.
        +
        private BoardService boardService; 이 코드에서 boardService말고 boardServiceaaa로 필드명을 바꿧는데도 정상작동하였다.
        즉, 여기선 필드명이 중요하다기보다 이 BoardService라는 인터페이스형를 더 의미있게 이해해야하는것으로 보인다. 또한, @Autowired를
        이용한 필드주입이나 생성자주입모두 boardServiceaaa로 했는데, 정상작동하였다.
        [직접해봄]   
        [참조문헌 : 스프링부트 시작하기 초록책 64pg ~ 66pg] / 여기있는 코드를 기반으로함
    1-2.@Component, @Service, @Controller 에서 의존주입하는경우 @Autowired 자동주입말고 생성자 자동주입으로 사용하야하는 이유와 이와 관련된 내용
        1-2-1.스프링 프레임워크에서 의존성을 주입하는 방법은 3가지가 있다고 한다. 
            1.생성자 주입
            2.필드 주입             
            3.수정자 주입
            우리는 이중에서, 필드 주입과 생성자 주입에 관하여 알아볼건데 필드 주입의 경우는 필드위에 @Autowired를
            붙이는것이고 생성자 주입의 경우는, 말 그대로 생성자의 매개변수에 필드관련 값을 적어주어 주입이 되게 하는
            방식이다. 이 방식이, 아래 참조링크와 참조문헌에서 대표적인 방법이라고 한다.(수정자 주입은 필요시 작성글 다시 찾아보기)
            또한, 아래 참조문헌에서나 참조링크 혹은 내가 직접해본것은 @Component , @Service, @Controller의 클래스에서
            적용되는 방식만 본것으로 다른 상황의 경우에서는 다시 보도록 해보자. 하지만, 별 차이는 없을 것 같다.
            [참조문헌 : 스프링부트 aws책 106 ~ 107pg] / 스프링에서 빈을 주입하는 방식은 3가지(@Autowired필드주입, setter수정자주입, 생성자주입) 
            [참조링크 : https://jackjeong.tistory.com/41] / 스프링에서 빈을 주입하는 방식은 3가지(@Autowired필드주입, setter수정자주입, 생성자주입)    
        1-2-2.여기서 쓰인 생성자 주입중에, @Component, @Service, @Controller에 한해서만 자료가 주어졌기에 정리하는데, 이 주석이 붙은 클래스의 생성자에
            해당 @Component, @Service, @Controller가 붙은 클래스의 필드가 빈 타입인경우 해당 빈 타입에 해당하는 값을 생성자 매개변수에 설정하게 되면, 
            컴포넌트 스캔이 알아서 @Component, @Service, @Controller에 해당하는 클래스를 빈으로 등록될때, 자동으로 생성자의 매개변수에 등록한 값까지 반영이되어 
            해당 @Component, @Service, @Controller가 붙은 빈의 필드에도 위에 적은 적절한 빈이 주입이 되는것이다. 다른 클래스에서도 생성자 주입이 쓰인다면 그때가서 응용해서 
            이해하면 될 것같다. 아래 링크들에 @Component, @Service, @Controller에 해당하는 클래스에 어떻게 반영되는지 자세한 코드 예시가 나와있다.
            또한, 자세한 설명들은 바로 다음부터 하겠다.
            [@Component관련 정리글 참고]   
            [참조링크 : https://programmingrecoding.tistory.com/13]   
            [참조링크 : https://jackjeong.tistory.com/41]        
            [참조링크 : https://firework-ham.tistory.com/28]     
        1-2-3.그렇다면, 1-2-2에 나온 생성자의 매개변수에 어떻게 적어주어야 @ComponentScan에 의해 자동으로 필드에 빈이 주입이 되는지 알아보겠다.
            우선 @Component가 붙은 클래스를 해보겠다,  직접 스프링에서 @Component, @ComponentScan관계에 있는 클래스에서 @Component가 붙은 클래스의 필드에 다른 클래스의 빈을 주입해봐서
            해봤는데, 이때는 롬복을 사용할 수 없어서 직접 생성자를 만들고 생성자 매개변수에 해당 @Component가 붙은 클래스의 필드에 해당하는 매개변수형과 매개변수값을 넣어주었다.(당연히 필드에 해당하는
            빈은 이미 빈으로 등록이 되었었다.) 이때 매개변수의형은 당연히 의존주입하려는 필드의 형과 맞춰주어야 하고, 매개변수의 이름은 매개변수의 타입의 첫글자만 소문자로해서 써놔도 되지만, 사실
            아무거나 적어놔도 잘 주입이 됬었다. 하지만, 이는 필드의 빈이 싱글톤이였으며, 핻당 필드타입의 빈이 하나밖에 없었기때문에 가능한것으로 보이니, 싱글톤이 아니거나 해당 필드타입의 빈이 2개이상
            인경우 다시 정리하도록 하여야 한다. 또한, 아래 참조링크보면, @Component에서 @RequiredArgsConstructor을 이용해서 생성자주입이 정상적으로 이루어지는것도 볼 수 있다.
            [직접해봄] / @Component,@ComponentScan 관계에서 직접 생성자를 만들어서 생성자주입시도해봄
            [참조링크 : https://jackjeong.tistory.com/41]   
            +
            @Controller와 @Service의 경우는 직접해본것으로는 아래 책 64 ~ 68pg를 기반으로 필드주입을 하지않고, 직접 생성자를 @Controller와 @Service가 붙어있는 클래스에 만들어서 해본결과
            생성자의 매개변수에 '형'으로는 @Controller의 경우 BoardService로 Service인터페이스형을 넣어주고, @Service의 경우 BoardMapper형으로 Mapper인터페이스형을 넣어주었다. 또한, 각각의
            매개변수명은 아무거나 넣어주어도 정상작동했는데, 이는 서비스인터페이스 구현체 클래스와 매퍼인터페이스 구현체 클래스가 한개씩밖에 없고 또한 싱글톤 객체에 해당 각각 구현체 클래스형의
            빈도 1개밖에 없기때문에 그런것같다. 만약 나중에 빈이 2개이상이거나 구현체 클래스가 2개이상이면 다시 봐보도록 하자. 또한, @RequiredArgsConstructor를 이용했을때도, 정상작동하였는데
            이때도 당연히 @Controller와 @Service의 각각 서비스인터페이스형 필드 명과 매퍼인터페이스 필드명에 아무거나 넣어도 정상작동하였다.
            [직접해봄] / 스프링부트 시작하기 초록책 64 ~ 68pg를 기반으로 직접해봄
            [참조문헌 : aws책 106 ~ 107pg] / @Service, @RestController에서 @RequiredArgsConstructor사용      
            [참조링크 : https://growing-up-constantly.tistory.com/49] / @Service에서 @RequiredArgsConstructor사용   
        1-2-3.그럼 이 @RequiredArgsConstructor 어떻게 생성자주입에 쓰이게 되는지 구체적설명과 더불어 @AllArgsConstructor에 관하여 부수적으로 설명하도록 하겠다.
            우선, 이 @RequiredArgsConstructor 애노테이션을 붙이게 되면, 해당 클래스의 생성자가 자동으로 만들어지는데, 이 만들어지는 방식이, final이나 @NonNull이 붙은
            필드의 경우가 생성자 매개변수에 설정이 되는거다. 이때, 아래 두 참조링크를 봤을때, 생성자의 매개변수에 설정되는 값의 형태가 우선, '형'의 경우 해당 필드의 final이나
            @NonNull이 붙은 필드의 형이 적혀지며, 매개변수이름은 해당 필드의명을 따라가는것으로 보고있다. 이 부분 만약에 다를시에 다시 보도록 하자. 또한, @RequiredArgsConstructor특성상 
            final이나 @NonNull이 붙은 필드의 순서대로 생성자의 매개변수에 똑같은 순서로 값이 설정된다.
            [참조링크 : https://dingue.tistory.com/14]   
            [참조링크 : https://hyoj.github.io/blog/java/basic/lombok/#noargsconstructor-requiredargsconstructor-allargsconstructor]   
            +
            그렇다면, @Component, @Service, @Controller의 필드에 final이 붙어서 사용이되도 상관이 없는지 보도록 하겠다. (@NonNull은 필요시 나중에 다시보자)
            이 final의 기능은 초기화가 반드시 필요하다는것 외에 한번 빈이 주입된다면 바뀔 수 없다는 특징이 있는거다. 또한, 아래 설명하겠지만 이는 주입된 빈 객체가 변하지
            않는 즉, 불변성을 보장하는 역활도 한다. 필드주입이나 수정자주입으로는 final을 선언할 수 없다고 한다. 왜냐하면, 위의 23번글쯤에 빈이 생성되는 순서에 대해 적어 놓았는데
            수정자주입이나, 필드주입같은경우 초기화를 못한다. 한 클래스의 필드의 필드주입이나 수정자주입은 해당 클래스가 빈으로 생성되고나서 이루어지는 행동이니 final 을 필드에 쓰면 오류가
            나는게, 초기화를 안시키니까 에러가 나는거다. 이어서 불변성은 생성자주입을 함으로써 이러우지는 장점중 하나로 아래 두 참조링크에서 나열했는데, 권장하는 기능중 하나로 보인다. 
            지금까지 봐왔던 @Component,@Controller,@Service의 필드에서 불변성이 당연시되는 것들이였으나 혹시나, 나중에 중간에 이 주입되는 필드가 변해야하는 경우가 있다면, 그때 다시 보도록 해보자.
            [직접해봄] / @Component의 필드에 final을 해봐서 직접해보았고, @Controller의 boardService필드(서비스 인터페이스형)에 final을 붙여서 해보았고, @Service의 mapper필드(mapper인터페이스)에 final을 붙여서 해보았더니 모두 정상작동했다.
            [참조링크 : https://firework-ham.tistory.com/28]   
            [참조링크 : https://jackjeong.tistory.com/41]     
            +
            @AllArgsConstructor는 롬복에도 이 주석을 안써봐서 정리를 안해놨는데 아래 참조링크를 보면 final의 여부와 상관없이 해당 클래스에 존재하는
            모든 필드에 대해 생성자에 자동으로 반영하여 생성해 준다고 한다. 이거는 @AllArgsConstructor을 쓰게되면 다시 제대로 정리하도록 하고 또한, 
            원하지 않은 필드도 생성자에 반영이 되기도 해 @AllArgsConstructor를 조심해서 써야하고 @RequiredArgsConstructor로 필드를 선별해서 생성자를 만드는데 사용한다고 한다. 또한, 
            @Component이 적용된 @Controller이나 @Service클래스에서 아래 참조문헌을 봐도 @AllArgsConstructor이 쓰이는것을 보지 못했다. 
            [참조링크 : https://blog.hodory.dev/2019/05/28/required-a-bean-of-type-that-could-not-be-found/] / 선택적 생성자 만드는경우 @AllArgsConstructor보단 @RequiredArgsConstructos사용
            [참조링크 : https://jackjeong.tistory.com/41]   
            [참조문헌 : 스프링 aws책 106~107pg]    
        1-2-4.@Autowired로 의존주입을 하지않고 생성자주입을 권장하는 이유
            1.순환 참조 방지역활
                순환참조란, 빈 A, B가 있을때 A의 필드에 B을 주입하고, B의 필드에 A를 주입한 상태에서
                A클래스의 메서드안에서 필드 B를 이용하여 필드B의 메서드를 사용하고 B클래스의 메서드안에서 필드 A를
                이용하여 필드A의 메서드를 사용해서 결국에는 빈A가 빈B를 빈B가 빈A를 무한적으로 참조하게 되어 에러가 발생
                하게 되는데 이를 순환참조라고 한다. 자세한 예시설명은 아래 링크를 보면된다.
                [참조링크 : https://2ham-s.tistory.com/278]     
                [참조문헌 : https://jackjeong.tistory.com/41]    
                +
                그런데, 이러한 순환참조를 예방하여야 하는데, 위의 내용이나 아니면 23번 빈이 생성되는 과정 정리글을 보면, 어떤 클래스에 @Autowired이용한
                필드주입이나 수정자주입의 경우는, 먼저 빈이 생성이되고 해당 클래스의 필드에 빈이 주입이 되며, 생성자주입의 경우에는 해당 클래스의 빈이 생성되기 이전에
                주입하려는 필드의 빈을 찾게된다. 이 얘기를 하는 이유가, 서로 참조하는 두 클래스의 경우, 메서드를 이용해서 순환참조의 가능성이 있다. 그러나 필드
                주입 즉, @Autowired이나 수정자주입의 경우는 해당 순환참조를 하는 메서드가 실행되기 전까지는 에러메시지가 뜨지 않는다. 그에 반해 생성자 주입의 경우는
                애초에 두 클래스의 각각이 빈이 생성되기 이전에 필드에 주입하려는 빈을 먼저찾게되니 두 클래스의 빈이 생성되는 과정에서 에러가 떠서 순환참조를 미리
                예방할 수 있는 효과가 있다. 그렇기에 생성자주입을 권장한다고 한다.
                [참조링크 : https://jackjeong.tistory.com/41]   
                [참조링크 : https://2ham-s.tistory.com/278]      
            2.final 선언이 가능하다.(불변성)
                필드주입이나 수정자주입은 필드에 final을 붙이지 못한다. 그러나 생성자주입은 붙일 수가 있어
                런타임에 객체 불변성을 보장한다고 한다. 그냥, final이니 다른 객체값으로 바꾸지 못한다라고
                알면될것같다. 더 구체적으로 알 필요가 있을시에 나중에 다시 보도록 하자.
                [참조링크 : https://2ham-s.tistory.com/278]     
                [참조링크 : https://jackjeong.tistory.com/41]   
            3.테스트 코드 작성이 편리하다고 한다.
                그러나, 내가 테스트코드를 진행하지 않을 예정이니 이 부분은 나중에
                필요시에 다시보도록 하자.
                [참조링크 : https://2ham-s.tistory.com/278]   
                [참조링크 : https://jackjeong.tistory.com/41]   
.
.
.
2.스프링부트 시작하기 초록책65gg ~ 68pg의 @Service에 대해 정리하겠다.
    2-1.@Mapper 주석을 달은 Mapper 인터페이스가 어떻게 @Service가 붙은 클래스의 필드가 Mapper형이여서 여기에 빈이 주입이 되는지 그 원리와 이해에 대해 설명하겠다.
        여기는 위의 @Controller에서 boardService 즉, 서비스 인터페이스형에 구현체를 받아온것과는 조금 다른데, 우선, 서비스 구현체에서 Mapper 인터페이스형의 필드에 필드주입이건
        생성자주입이건 주입하라는 코드를 적었을때, 이는 @Controller에서 Service인터페이스형의 필드에 주입하라는 방식과 같아 보인다. 즉, 여기서도 Mapper인터페이스형의 필드에
        Mapper인터페이스를 구현한 구현체의 빈을 주입하라고 하는것이다. @Mapper 주석은 애초에 @Component를 포함한 주석이 아닐것으로보고(이 부분 틀리면 다시보기) @Mapper가 붙은
        Mapper 인터페이스의 구현체가 만들어져 그것이 @Component를 포함한 구현체로써 빈으로 등록되고 그리하여 서비스 구현체 클래스의 Mapper 인터페이스형 필드에 
        이 Mapper인터페이스의 구현체가 빈으로 주입이 되는것으로 보인다. 서비스 인터페이스 구현체 클래스의 @Service는 @Component가 포함되있어 해당 서비스 인터페이스 구현체 클래스를 빈으로
        등록함과 동시에, @Controller에서 서비스 인터페이스형에 빈 주입하려고 하면 이 서비스 인터페이스 구현체 클래스의 빈이 대신 주입되게 해준다. @Mapper도 이와 비슷한 기능을 하나,
        다른점은 아예 매퍼 인터페이스형에 @Mapper를 붙여서 해당 매퍼 인터페이스의 구현체 클래스를 추가로 만들고 여기에 @Component까지 붙여 빈등록을 하게한다음에, @Service에서 매퍼 인터페이스형에 
        빈 주입하려고 하면 여기에 매퍼 인터페이스의 구현체 클래스의 빈이 주입되게 하는것이다.
        [참조문헌 : 스프링 부트 시작하기 초록책 66 ~ 68pg] / 위에서 얘기하는 내용이 모두 여기에 있는 내용이다.
        [참조링크 : https://joont92.github.io/etc/MapStruct/]    
        +
        private BoardMapper boardMapper; 이 코드에서 boardMapper말고 boardMappereaaa로 필드명을 바꿧는데도 정상작동하였다.
        즉, 여기선 필드명이 중요하다기보다 이 BoardMapper라는 인터페이스형를 더 의미있게 이해해야하는것으로 보인다. 또한, @Autowired를
        이용한 필드주입이나 생성자주입모두 boardMapperaaa로 했는데, 정상작동하였다.
        [직접해봄]   
        [참조문헌 : 스프링부트 시작하기 초록책 66pg ~ 68pg] / 여기있는 코드를 기반으로함       
    2-2.서비스 인터페이스와 서비스 클래스 구현체를 따로 두는 이유와 그와 관련된 내용@@@@@@@@@@@@@@@@@@@@@@@
        2-2-1.아래 2-2-2.에는 형식적인 얘기를 써놓은거고, 여기에는 스프링 AOP와 JDK Dynamic Proxy와 관련해서 적도록 하겠다.
            사실상, 아래 2-2-2.만 보더라도 딱히 Service에서 인터페이스와 구현체를 나눌 필요가 없다. 그러나 동적 프록시를 사용하기 위해서는
            즉, JDK Dynamic Proxy를 사용하기 위해서는 인터페이스를 사용하여 나누어 주어야 한다. 왜냐면 이 동적프록시는 반드시 인터페이스가 있고 이를
            구현해야 JDK Dynamic Proxy를 사용할 수 있기 때문이다.(더 자세한거는 동적프록시 내용보기) 그러나, 사실 스프링부트에서는 CGLIB이 디폴트이고,
            또한, 이런 인터페이스를 구현한 서비스 구현체도 CGLIB으로 가능하니 더더욱 요즘들어서는 서비스를 인터페이스와 구현체로 나눌필요가 없어보인다.
            그러나 여태 해온 관습적인것들이긴 하나 나도 그렇게 공부했고, 아직은 이를 서비스 인터페이스 없이 구현체만 사용해본적이 없기에 그냥 사용하도록
            하자. 나중에 인터페이스없이 서비스 사용할때 필요할때 다시 정리하도록 하자.
            [직접해봄]     
        2-2-2.느슨한 결함을 유지하여 각 클래스 간의 의존관계를 최소화하기 위해 사용한다고 한다.
            이 말이 무슨말이냐면, 객체지향 프로그래밍에서는 클래스들을 기능별로 세분화되게 나누어 다른 클래스와의 의존관계를 낮추는 것이 중요한데,(이를 결합도를
            낮춘다고 한다. 혹은 느슨한결합(Loose coupling) 이라고 한다, 또한 이렇게 하는것이 해당 한 클래스의 책임을 클래스들이 나누어 갖게되어, 다른 클래스들과의 의존관계가 하나의
            클래스에서 모든 책임을 갖었을때보다는 의존관계가 줄어들어서 결합도가 낮아졌다고도 하는거다.) 이를 해주는것이 인터페이스를 이용하여 여러 구현체를 두어서 다형성을 구현하는것이다.
            [참조문헌 : 스프링부트 시작하기 초록책 65pg] / 이 책에서 느슨한 결함을 유지하여 각 기능 간의 의존관계를 최소화하기 위해 사용한다고 한다.   
            [참조링크 : https://velog.io/@aquarius1997/Service%EC%99%80-ServiceImpl]   
            [참조링크 : https://hyunsoori.tistory.com/11]   
            [참조링크 : https://www.popit.kr/spring-oop-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%98%88%EC%A0%9C1-service-serviceimpl-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0/]      
            +
            또한, 의존관계의 최소화로 인해 기능의 변화에도 최소한의 수정으로 개발할 수 있는 유연함을 가질 수 있다고 한다. 즉, 위의 개념으로
            봤을때 의존관계 최소화 즉, 클래스들의 기능이 세분화되어 나뉘어져 있으니 어떠한 기능의 변화에도 최대한 클래스들이 기능에 따라 세분화
            되어있으니, 하나의 클래스가 갖는 의존관계가 최소화되어있어 기능을 수정할때 큰틀을 수정하는게 아닌 세부적인 것만 수정하면 되는것의 의미로
            알고있다. 
            [참조문헌 : 스프링부트 시작하기 초록책 65pg] / 이 책에서 의존관계의 최소화로 인해 기능의 변화에도 최소한의 수정으로 개발할 수 있는 유연함을 가질 수 있다고 한다.
            [참조문헌 : https://velog.io/@aquarius1997/Service%EC%99%80-ServiceImpl]   
            +
            근데, 이러한 것들은, 인터페이스를 사용하고 이를 구현하는 구현체가 2개 이상 일때 의미가 있는것이다. 그러나 아래 참조링크에서 보듯이
            대부분의 서비스 인터페이스의 경우 하나의 구현체가 있는것이 대부분이였다. 그러니, 이 2-2-2.에 해당하는 장점들이 의미가 없어지게되는거다.
            또한, 추가로 서비스 인터페이스를 사용할때 서비스 인터페이스 구현체 클래스가 2개이상인 경우에는 따로 어떻게 사용하는지도 찾아봐야 한다. 그건 그때가서
            필요할 경우에 다시 봐보도록 하자.
            [참조문헌 : https://hyunsoori.tistory.com/11] / 대부분 하나의 서비스 인터페이스에 하나의 구현체로 있는것이 대부분이였다.   
    2-3.아래 참조문헌에 보면, BoardService 인터페이스, 즉, 서비스 인터페이스의 메서드에 접근제어자가 적혀져 있지 않다. 이 경우에 인터페이스는
        알아서 public abstract를 붙인다고 한다.
        [참조문헌 : 스프링부트 시작하기 초록책 66pg]   
        [참조문헌 : 자바 책 315pg] / 인터페이스 메서드에는 접근제어자 붙이지 않아도 알아서 public abstract가 붙는다.
        +
        메서드 오버라이딩 @Override에 대한 얘기인데, 상속관계있는 서로 다른 두 클래스가 있을때 상위 클래스의 어떤 메서드의 접근제어자가 상속받는 하위클래스에서
        상위 클래스의 해당 어떤 메서드를 오버라이드 하려할때 접근제어자가 영향을 주었다. 즉, 해당 어떤 메서드의 접근제어자가 private이면 하위 클래스에서 해당 어떤
        메서드를 @Override하지 못했으며, 만약 public이거나 protected인 경우에는 하위클래스에서 해당 어떤 메서드를 @Override 할 수 있었다. 즉, 상속관계에 있을때
        이 접근제어자가 @Override의 권한여부에도 영향을 끼친단는것을 알았다. 또한, 상위클래스의 어떤 메서드의 접근제어자가 protected이고, 하위 클래스에서 해당 어떤
        메서드를 @Override한다 할때 이때 @OVerride할때 접근제어자를 public으로 바꿀수도 있었다. 이것도 정상 작동하였다.
        [직접해봄]
        +
        인터페이스의 메서드는 기본적으로 접근제어자가 적혀져 있지 않은데, 이럴 경우 public abstract를 알아서 붙인다고 한다. 근데 추가적으로 내가
        private abstract나 protected abstract를 붙이니 허용되지 않는 문법이라고 한다. 즉, 당연히 위의 @Override에 따르면, private abstract는
        애초에 @Override를 못하니 말이 안되는게 맞고, protected abstract도 자세한 내용을 알고 싶으나, 더 자세히 알려면 여러가지 다른것들을 더 공부
        해야하기 때문에 그냥 인터페이스에서는 protected abstract로 메서드를 못쓴다는 것만 알고가도록 하자.(public abstract를 붙이니 불필요하다고 붙이지 말라한다.)
        [직접해봄]  
        [참조문헌 : 자바 책 315pg] / 인터페이스 메서드에는 접근제어자 붙이지 않아도 알아서 public abstract가 붙는다.     
        +
        아래 참조문헌에 보면 인터페이스의 메서드에 접근제어자 public을 적어줬는데 여기서 abstract는 따로 안적어줬다. 그래서
        직접 abstract는 안쓰고 public만 쓰니 redundant라고 불필요하다고 나왔다. 그대로 직접 실행해보니(서비스 인터페이스 메서드에
        적용해봄) 정상적으로 해당 public만 붙인 메서드가 정상적으로 작동했었다. 아마 public만 붙여도 그 다음에 abstract를 알아서
        붙여주는것 같다.(그래야만 하는게, 그렇지 않으면 인터페이스에서 추상메서드가 아니게되어서 에러일으킴)
        [직접해봄]   
        [참조문헌 : 스프링책 152pg]            
.
.
.         