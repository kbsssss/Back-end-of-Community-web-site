.
.
.
1.AOP의 핵심 기능에 공통 기능을 삽입하는 3가지 방법과 그 중에 사용할 방법에 대해 알아보겠다.
    1.컴파일 시점에 코드에 공통 기능을 삽입하는 방법
        1-1.컴파일 하기 직전에 공통 기능을 삽입하는것이다.
            [참조링크 : https://niklasjang.github.io/spring/spring-aop/] / 컴파일 전에 공통기능 삽입   
    2.클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법
        2-1.클래스 로딩 시점 즉, 클래스 로더가 JVM의 메모리에 class파일을 올릴때 바이트 코드에 공통 기능을 삽입하는것이다.@@@@@@@@
            [참조링크 : https://niklasjang.github.io/spring/spring-aop/]    
    3.런타임에 프록시 객체를 생성해서 공통 기능을 삽입하는 방법
        3-1.런타임 즉, main함수가 실행되고 JVM에서 해당 바이트코드들을 실행하며, 인스턴스 혹은 빈객체를 생성하고 등록할때
            프록시 객체를 생성해서 공통 기능을 삽입한다는 것이다.(여기 부분 혹시 틀린부분 있으면 나중에 자세히 보기)
            [ㅁ]   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    [정리]   
        ㅁ 
    [추가사항]    
        1.작성한 자바소스 파일이 어떻게 사용되어지고 그 중간중간 과정에서의 의미있는 용어들이나 부분에 대해 보겠다.
            1-1.우선, 작성한 자바소스는 즉, 확장자가 .java인 파일을 자바 컴파일러를 통해 자바 바이트코드로 컴파일 한다.
                [참조링크 : https://steady-snail.tistory.com/67]   
                [참조링크 : https://tjdrnr05571.tistory.com/19]    
            1-2.컴파일된 바이트코드를 JVM(자바 가상 머신)의 클래스로더에게 전달하며, 그리고나서 클래스 로더가 클래스(바이트코드)
                를 JVM내의 Runtime Data Area 즉, JVM의 메모리에 올린다. 이 클래스로더가 JVM내에 클래스를 올리는것을 클래스 로딩이라 한다.
                [참조링크 : https://tjdrnr05571.tistory.com/19]    
                [참조링크 : https://steady-snail.tistory.com/67]    
                [참조링크 : https://gbsb.tistory.com/2]    
                [참조링크 : https://taes-k.github.io/2019/07/16/java-class-loading/] / 클래스 로딩   
            1-3.아래 참조링크를 보면, 컴파일 과정을 마친 응용 프로그램이 사용자에 의해서 실행되어지는 '때'가 바로
                런타임이라고 한다. 근데 두번째 참조링크를 보면, 이 main함수가 실행될때를 런타임의 시작이라고 보며 세번째 네번째
                참조링크를 참조하여, 이 main함수가 실행되는것을 다른말로 JVM메모리에 올라온 바이트 코드들을 실행한다 라고 볼 수 있을것 같다.
                만약 더 자세하게 봐야하거나, 고쳐야 할 것이 있다면 다시 봐보도록 하자.
                [참조링크 : https://dd-corp.tistory.com/9] / 실행되어지는 때를 런타임
                [참조링크 : https://taes-k.github.io/2019/07/16/java-class-loading/] / main함수를 동작시키는 중에 class를 로드할때 런타임 로드라 하는것보니, main함수를 동작시키고나서를 런타임의 상황이라고 볼 수 있을것같다.(틀리거나 더 정확하게 봐야한다면 다시보기) 
                [참조링크 : https://steady-snail.tistory.com/67] / JVM메모리에 올라온 바이트 코드들을 실행     
                [참조링크 : https://gbsb.tistory.com/2] / JVM메모리에 올라온 바이트 코드들을 실행 + 그 외 기타내용 
                [참조링크 : https://gbsb.tistory.com/2] / JVM이 바이트코드를 해석하여 자바 프로그램이 실행
            [추가사항]   
                자바에서 인스턴스 생성(new 생성자)이나 스프링이나 스프링부트에서 빈 객체를 생성하는것 모두 런타임에서 하는
                것이다.
                [참조문헌 : 스프링5 47pg] / 여기보면, 런타임시에 자바 설정에서 정보를 읽어와 빈 객체를 생성하고 관리한다.
        2.JRE 그리고 JVM / 자바 소스코드와 자바 컴파일러 그리고 바이트코드
            2-1.JRE와 JVM의 관계를 정리하자면, JRE는 JVM이 자바프로그램을 실행시킬 때 필요한 라이브러리들과
                기타 등등 파일을 가지고 있다고 한다. 즉, JRE는 JVM의 실행환경을 구현한것이다. 그러기에 아래 참조
                문헌에 보면 JRE가 설치되어있으면, JVM이 설치되어있는것이라고 한다.
                [참조링크 : https://dohwankim.tistory.com/35]   
                [참조문헌 : 자바 21pg]   
            2-2.자바 소스코드(.java파일)는 자바 컴파일러에 의해 바이트 코드(.class파일)로 바뀌고 이 바이트 코드들은 리눅스나 윈도우의
                JVM에서 실행이 되는것이다. 이때 바이트 코드는, 운영체제에 맞는 완벽한 기계어가 아닌 중간 기계어 이며, 자바 가상 머신이
                운영체제에 맞는 완벽한 기계어로 바꿔주게 되어 실행이 되는거다.
                [참조문헌 : 자바 21pg]   
.
.
.
2.인터페이스형과 구현체형 사이에서의 알아야할 지식들 정리
    1.인터페이스와 설정파일, @Component의 빈 생성과 빈 주입에 관하여
        1-1.인터페이스형 반환형의 메서드에서, 반환되는 값이 구현체형 인스턴스이거나, 아니면 반환되는 값이 인터페이스형으로 형변환된 구현체형인것에
            차이가 있냐는것이다. 원래는 이전까지는 인터페이스형 반환형 메서드에서 구현체 인스턴스가 인터페이스형으로 형변환되어서 인터페이스형 변수로
            값이 반환되었을때는, 당연히 그냥 형변환된 구현체 인스턴스가 인터페이스형 변수로 반환됬다고 봤는데, 다른 그저 구현체 인스턴스만 반환됬을때는
            어떨지 몰랐다. 그런데, 직접 구현체 인스턴스만 반환된 경우,(해당 메서드의 반환형은 인터페이스형) 이 경우는 해당 구현체형의 인스턴스가 인터페이스형으로
            형변환된 후에 나오게 된다. 직접 설정파일에 각각 인터페이스형 반환형 메서드에 한개는 구현체 인스턴스만 반환하고 다른 하나는 인터페이스형 변수에 구현체형
            인스턴스를 대입하여 자동형변환을 시킨후 해당 인터페이스형 변수를 반환했다. 그리고 나서 각각 ctx.getBean("빈 이름",인터페이스.class) 으로 해당 빈 객체를
            갖고온다음에, 인터페이스형 변수에 넣으니 잘 들어갔다. 그러나 각각(이때 인터페이스형은 Test였고, 하나 구현체는 Test1, 다른 하나 구현체는 Test2이였다.), ctx.getBean
            으로 반환되는 빈을 각각 구현체 Test1형의 변수와 구현체 Test2형의 변수에 넣으려고 하니 형이 맞지 않다고 각자 오류가 났었다. 또한, 아래 정리에 추가로 getClass,getName
            메서드를 사용한것에 대해 정리했다.
            또한,
            getClass()를 사용했을때 해당 클래스 정보를 담긴 Class 형 객체를 반환하게 되는데, 인터페이스형으로 자동형변환된 인터페이스형 변수에 쓰거나
            아니면, 그냥 구현체형의 인스턴스인데 인터페이스형으로 자동형변환되고 인터페이스형의 변수가 가리키고 있지않은 상태의 인스턴스자체에 getClass()를
            쓰거나, 둘다 .getClass()로 받아오는 클래스 정보는 모두 구현체형의 클래스 정보를 받아왔었다. 직접 둘다 해보고 getName()으로 확인까지 했었다. 
            [직접해봄]   
            [참조링크 : https://woochan-autobiography.tistory.com/222] / .getClass()사용시 Class형 객체 반환(Class형 인스턴스반환으로 봐도될듯) 
            [정리]    
            즉, 정리하자면, 애초에, 
                1.인터페이스를 구현한 구현체의 경우, 자동형변환이 이루어지면 구현체 인스턴스의 형 자체가 변하는것이다. 
                2.인터페이스형 반환형 메서드에서 구현체 인스턴스 자체를 반환하면 형변환된 구현체 인스턴스가 반환되고, 
                    인터페이스형 변수에 형변환하여 해당 변수를 반환하면 형변환된 인터페이스형 변수가 반환되는거다.
                3.인터페이스형으로 형변환된 구현체인스턴스를 가리키는 변수에다 쓰던, 아니면 ctx.getBean(~)으로 직접(여기에다 직접 메서드씀) 
                    자동형변환된 구현체 인스턴스를 쓰던지, (여기서, 이 ctx.getBean으로 갖고온것은 설정파일에서 인터페이스 반환형 메서드에서 구현체 인스턴스 자체만 반환한거를 쓴거다.) 어느것이든
                    getClass().getName()으로 하면, 해당 구현체 클래스의 패키지명과 클래스명이 떳었다.
            [직접해봄]   
        1-2.구현체형이 인터페이스형으로 형변환이 이루어지면, 단순히 구현체 인스턴스의 주소값을 인터페이스형 변수가 가르키는것 외에도 애초에
            구현체 인스턴스 자체가 형변환이 일어나게 된다. 아 그러면, 여태 단순히 인터페이스형의 변수에 의해 해당 인터페이스형의 멤버변수나 메서드를 이용할
            수 있었던게 아니라, 구현체같은 인스턴스 자체가 형변환을 일으켜서 그런게 가능했고, 형변환을 했기에 그걸 인터페이스형 변수가 가리킬 수 있었던 거다.
            위에보면 왜 그런지 자세히 알 수 있다.
            [직접해봄]   
            [참조문헌 : 자바책 319pg]    
        1-3.위의 내용들에서, 설정 파일에서 메서드의 반환형이 인터페이스형이고 여기서 구현체 클래스의 인스턴스만 반환하던, 아니면
            구현체 클래스의 인스턴스를 인터페이스형 변수로 가리켜서 그 인터페이스형 변수를 반환하던지, 이는 main함수가 있는 클래스에서
            ctx.getBean("메서드명",인터페이스형.class)으로 이것들을 각각 둘다 빈값을 갖고오게 했는데, 둘다 어느 하나도 구현체 클래스를 import
            할 필요가 없었다.(필요하면 import해야하는 상황이였음) 또한, 이는 일반 자바에서 방금한것과 같이 똑같이 일반 인터페이스형 반환 메서드에
            사용했어도 똑같은 결과가 나올것이다. 만약 다르다면 나중에 다시 정리하자. 그러나 같을것이다.
            [직접해봄]   
        1-4.위의 1.3과 같이 인터페이스형 변수(service같은거)에 @Autowired나 생성자 주입으로 구현체 빈을 주입하는 경우에도 import문이 필요하지 않았었다. 
            직접 예를 들은것은 @Controller에서 Service인터페이스형에 관해서이며, 근데 이 경우는 일종의 구현체가 인터페이스형 변수에 대입되는거로 자동형변환이
            일어나는것으로 보이는데 위의 1.3에서 import문이 필요없었던거랑은 조금 다른것으로 보인다. 아마 내부적으로 처리하는것으로 이 또한 import문이 
            필요하지 않다는것을 알았다.(설정파일에서 파라미터로 자동주입하는것은 필요한지 안필요한지는 나중에 알아봐야할때 알아보자. 또한, 다른것들도.)
            [직접해봄]   
        1-5.직접해봤더니, 인터페이스형 변수에 생성자주입이나 @Autowired를 쓰게되면 알아서 구현체의 빈이 주입이 된다. 이는 구현체가 하나밖에 없는경우
            인터페이스형의 변수명이 아무거나 되도 구현체 빈이 주입이 되고, 만약에 여러개인 경우에는 해당 구현체의 빈의 이름을 인터페이스형 변수명으로 해서
            어떤 구현체를 주입할지 알려주어야 한다. 그렇지않으면 어떤 구현체 빈을 주입할지 몰라서 예외를 발생시키며, 이는 @Controller에서 서비스 인터페이스로도
            해본거지만, 직접 스프링에서 따로 인터페이스와 구현체 빈을 이용해서 해본 결과다. 찾아보니까, 이는 일반 클래스파일의 타입형 빈이 싱글톤이 아닐경우,
            변수명으로 같은 '형'의 빈을 주입하는 방법말고도 @Qualifier와 @Component, @Service등에 한정자를 추가로 적용해주는 방법이 있다. 이를 인터페이스형
            변수에도 똑같이 적용하는것이 있는데, 이 방법도 있고 다른 방법도 있는것같은데 이는 나중에 필요할시 다시 봐보도록 하겠다.
            [직접해봄]    
            [참조문헌 : 스프링5 책 115pg ~ 129pg] /    
            [참조링크 : https://hyeonguj.github.io/2020/02/07/java-interface-1/]   
            [참조링크 : https://sunghs.tistory.com/15]   
            [참조링크 : https://velog.io/@owljoa/Spring-Boot-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%8B%9C-%EC%84%9C%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%8B%9D%EB%B3%84-%EB%B0%A9%EB%B2%95]   
        1-6.@Component 빈과 설정파일에서 인터페이스형으로 추가한 빈 그리고 ctx.getBean 마지막으로 생성자주입, @Autowired주입, 설정파일 파라미터명 주입과의 관계 
            (1).먼저, 인터페이스와 이를 구현한 구현체 클래스 2개가 있다고 하고, 설정파일에는 딱히 아무것도 안써주었다고 하자.(구현체 클래스는 @Component로 빈 등록)
                그러고 나서, 인터페이스형 변수를 생성자주입하는데 쓰거나 @Autowired로 인터페이스형 변수에 주입하거나 설정파일의 파라미터에 인터페이스형 파라미터가 쓰인다고
                하면, 모두 구현체 클래스가 알맞게 들어간다. 또한, 어떤 인터페이스가 있고 이를 구현한 구현체 클래스가 하나이며 이를 @Component로 하고 설정파일에는 아무것도 안적어주었을 경우에도, 
                설정파일의 빈 메서드에서 파라미터에 해당 인터페이스형의 변수가 써져있다면 정상적으로 해당 구현체가 주입이 됬었다. 또한, 여기서는 구현체가 하나여서 그런지 해당 
                파라미터명이 아무거나 넣어도 그대로 다 정상적으로 작동하였다.(여기서 @Component로 구현체를 빈으로 등록했을때는(1개만 빈 등록) 설정파일의 파라미터에서 인터페이스형이 쓰이는 경우, 해당 파라미터명을
                아무거나해도 주입이 되는지는 확인하지 않았으나 가능한것으로 간주하고 한다. 문제 있을시에 다시 정리하자.) (만약 구현한 구현체 클래스가 빈이 2개이상일 경우, 파라미터명을 빈이름으로 적어준경우 해당 빈이 
                주입되는지에 관해서는 나중에 필요시 해보자.) 또한, ctx.getBean("빈이름",인터페이스명.class) 으로 받아오려는 경우에는, 빈이름에는 만약 구현체 클래스가 2개이고
                이 중 하나만, @Component로 빈 등록이 되있다면 빈이름에는 이 @Component된 클래스의 빈이름을 적어주어야 한다. 그렇지않으면 다른 빈이름들을 적어주면 예외가
                발생하게된다. 여기서는 다른 아무 설정없이 @Component로 구현체가 1개만 빈으로 등록되어있어도 이랬다.
                [직접해봄]    
                +
                추가로, 만약에 @Component가 된 여러개의 구현체가 있다면, ctx.getBean("빈이름",인터페이스명.class) 에서, 해당 등록된 빈의 이름을 getBean에서 빈이름에
                정확히 적어주면 해당 구현체의 빈을 갖고왔었다.
                [직접해봄]
            (2).직접 설정 클래스에 인터페이스형 메서드를 설정하고, 반환되는값을 구현체 클래스의 인스턴스나 구현체 클래스의 인스턴스이며 이를 가리키는 인터페이스형
                변수인 경우 ctx.getBean("해당메서드이름",인터페이스명.clss)으로 설정 파일에서 작성한 반환값이 반환된다.(자동형변환된 구현체 빈 혹은 이를 가리키는 변수) 또한,
                이 경우에도 해당 메서드이름을 정확히 인터페이스 반환형 메서드 이름과 똑같아야지 제대로 작동한다. 그 외의 메서드이름을 적어준다면 모두 예외 발생한다. 여기서
                새로 알게 된점은, getBean에서 class명 적는곳에 인터페이스명을 적어도 작동한다는것이며, 설정파일에 인터페이스 반환형을 적을 수 있고, 또 이 반환형으로
                자동 형변환된 구현체 인스턴스나, 이를 가리키는 변수를 반환하여 이 것을 getBEan()에서 갖고온 빈으로도 쓸 수 있다는거다. (또한, 이렇게 설정파일을 추가할시, 인터페이스 형으로
                자동형변환된 인스턴스 자체를 반환하거나 아니면 인터페이스형 변수가 이를 가리킨 변수가 반환한경우 둘다 해봤는데, 설정파일 파라미터의 인터페이스형에 대한 주입도 정상적으로
                이루어졌고(Datasource로 직접해봄) 또한, 생성자주입이나, @Autowired주입에 인터페이스형을 썻는데, 해당 설정파일에 적힌게 정상적으로 주입됬다. 이때 다른 구현체가 @Component쓰인것도
                아니였다. 또한, 이때도 설정파일에 해당 인터페이스형 메서드 하나만 적어주어서 그런지, 생성자주입이나 @Autowired 그리고 설정파일 파라미터형 변수명 모두 변수명이 제각각 달랐는데도
                모두 정상작동했다.) 물론 여기서도, 설정파일에 해당 인터페이스형 메서드가 하나밖에 없어도 getBean("빈이름",인터페이스명.class)에서 빈이름을 정확히 해당 메서드 이름과 같지 않으면
                예외를 발생했었다.
                [직접해봄]   
                [참조문헌 : 스프링부트 시작하기 48pg] / 설정파일에 인터페이스형이며 반환값은 형변환된 인스턴스인데 해닫 설정파일 다른 빈등록 메서드에서 파라미터로 인터페이스형 파라미터가 쓰였다.
                [참조문헌 : 스프링부트 시작하기 45 ~ 48pg] / DataSource로 직접 해봄  
                +
                여기서도 설정파일에 인터페이스 반환형 메서드를 만들고, 구현체 인스턴스나 구현체 인스턴스를 가리키는 인터페이스형 변수를 반환값으로 반환할때 해당하는 인터페이스 반환형
                메서드를 2개만들고 메서드 이름만 다르게 했는데, getBean("빈이름",인터페이스명.class)에서 빈이름에 각각의 방금 적은 메서드 이름을 빈이름에 정확히 적어주니 해당 빈 객체를
                갖고왔었다.
                [직접해봄]   
            (3).또한, 인터페이스형이 있고 이를 구현한 구현체가 2개 있을때 하나의 구현체는 @Component를 붙여서 빈을 등록하고, 하나는 설정파일에서 빈 메서드의 반환형이
                인터페이스형으로 하고 적절한 메서드명을 정해주고 반환값으로 구현체 인스턴스나 구현체 인스턴스를 가리키는 인터페이스형 변수를 반환한다고 해보면, main함수에서
                ctx.getBean("빈이름",형.class)에서 해당하는 빈이름을 적어주는것에 따라서, 설정파일 혹은 @Component한 빈을 갖고온다.
                [직접해봄]     
            (4).마지막으로, getBean에 대한 추가적인 내용인데, 내가 만약 설정파일에 일반 클래스 반환형에 메서드이름을 정해주거나 @Component로 설정을 대신해준다 해도, 싱글톤이라 해도
                각각, getBean에서 메서드이름에 해당 설정파일의 메서드이름이나 @Component 해준 클래스 파일명(첫글자 소문자)를 제대로 해주지 않으면 예외 발생한다. getBean에서는 그렇다.
                [직접해봄]     
        [정리]    
            1.아래 AOP를 사용하기위해 프록시 객체가 적용되는것을 이해하기 위한, 내용 정리이다. 우선, 여기서 핵심은 @Component로 빈 등록, @Bean을 이용한 빈 등록, @Autowired나 생성자주입 설정파일 파라미터 주입,
                마지막으로 ctx.getBean을 이용한 빈 객체 가져오기를 서로 각자 다른 역활을 하는것으로 인지하는것에서 출발해야 한다. 우선 제일 중요한건, 인터페이스의 구현체 클래스에서 @Component로 빈 등록을 한다는 말은
                해당 구현체 클래스 형의 빈타입과 해당 클래스 명의 첫글자만 소문자로한 빈 이름이 빈으로 등록된다고 볼 수 있지만, 동시에 해당 클래스는 구현한 인터페이스형도 될 수 있기에, 빈 타입은 인터페이스형으로
                하고 빈이름은 해당 구현체 클래스의 빈 이름의 첫글자만 소문자로 한것이 빈으로 등록됬다고 보는것이다. 즉, 구현체를 @Component로 빈 등록하면 구현체 형과 인터페이스형 두 타입의 빈이 동시에 등록된다고
                봐도된다. 그래서 main함수에서 ctx.getBean("구현체 클래스 이름",인터페이스명.class)에서 구현체만 @Component로 등록했는데도 이렇게 getBean을 적어주면(구현체 클래스 이름과 인터페이스명.class)
                정상적으로 빈을 불러오는데, 여기서 직접해보니 반환되는 형이 인터페이스형으로 이미 형변환된 구현체형을 값으로 갖고왔었다.(실제로 getBean으로 갖고온 빈을 구현체 형으로 할려하니 예외 발생했다.) 근데,
                여기서도 애초에 인터페이스형으로 이미 형변환된 구현체빈을 갖고오는걸 보니, @Autowired나 생성자주입, 설정파일 파라미터에 쓰이는 인터페이스형들도 모두 빈이 주입될때 이미 형변환이 끝난
                구현체 빈을 주입하는것같다.(import문 이해에도 도움)
                [직접해봄]    
            2.두번째는 설정파일로 반환형은 인터페이스형으로 하면서, 반환되는 값은 구현체 인스턴스나 이를 가리키는 인터페이스형 변수이다. 여기서 신기한것은 직접해본봐로는 만약, 이 해당 빈만
                등록을 하고 해당 구현체는 따로 빈 등록을 하지 않는경우는 어떻게 될까이다. 이 경우에 ctx.getBean("메서드이름",구현체명.class)로 하고 메서드 이름에는 설정파일에 인터페이스 반환형의
                앞선 메서드명을 적어주고 구현체명은 해당 설정파일의 인터페이스 반환형 메서드에 쓰인 구현체 클래스를 적어주면, 해당 구현체 클래스에 해당하는 빈을 반환한다. 그러나 내가 해당 구현체
                타입에 대해서 @Autowired나 생성자주입 아니면 설정파일의 파라미터에 쓰게되면 주입할 해당 타입의 빈이 없다고 예외를 발생시킨다. 즉, 내 생각에는 이 설정파일에 인터페이스 반환형으로 등록한
                메서드를 써주게 되면, 첫번째로 해당 인터페이스형의 메서드 명에 해당하는 빈이 등록이 되고(자동형변환된 구현체 인스턴스 혹은 이를 가리키는 변수) 그리고 나서, 예외적으로 설정파일의 인터페이스 반환형
                메서드에 쓰인 구현체만 ctx.getBean("메서드이름",구현체명.class)와 같이 메서드이름에는 해당 설정파일의 인터페이스반환형 메서드이름을 써주면, 실제로 구현체 타입의 빈을 값을 반환한다.(직접 구현체 타입 변수로 확인해봄)
                내 생각에는 이 부분만 예외적으로 허용한다고 밖에 볼 수 없다. 나중에 필요시 다시 봐보도록 하자.
            [결론]   
                설정파일에 인터페이스형의 메서드를 써주던, 구현체에 @Component로 빈을 등록하던, 인터페이스형의 빈이 생성되고 관리되며 이를 이용하는 방식을 결론적으로
                동일한것으로 보인다. 오히려, 구현체와 관련된 빈 사용에 대해서만 차이가 난다.
                [직접해봄]    
    2.위의 1. 내용들을 토대로 보면, @Service나 @Mapper 인터페이스들이 어떻게 @Controller나 @Service에서 구현체가 주입되는지 이제는 알 수 있다. 바로
        구현체가 하나이기때문에 그냥 인터페이스형 변수(@Autowired나 생성자주입에)를 쓰면 해당 구현체 빈이 주입되는거다.
        [직접해봄]    
    3.자바의 메서드의 파라미터나 생성자의 파라미터에 인터페이스형이 쓰이게 되고, 거기에 구현체 인스턴스가 실제로 들어가게되면,
        그 구현체 인스턴스는 자동 형변환이 된다음에, 생성자 함수나 메서드 함수에서 적용이 되는거다. 즉, 첫번째로 자바 객체의 생성자나 메서드의
        파라미터에 인터페이스형을 쓸 수 있는게 허용이 되고 두번째로, 거기에는 구현체 인스턴스만 들어갈 수 있는데, 그럴경우 자동형변환되서 생성자나 메서드
        함수내에서 자동형변환된 파라미터변수로 사용된다는거다. 그래서 검증을 했더니 함수 내에서 해당 구현체 인스턴스를 인터페이스형 변수에 대입하는것은 가능했는데, 
        해당 구현체 형의 변수에 대입하려하면 형이 맞지 않다고 나왔다. 이게 비슷하게 쓰인게 아래 스프링부트 시작하기 초록책 48pg인데, 지금 설명한것과 차이점은
        내가 봤을때 자바의 메서드나 생성자의 파라미터에 쓰이는경우 실제 구현체 인스턴스가 주입되는 경우 자동형변환되서 함수내에서 적용이 되지만, 아래 스프링부트의
        설정파일의 메서드에서 사용된 파라미터의 인터페이스형은 애초에 주입되는값이 형변환된 값이고 그대로 그게 함수내에서 쓰이는것으로 보인다. 이는 내가 직접 보고
        생각한 것이다. 조금 같은듯 다른것으로 생각하는게 편할것같다.
        [직접해봄]   
        [참조문헌 : 스프링5 155pg]   
        [참조문헌 : 스프링부트 시작하기 초록책 48pg]   
.
.
.
    3.AOP와 스프링 AOP에 대한 개념설명
        (3-1).AOP의 개념과 스프링 AOP에 대해 보겠다.
            1.AOP의 개념
                AOP의 기본 개념은 핵심 기능에 공통 기능을 삽입한다는 것이다. 즉, 핵심기능을 구현한 코드와 공통 기능을 구현한 코드를 분리함으로써,
                핵심 기능의 코드를 수정하지 않으면서 공통 기능의 구현을 추가하고 이 공통기능 코드를 재활용 하는것이 AOP이다. 
                [참조문헌 : 스프링5 158pg]   
                [참조링크 : https://engkimbs.tistory.com/746]
            2.SPRING AOP에 대해
                spring에서는 이 AOP라는 기법대로 코드를 짜보겠다는거다. 스프링은 이 AOP의 기능을 프록시를 이용해서 구현한다.
                [참조문헌 : 스프링5 158pg]
.
.
.
    4.스프링 프록시를 구하는 두가지(1).JDK Dynamic Proxy와 (2).CGLIB 방법이 있는데, 이 두가지 방법들에 대해서 정리하겠다.         
        (1).JDK Dynamic Proxy
            (1-1).시작하기에 앞서, 동적로딩에 대해 먼저 알아야 한다.
                우선 동적로딩에 대해 알아볼것인데, (핵심 기능에 공통기능을 삽입하는 3가지 방법의 글에 간단하게 클래스로더와 클래스로딩
                그리고 JVM 메모리에 올리는것에 대해 정리되어있다. 이것 참고하기) 클래스 로더에서는 받은 바이트코드(.class 파일의 코드들)를
                JVM의 메모리에 올리는것을 클래스로딩이라고 한다 했다. 추가로 아래 첫번째 참조링크에 보면, 이는 다른 말로 해당 .class 객체를 생성하는
                동작이라고 한다. 근데 이 클래스 로더가 해당 자바 프로그램 실행시에 모든 클래스 파일(.class = 바이트코드)들을 한번에 JVM 메모리에 로드
                시키지 않고, 요청이 들어온 순간만 로딩(객체 생성)시킨다고 한다. 즉, 이러한 행위를 동적로딩이라 하는데, 다시 한번 정리하자면 동적로딩이란
                모든 클래스가 Java프로그램 실행시에 로딩(객체 생성) 되지 않고, 필요한 시점에 클래스파일(.class)을 로딩(객체 생성)시킨다는것이다.
                동적로딩 외의 로딩은 필요시 자세히 찾아보도록 하자.
                [참조링크 : https://futurists.tistory.com/43]   
                [참조링크 : https://stack07142.tistory.com/306] / 동적로딩의 개념
                +
                동적로딩에는 두가지 종류가 있다. 하나는, 로드 타임 동적 로딩이다. 로드타임 동적로딩은
                하나의 클래스를 로딩하는 과정에서 필요한 다른 클래스를 동적으로 로딩하는 것 이다. 
                아래 예시는 로드타임 동적로딩에 관한 예시이다.
                public class Hello { 
                    public static void main(String[] args) { 
                        System.out.println("Hello, world!"); 
                    }
                }
                이 코드를 보면, Hello 클래스를 로드(객체 생성)할 때 이 클래스가 참조하고 있는 Object, String, System. 클래스가 아직 로드(객체 생성)
                되지 않았으므로, Hello 클래스를 로드(객체 생성)하는 일을 중단하고 우선 이 클래스들을 로딩(객체 생성)해야 한다. 이 처럼 한 클래스의 로드(객체 생성)
                에 필요한 다른 클래스들을 동적 로딩하는 것을 로드타임 동적로딩이라한다.
                [참조링크 : https://futurists.tistory.com/43] / 예시들
                [참조링크 : https://stack07142.tistory.com/306] / 로드타임 동적로딩과 런타임 동적로딩
                +
                다른 하나는 런타임 동적로딩으로 코드를 실행하는 순간에 필요한 클래스를 로딩하는 것이다. 즉, 런타임 시에
                필요한 경우 클래스를 로딩하여 사용한다는것이다. 이것에 대한 개념만 알아두고 자세한 예시는 아래 JDK Dynamic Proxy가
                런타임 동적로딩을 통해 만들어지니, 이것으로 예시를 보이겠다.(사실 어디서도 프록시를 동적로딩을 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ㅍ@)
                [참조링크 : https://stack07142.tistory.com/306] / 로드타임 동적로딩과 런타임 동적로딩
                [참조링크 : https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html] / JDK Dynamic Proxy는 프록시를 동적으로 생성해준다.    
            (1-2).자바의 리플렉션(reflection)에 대해 알아보자.
                자바의 리플렉션이란 구체적인 클래스 정보들을 알지 못할때, 해당 클래스의 정보들에 대해 접근 할 수 있게 해주는 자바 API이다. 
                즉, 자바 프로그램을 실행하게되면 자바 파일은 클래스 파일(바이트코드)로 컴파일 되어 모든 클래스파일들은 Static영역에 위치하게된다.
                (이 부분 틀린부분 있으면 나중에 다시 봐보도록 하자.) 그러기에, 클래스 파일 이름만 알고있다면, 리플렉션 api를 이용해서 해당 클래스
                정보를 갖고와 해당 클래스를 동적로딩(객체 생성)이 가능하게 해준다. 즉, 자바의 리플렉션은, 다른 클래스 들의 정보를 갖고오게 해주어,
                해당 클래스를 동적 로딩(객체 생성)하게 해주는 기능이 있는것이다. 
                [참조링크 : https://taes-k.github.io/2021/05/15/dynamic-proxy-reflection/] / 자바 리플렉션 정의   
                [참조링크 : https://brunch.co.kr/@kd4/8] / 자바 리플렉션 정의   
                [참조링크 : https://brunch.co.kr/@kd4/8] / 모든 클래스 파일은 Static영역에 저장된다.
                [참조링크 : https://madplay.github.io/post/java-reflection] / 근데 여기서 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적로딩(객체생성)할 때 쓴다는것보니, 리플렉션은 런타인 동적로딩에만 쓸 수 있나보다.(나중에 틀리거나,필요시 자세히 보기, 아래 링크가 그 내용)   
                [참조링크 : https://velog.io/@agugu95/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%86%8D%EB%8F%84-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EA%B8%B0%EB%B2%95%EB%93%A4] / 추가적인 로드타임 런타임 동적로딩, 리플렉션에 관하여
                +
                자바 리플렉션에서 제공하는 기능중 하나인 Class.forName()메서드 말고도 많은 메서드가 있다.
                [참조링크 : https://jongminlee0.github.io/2019/06/29/reflection/]
            (1-3).이제 스프링 AOP에 사용되는 프록시 중 하나인 JDK Dynamic Proxy에 대해 정리하겠다.
                (1).DK Dynamic Proxy(동적 프록시)는 왜 JDK Dynamic Proxy로 불리느냐이다. 바로, 이 동적 프록시는 자바 리플렉션을 이용해서
                    동적으로 생성하는 프록시 객체이기 떄문이다.(내가 설명한 글들을 토대로라면 사실상 동적로딩을 통해 프록시를 생성한다라고 볼 수 있다.
                    근데 어디서든 동적으로 프록시 생성한다고 하지, 동적로딩을 통해 생성한다고 말을 안한다. 인지만 하기.) 그러하기 때문에 동적 프록시라고
                    한다.
                    [참조링크 : https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html]    
                    [참조링크 : https://taes-k.github.io/2021/05/15/dynamic-proxy-reflection/]     
                    [참조링크 : https://sabarada.tistory.com/97]     
                    [참조문헌 : 스프링5 158pg] / 런타임에 프록시(JDK Dynamic Proxy) 객체를 생성한다.        
                (2).JDK Dynamic Proxy가 생성되는 과정에 대해 알아보도록 하겠다.
                    1.우선 JDK Dynamic Proxy 즉, 어느 빈을 프록시로 생성할지에 대해서는 '포인트컷'이라는걸 적용해서 지정한다.(구체적인 방법에 대해서는 아래에 포인트컷에서 보고
                        여기서는 JDK Dynamic Proxy가 생성되는 과정에서 필요한 정보만 정리하도록 하겠다.) 포인트컷은 동적 프록시 생성이 기본인 스프링에서는, 인터페이스 아니면 인터페이스를
                        구현한 구현체 클래스를 지정하고 그에 해당하는 메서드를 지정할 수 있다. 만약 인터페이스를 포인트컷으로 지정하고 특정 메서드를 지정하게 된다면, 이것이 의미하는 바는 해당 인터페이스형
                        타입의 모든 빈은 프록시 객체로 대신생성하겠다는 의미이다. 추가로, 만약 인터페이스를 구현한 특정 구현체와 해당하는 메서드를 포인트컷으로 지정하면 해당 구현체의 구현한 인터페이스형의
                        타입과 빈 이름이 구현체클래스의 이름의 첫번째글자만 소문자로 바꾼것만 프록시 객체로 생성하겠다는 의미다.(즉, 앞에서 봤듯이, 구현체 클래스를 @Component로 빈등록시에 해당 구현한 인터페이스
                        형의 빈도 동시에 등록된다고 했다. + 설정파일에서 @Bean으로 등록시에는 어떤지 모르나, 이것은 필요한 경우에 하자.) 
                        [직접해봄]   
                    2.그럼 실질적으로 프록시 객체가 생성되는 과정과, 구체적인 내용에 대해 보도록 하겠다. 우선, 아래에 @EnableAspectJAutoProxy에 관한 정리된 내용을 보면, 
                        @Aspect가 붙은 빈을 찾아서 @PointCut과 @Around 설정을 사용한다고 한다. 즉, 우선 Aspect클래스를 정상적으로 필요한것들을 모두 작성하고 프로젝트를 실행시키면,
                        Aspect클래스는 빈으로 등록되고, 그 빈의 @PointCut으로 특정 클래스의 메서드에 대해 프록시를 생성할 기준을 적용하고 @Around를 적용할 준비를 하는것 같다.@@@@@@@@@@@@
                        우선적으로, @@@@@@@@@@@@@@@@@
                        [직접해봄]     
                        [참조링크 : ]    
                        [참조링크 : ]    
                        +
                        실제로 어떠한 구현체 빈이 사용되냐를 기준으로 프록시 객체를 생성하는거다. 즉, 만약 구현체 클래스가 여러개이나 1개의 구현체 클래스만
                        @Component를 적용했다면, 생성자주입 같은데에 인터페이스형의 변수명이 꼭 구현체 클래스의 이름의 첫번째 글자만 소문자로 바꾼 이름이 아니더라도
                        해당 인터페이스 타입이면서, 자동형변환된 구현체가 해당 @Component인 빈이 주입되는것도 괜찮다.@@@@@@@@@@@@@
                        [직접해봄]
                        특정 인터페이스의 메서드를 적용한다고 한다면, 빈 중에 해당 인터페이스 타입에
                        해당하는 모든 빈들은 프록시 객체로 생성하게 된다.(즉, 생성자주입, @Autowired, ctx.getBean("~",인터페이스명.class)) 이게 가능한 이유는
                        애초에, 구현체를 @Component로 빈 등록하면 앞서 말했듯이 두개의 빈이 등록되는것으로 볼 수 있다고 했다. 하나는 구현체 클래스 빈이고 다른 하나는
                        인터페이스 타입에 빈이름이 구현체 클래스명의 첫글자만 소문자로 한것이다. 그렇기에 이 방식대로 이해하면 되는것이다. 또한, 구현체를 포인트컷으로
                        명시한 경우에도, 구현체의 구현한 인터페이스 타입에 빈 이름이 구현체의 클래스명에 앞글자만 소문자로 딴것만 프록시 객체로 만든다. 즉, 빈의 타입이 인터페이스
                        이고, 빈 이름이 해당 구현체 클래스의 클래스명에 앞글자만 소문자로 한것만 프록시로 생성한다는 말이다.(이 부분들 중에 틀리거나 더 알아야 할 부분들이 있는데
                        그럴 경우에는 나중에 필요시에 다시 봐보도록 하자) 
                        [참조링크 : ]    
                        [참조링크 : ]        
                        +
                        당연히, 빈으로 등록된(@Component로) 구현체 클래스가 하나밖에 없는 경우에는 포인트컷으로 해당 구현체 클래스만 지목하게 되는 경우,
                        실제 생성자주입을 하되, 해당 인터페이스형의 변수명이 아무 변수명이나 적어도 프록시 객체가 정상적으로 생성이 됬었다. 이거로 보아, 실제로
                        실질적으로 어떤 빈이 주입(생성자주입, @Autowired, ctx.getBean등등)되느냐에 따라서 포인트컷이 적용되어 프록시 객체가 생성되는것같다.
                        [직접해봄]    
                        [참조링크 : ]     
                    2.
                        [참조링크 : ]   
                        [참조링크 : ]   
                        +
                        인터페이스 경우 해당 구현체는 모두 따로 못불러냄, actually 프록시 타입 어쩌구 뜸.
                        클래스도 그런가 ? 심지어 구현체 하나에 포인트컷적용했는데, 따로 해당 타입만 ctx.getbean으로
                        했는데 똑같이 뜸 
                        +
                        그런데, 위에 구현체만 포인트컷지정해놓고, ctx.getBean으로 인터페이스형하고, 빈이름에는 @Component적용된
                        구현체가 해당 클래스이름으로 인터페이스형 빈 이름도 설정해주니 이 이름을 getBean 빈 이름에 적어주니 프록시가
                        나왔다. 그러나, 다른 빈이름(calculator)을 해주니 오류났다.
                        +
                        즉, Dynamic Proxy는 기본적으로 적용이되도, 인터페이스형을 갖고올때만 가능한가보네 그리고 스프링5책에
                        설정파일에 인터페이스형 빈 추가했을때도 되는거보니 이 자동형변환된것을 프록시 객체 생성하는데 사용되나보다. 
                        이것도 함꼐 정리
                        +
                        그리고, 그 구현체를 직접 쓰려고 할떄 acuallty뭐라했던거는 ctx.getBean이나 아니면 생성자 구현체 클래스 주입에서
                        모두 그렇게 뜬거였다.
                        +
                        만약 구현체가 하나(구현체 클래스가 여러개여도 빈으로 등록시키는게 하나면 하나로 취급한다.)라면,
                        따른 클래스에서 testtest클래스같은데서 생성자주입으로 인터페이스형을 매개변수에 쓰데 해당 변수명을
                        아무거나 적어도 정상작동한다. 그러나, 당연히 ctx.getBean으로 인터페이스형 받아오는거에는 빈 이름을
                        정확히 적어주어야 적용된다.
                        +
                        아마 이 변수명에 대해서는(ctx말고) 그냥 싱글톤과 같은게 일반적으로 적용이 되는것같다. 그리고나서
                        프록시가 적용되는것으로 보인다.
                        +
                        [결론]   @@@@@@@@@@@@@@@@@@@
                            인터페이스의 메서드를 가리키는 경우 모든 타입이 인터페이스형인 빈에 대해서 프록시를 적용하고 만약 구현체만
                            포인트컷으로 적용대상이 된경우는 빈 타입이 인터페이스형이면서 해당 빈 이름(구현체에 해당)에 해당하는것만 프록시를
                            생성하게 된다.(인터페이스 타입으로 빈 등록되는것에 대한 사전 이해가 큰 역활을 하는듯★★★★★★★★★★★★.)
                            거기다가 ctx.getBean으로 인터페이스 타입으로 해도 프록시가 생성된다.@@@@@@@@@@@@@@@@@@@@@@
                    [추가사항]    
                        1.포인트컷은 애초에 어느 클래스의 어느 메서드에 공통기능을 적용할지를 정하는거다.(자세한건 뒤에 포인트컷 설명) 근데 이
                            포인트컷은 스프링부트가 아닌 스프링이 쓰이는곳에서는 기본적으로 JDK Dynamic Proxy를 사용하도록 설정이 되 있는데, 이
                            포인트컷을 해당하는 
                            [직접해봄] / 인터페이스와 이를 구현한 구현체 클래스를 둘다 가리키기도 해봤고, 인터페이스만 가리켜보기도 해봤고, 구현한 구현체만 가리켜보기도 했다.    
                            [참조링크 : ] / 여긴, 인터페이스만 가리킨다.   
                            [참조링크 : ] / 여긴, 구현한 구현체만 가리킨다.  
                            [참조문헌 : 스프링5 161pg] / 여긴, 인터페이스와 이를 구현한 구현체 모두 가리킨다.   
                        2.
                            [직접해봄]    
                (3).구체적인 JDK Dynamic Proxy가 만들어지는 과정과 그 과정에서의 알아야 할 요소들에 대해 설명하겠다.
                    [ㅁ]    
                (4).
                    [ㅁ]    
                    +
                    그 스프링과 스프링부트 cglib과 dynamic proxy쓰이는거관련 정리 해야해 기본 설정
        (2).CGLIB 프록시
            (1-1).
                ㅁ
            (1-2).
                ㅁ
            (1-3).위에 설명한것중에 하나인데, 여기도 포인트컷을 클래스(컨트롤러)에 해도되고 인터페이스형(boardService)에 했는데도 정상적으로
                작동하고 거기다 cglib으로 잘됬다. 또한, mapper도 따로 이해해야해
                ㅁ
        [추가사항]    
            (1).JDK Dynamic Proxy와 Cglib 프록시 객체 생성은 모두 런타임에 프록시 객체를 생성하는 방식이다.@@@@@@@@@@@@@@@
                [참조링크 : ]    
                [참조링크 : ]    
                +
                이는 아래 스프링5 158pg에 나오는 클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법과는 다른것이다.@@@@@@@@@@@@
                [참조문헌 : 스프링5 158pg]   
            (2).위빙(weaving)의 뜻에 대해 먼저 알아보고 가겠다.
                아래 참조링크들과 참조문헌을 보면, 첫번째 참조링크에서 위빙은 포인트컷으로 지정한 핵심 비즈니스 로직을
                가진 메소드가 호출될 때, 어드바이스에 해당하는 공통기능의 메소드가 삽입되는 과정을 의미한다고 했다(이건 런타임 위빙). 또한, 두번째
                참조문헌에서는 Advice를 핵심 로직 코드에 적용하는 것을 weaving이라고 했다. 세번째 참조링크를 보면, 공통기능과 핵심기능을
                linking을 하는 과정이 AOP의 Weaving(위빙)이라고 나와있다. 하지만, 이거를 있는 그대로 이해하려면 어려우니 이렇게 생각하면 된다.
                핵심코드가 있는 자바파일이나 클래스 파일에 공통기능 코드를 핵심기능 소스코드에 직접적으로 삽입시키거나(컴파일 시점 위빙, 로드 시점 위빙(클래스 로딩 시점 위빙)), 
                아니면 프록시 객체를 생성하는 방식에서, 포인트컷으로 지정한 핵심 비즈니스 로직을 가진 메소드가 호출될 때 공통기능과 핵심기능이 적용되어서 연동되는 과정을 위빙이라고
                보면 될것같다.(그러고나서 프록시 객체가 생성되는것은 위빙이라고 보기 어려울것같다.)
                [참조링크 : https://sa1341.github.io/2019/05/25/%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B0%9C%EB%85%90-%EB%B0%8F-Proxy%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B5%AC%EB%8F%99%EC%9B%90%EB%A6%AC/]    
                [참조문헌 : 스프링5 159pg]       
                [참조링크 : https://ehdvudee.tistory.com/22]   
                [참조문헌 : 스프링5 158pg] / 여기에도, 컴파일 시점 위빙과 클래스 로딩 위빙 그리고 런타임 위빙에 대해 나와있다.
                [참조링크 : https://logical-code.tistory.com/118] / 여기서 컴파일 시점 Weaving에서 설명을 보면 'Weaving된 class 파일' 이라 말하는것 보니, 공통기능 소스 코드가 핵심 로직 코드에 입력혹은 삽입되는것을 위빙(Weaving)이라는걸 알 수 있다.
                [참조링크 : https://logical-code.tistory.com/118] / 컴파일 시점 위빙, 로드 시점 위빙(클래스 로딩 시점 위빙)에 대해 나와있고, 컴파일 전 위빙도 여기 링크에 나와있지만 이건 나중에 필요시 다루기로 하자.
                [참조링크 : https://dahye-jeong.gitbook.io/spring/spring/2020-04-10-aop-aspectj] / 런타임 위빙에 관한 설명이며, 런타임시에 포인트컷으로 지정한 메서드가 호출시에 일어나느 위빙이라고 한다.
                [참조문헌 : 스프링부트 시작하기 초록책 106pg] / 여기서도 컴파일 시점 위빙이나, 로딩 위빙(클래스 로딩)은 공통기능 코드가 핵심기능 코드사이에 직접적으로 삽입된다고 나와있다.
                +
                아래 Spring AOP와 AspectJ에 대해 설명하는거에 나올텐데, Spring AOP는 런타임 Weaving(위빙)만을 지원하고,
                AspectJ 의 경우, 컴파일 전 위빙, 컴파일 시점 위빙, 로드 시점 위빙(클래스 로딩시)의 3가지 위빙방식만을 지원한다.
                이는 아래 참조문헌에도 나와있으며, 단, 책에서는 컴파일 전 위빙은 안나와있다.
                [참조링크 : https://logical-code.tistory.com/118] / AspectJ 지원 위빙 3가지 방식
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy] / 스프링 AOP는 런타임 위빙만 지원
                [참조링크 : https://logical-code.tistory.com/118] / 스프링 AOP는 런타임 위빙만 지원
                [참조문헌 : 스프링 158pg]       
                +
                아래 참조링크에 런타임 위빙은 Aspect 대상 객체의 프록시를 사용하는 애플리케이션의 실행 시에 위빙된다고 나와있다. 즉,
                말 그대로 런타임 중에 위빙이 되는거다.
                [참조링크 : https://logical-code.tistory.com/118]    
                +
                런타임 위빙의 경우 런타임 위빙이 일어나더라도, 실제로 소스파일이나 클래스 파일에는 전혀 변화가 없다고 한다
                [참조링크 : https://wjdtn7823.tistory.com/m/64]    
            (3).Spring AOP와 AspectJ에 대해 설명하도록 하겠다.
                스프링에서 AOP기능을 제공하는데, 그것이 바로 스프링 AOP이다.(아래 @EnableAspectJAutoProxy도 스프링AOP 기능에 포함된다고 본다, 비록
                (6).에서 보이는 실질적인 spring-aop와 spring-context처럼 모듈은 다르지만 말이다.) 즉, 스프링 안에서 할 수 있는 간단한 AOP구현만 제공하는것이다.
                즉, 완전한 AOP를 의도한것이 아니다. 반면에 AspectJ는 완전한 AOP를 제공하는 것이 목적으로써, 근원적으로 AOP를 완벽히 지원하기위한 것이다.
                [참조링크 : https://logical-code.tistory.com/118]   
                [참조링크 : https://gmoon92.github.io/spring/aop/2019/02/09/why-used-aop.html] / 스프링에서 제공하는 AOP란 스프링 AOP를 의미 
                +
                스프링 AOP에서는 런타임 위빙만을 지원하며, 이는 즉 런타임 위빙을 사용한다는것은 프록시 객체를 생성해서 사용한다는 말과같다. 
                또한, 추가로 Spring AOP는 메소드 실행에 대한 JoinPoint만 제공한다.
                [참조링크 : https://logical-code.tistory.com/118]    
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy]
                +
                AspectJ는 런타임 위빙은 지원하지않고, 컴파일 시점 위빙, 컴파일 전 위빙, 로드 시점(클래스 로딩) 위빙만을 지원한다.
                반대로 Spring AOP는 런타임 위빙만을 지원하는거다. 그렇기에, CGLIB이나 JDK Dynamic Proxy모두 프록시 객체를 생성하기에 스프링AOP를
                적용하는것이며 둘다 런타임 위빙을 사용한 Spring AOP로 구현되는것이다.
                [참조링크 : https://logical-code.tistory.com/118]    
                +
                그렇다면, 스프링 AOP만 이용하면 될것을 왜 AspectJ에 대한 의존성까지 추가하면서 이용하는 이유가 뭘까.
                바로, 두번째 참조링크에서 보듯이 스프링AOP에서 제공하기 힘들거나 아니면 더 효율적인 방안을 사용하기 위해, 
                AspectJ에 대한 의존성을 추가하고 사용하는것같다. 우선 눈에 보이는 코드로는 Aspect클래스에서 쓰이는 @Aspect, @Around,
                @Pointcut과 Signature, ProceedingJointPoint의 사용의 경우다. 추가로 첫번째 참조링크를 보면, 스프링 AOP는 이러한 AspectJ의
                어노테이션을 사용하더라도, 잘 AOP가 구현될수 있도록 구현방식을 제공하고 있다고 한다.
                [참조링크 : https://gmoon92.github.io/spring/aop/2019/02/09/why-used-aop.html]    
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy]        
                +
                스프링 AOP는 첫번쨰 참조링크를 보면 메서드 실행 포인트컷(Pointcut)만 지원한다고 나와있다. 그리고 AspectJ의
                경우에는, 모든 Pointcut을 지원한다고 나와있다. 그런데, 여기서 짚고 넘어가야할것이 조인포인트(JoinPoint)가 아래 개념을
                보면 알겠지만, Advice를 적용 가능한 지점을 의미하며, 그 예시로는 메서드 호출이나 필드 값 변경 혹은 여러가지 지점들이 있다.
                그 중에 실제로 Advice가 적용되는 지점을 Pointcut(포인트컷)이라고 하는거다. 그렇기에, 여기서 메서드 실행 포인트컷만 지원한다라고 적혀
                있는것에서 메서드 실행 조인포인트만 지원한다고 해도 같은말로 볼 수 있는거다. 실제로 두번쨰 참조링크에서는 조인포인트로 표현했다.
                [참조링크 : https://logical-code.tistory.com/118]    
                [참조문헌 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy]     
            (4).@EnableAspectJAutoProxy에 대해서도 함꼐 정리하도록 하겠다.  
                이 주석은, 아래 (5).에서도 나와있지만, spring-aop모듈과 사용되는 모듈이 조금 다르다. 그러나 이 @EnableAspectJAutoProxy도 스프링AOP 기능의 
                일부분이라고 여기는게 맞는것 같다. 이 주석의 기능은, 첫번째 참조문헌에서는 프록시 생성과 관련된 객체를 빈으로 등록한다고 나와있고,  두번째 참조링크
                에는 위에서 포인트컷으로 지정된 메서드를 호출시에 가로챌 수 있게 해주는 옵션이라고도 하고 마지막 세번쨰 참조링크에서는, AspectJ의 기능을 가져다
                쓰는데, 이 AspectJ의 기능을 사용할 수 있게 해준다고 한다. 이것도 나중에 구체적으로 알아야 하면 그때 다시 정리하도록 하고 여기서는 간단하게 정리해서
                사용되는 스프링AOP 기능과 AspectJ의 일부 기능들이 정상적으로 작동하게 해주는 주석이라고 이해하면 될것같다. 이 주석을 쓰지 않는다면 정상적으로 작동하지
                않는다.
                [직접해봄] / 이 주석을 빼고 스프링 프로젝트에서 사용했더니 AOP가 정상작동하지 않았다.   
                [참조문헌 : 스프링 163pg]  
                [참조링크 : https://jeong-pro.tistory.com/171]       
                [참조링크 : https://araikuma.tistory.com/309]    
                +
                추가로 @EnableAspectJAutoProxy에 대한 이해를 할 필요가 있는데, 이 주석은 이 @Aspect 주석을 붙인 클래스를
                빈으로 등록하려는 설정파일에 붙여야 하는 주석이다.(@ComponentScan과 @Component으로 빈을 등록하는 설정파일이던, 아니면
                직접 @Bean으로 설정파일에 코드를 작성하여 빈으로 등록하려는 설정파일이던) 아래 스프링 163pg의 참조문헌에 보면, @EnableAspectJAutoProxy에
                대한 기능얘기가 나오는데, 이것정도는 인지하고 왜 빈으로 등록한 설정파일에 적어줘야하는지로만 알고있자. 추가 기능이란, 이 @EnableAutoConfiguration주석을
                붙이면, 빈으로 등록한 것중에 @Aspect 애노테이션이 붙은 빈 을 찾아서 해당 빈 객체의 @PointCut설정과 @Around설정을 사용한다고 한다.(책에서도 빈 객체를 찾는다고
                나와있는데, 등록된 빈 객체 즉, 만들어진 객체를 찾는것으로 이해해도 될 것 같다. 이 부분 나중에 정확히 알아야 할 시에 다시 정리하도록 하자.)
                또한, @Component으로 @Aspect를 붙인 클래스를 빈 등록한 설정파일에서 직접해보았고, 이 설정파일에 @EnableAutoConfiguration를 안쓰니 정상작동하지 않았다.
                그리고 @Bean을 사용한 경우에도 직접은 안했지만 아래 참조문헌 163pg를 보면 똑같이 @Bean으로 빈 등록한 설정파일에 @EnableAutoConfiguration를 사용하고있다.
                [직접해봄]    
                [참조문헌 : 스프링 163pg] / 설정파일에 붙여주어야 한다.   
                [참조문헌 : 스프링부트 시작하기 초록책 107pg] / 여기는 Application 클래스에 @SpringBootApplication 주석에서 이러한 작동을 한다.
                +
                스프링부트에서는, 아래 첫번째 참조링크를 참고하면 @SpringBootApplication주석을 사용하게 되면, @EnableAutoConfiguration 주석을
                포함하게 된다. 근데 자동설정 주석을 사용하면 @Conditional타입의 주석인 @ConditionalOnClass와 @ConditionalOnPropery 주석을
                사용하게 되는데, 이 중에 @ConditionalOnClass는 AOP같은것을 실행시키기 위해 필요한 클래스들을 알아서 클래스패스에서 보고
                추가하게 된다고 한다. 참조링크를 보면, EnableAspectJAutoProxy.class도 추가된것을 볼 수 있다. 이렇게 사용하게 된다면,
                마치, @EnableAspectJAutoProxy 주석을 직접 사용한것과 동일하게 작동한다고 한다. 그렇기에 스프링부트 프로젝트에서는
                Application클래스(스프링부트에서는 이게 설정파일이다.)에서 @SpringBootApplication에 따로 
                @EnableAutoConfiguration를 추가하지 않아도 된다고 한다.
                [참조링크 : https://stackoverflow.com/questions/48625149/spring-aop-works-without-enableaspectjautoproxy]    
                [참조링크 : https://blog.junu.dev/38] / 스프링부트 사용시에 @EnableAspectJAutoProxy 따로 안써줘도 됨   
            (5).이 @EnableAspectJAutoProxy라는 주석은 스프링의 org.springframwork:spring-context모듈에서 갖고오는 주석이다.(스프링부트는 해당 스프링부트
                의존성 추가시 이 org.springframework:spring-context모듈이 다 포함되어있다.) 또한, 나머지 Aspect 클래스에서 사용되는 주석인 @Aspect, @Around, 
                @PointCut과 ProceedingJoinPoint 그리고 Signature를 사용하는 경우에는 모두 org.aspectj:aspectjweaver 모듈에서 갖고온 것들로만 사용하게 된다. 
                그리고 org.springframework:spring-aop 모듈은(org.springframework:spring-context모듈 하위에 있는) 직접적으로
                사용되어지는 코드가 보이진 않는다.
                [직접해봄]              
            (6).Advice(어드바이스), joinpoint(조인포인트), Pointcut(포인트컷), Weaving(위빙), Aspect(어스펙트)의 용어 정리
                1.Aspect
                    첫번쨰 참조링크에서는 흩어진 괌심사를 모듈화 한것이라 나오고, 두번째 참조링크에서는 여러 객체에 공통적으로
                    적용되는 관심 사항을 Aspect라고 한다. 마지막으로 세번째 참조문헌에서는 그냥 여러 객체에 공통으로 적용되는 기능을 Aspect
                    라고 한다고 한다. 트랜잭션이나 보안 등이 Aspect의 좋은 예라고 한다. 즉, 정리해봤을때 코드로 보기보다는 말 그대로 공통적인
                    기능이라고 보고 이해하면 될 것 같다. 또는 공통적인 기능을 모듈화한것 이라고도 볼 수 있을것같다. 두가지 기준으로 보는게 나을듯 하다.
                    추가로 마지막 네번째 참조문헌에 보면, Aspect는 한 개 이상의 포인트컷과 어드바이스의 조합으로 만들어져있다고 하는데, 
                    이는 Aspect를 공통적인 기능을 모듈화한 개념으로 적용해서 생각하면 될 것 같다.
                    [참조링크 : https://engkimbs.tistory.com/746]     
                    [참조링크 : https://logical-code.tistory.com/118]    
                    [참조문헌 : 스프링5 159pg]    
                    [참조문헌 : 스프링부트 시작하기 초록책 106pg]
                    +
                    Aspect로 사용할 클래스에 @Aspect를 붙인다고 한다. 이 @Aspect 주석의 경우 해당 클래스가 공통기능을 모듈화한
                    클래스라는 것을 알려주는 주석이라고 한다. 즉, Aspect클래스라는것을 알려주는 주석이다. 이 @Aspect가 붙었다고 해서 
                    자동으로 빈으로 등록되는것은 아니니, @Component를 붙여주거나 직접 설정파일에서 빈을 등록해주어야 한다. 두번째 참조링크에서도 
                    @Aspect 주석을 붙이는것 자체가 이 클래스가 Aspect를 나타내는 클래스라는 것을 명시한다고 한다. 즉, 좀 더 자세하게 설명하자면, 위의 @EnableAspectJAutoProxy 주석에 대한
                    기능을 보면, 스프링 프로젝트 실행시에 @Aspect가 붙은 클래스의 빈이 생성이 되어서 등록이 될거다.(아마, 자동으로 생성되는것으로 이해. 또한
                    이것이 스프링에서 AOP의 시작이라고 봐도 될듯 하다.) 그리고나서, @EnableAspectJAutoProxy의 기능중 하나라고 봤듯이 등록된 빈 중에
                    @Aspect가 설정이 된 빈을 찾아서 해당 빈의포인트컷에 대한 설정과 @Around의 사용을 위한 기본 설정이 되는것으로 사용이된다고 한다.
                    즉,
                    정리하자면, @Aspect를 붙이는것은 해당 클래스를 공통기능을 가진 클래스로 알리고 사용된다는 것이다.
                    또한 마지막 참조문헌에 보면, @Aspect 애노테이션을 적용한 클래스는 Advice와 포인트컷을 함께 제공한다고 한다.
                    [참조링크 : https://galid1.tistory.com/498]    
                    [참조링크 : https://engkimbs.tistory.com/746]         
                    [참조문헌 : 스프링5 161pg]     
                    +
                    Aspect로 사용되는 클래스 혹은 Aspect 클래스를 같은것으로 보고 
                    위에서 보았듯이, Aspect의 개념중 하나인 공통기능을 모듈화한
                    클래스라고 이해하면 될것 같다.
                    [참조문헌 : 스프링5 160pg]                 
                2.Weaving
                    위빙은 위에 정리해 놓았다.
                3.Advice
                    첫번쨰 참조링크에는 어드바이스(Advice)란, 타겟에 제공할 부가기능을 담고 있는 모듈이라고 한다. 두번째 참조링크에는
                    여기서도 실질적인 부가기능을 담은 구현체라고 적어놓았다. 세번째는 JointPoint에 삽입되어서 동작할 수 있는 코드라고 나와있다.
                    즉, 여기서 부가기능이란 공통기능을 의미하고, 실질적인 공통기능에 대해 적힌 코드 라고 봐도될듯 하다. 마지막 네번째 참조문헌에
                    보면, 여기서만 마치 공통기능을 '언제' 적용할지로 언제라는 개념으로 어드바이스를 설명하고 있지만, 그다음 160pg를 보면, 언제라는
                    의미를 담은 단어들은 따로 붙이는것으로 보아, 그냥 직관적으로 이해하기위해, 실질적인 공통기능을 구현한 코드 라고 이해하는게 맞는것같다.
                    '언제'(메서드 호출전, 메서드 호출후 ...)라는 개념은 그 단어에서 포함된다고 이해하자. 아니면, 공통기능의 구현체라고 이해해도 될것같다.
                    [참조링크 : https://shlee0882.tistory.com/206]    
                    [참조링크 : https://engkimbs.tistory.com/746]    
                    [참조링크 : https://atoz-develop.tistory.com/entry/AspectJ-Weaver%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%95%A0%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95]                  
                    [참조문헌 : 스프링5 159pg]    
                3.Joinpoint
                    첫번쨰 참조링크를보면, 어드바이스를 적용할 수 있는 위치를 말한다고 한다. 두번째 참조링크를 보아도, Advice가 적용될 수 있는
                    위치를 의미하며, 메서드 진입 지점, 생성자 호출 시점 등등이 있다. 마지막으로 세번째 참조문헌에도 Advice를 적용 가능한 지점을 의미한다고
                    나와있다. 추가로 스프링AOP에서는 메서드 조인포인트 혹은 포인트컷만 지원한다는 내용은 위에 스프링AOP에 대한 설명에 정리해 놓았다.
                    즉, 의미를 정리하자면, 말 그대로 Advice를 적용 가능한 지점이라고 생각하면 될것같다.
                    [참조링크 : https://shlee0882.tistory.com/206]    
                    [참조링크 : https://engkimbs.tistory.com/746]    
                    [참조문헌 : 스프링5 159pg]    
                4.Pointcut
                    포인트컷(Pointcut)에 대해 각기 다르게 정의해놓았는데, 그 두가지가 바로 아래 두가지다.
                    (1).첫번째는 Joinpoint의 부분 집합으로 볼 수 있는데, 실제 Advice가 적용되는 joinpoint(조인포인트)를 나타낸다고 한다.
                        첫번째 참조문헌에서 이렇게 말했다. 두번째 참조링크는, 다양한 JoinPoint(조인포인트)중에 어떤것을 사용할지 선택이라고
                        나와있다. 즉, 이런걸로 보아 Pointcut은 실제로 Advice가 적용되어 사용되는 joinpoint라고 이해하면 될것같다.
                        추가로, @Pointcut처럼 Aspect클래스에 쓰이는것이 있는데, 이러한 주석사용들에 대해서는 따로 정리하도록 하자.
                        용어와 주석에 대해서는 조금 다르게 이해할 필요가 있다.
                        [참조문헌 : 스프링159pg]    
                        [참조링크 : https://atoz-develop.tistory.com/entry/AspectJ-Weaver%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%95%A0%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95]    
                    (2).두번째 의미로는 스프링부트 시작하기 초록책에서는 포인트컷(Pointcut)이란, 어드바이스를 적용할 조인포인트를
                        선별하는 과정이나 실제 그 기능을 정의한 모듈을 의미한다고 한다. 여기서는 조인포인트를 선발한다고 했는데, 스프링 AOP는
                        메서드 조인포인트만 제공하지만, 여기서는 여러종류의 조인포인트를 제공되고, 그 중에 고른다고 여겨지는것같다. 또한,
                        조인포인트를 선별하는 과정 혹은 실제로 이 기능을 정의한 모듈을 의미하는것같다.
                        [참조문헌 : 스프링부트 시작하기 초록책 106pg]    
                    +
                    @Pointcut에 대하여
                    위에서 설명한 두번째 개념을 적용하여, 이 주석을 쓰는건, 어드바이스를 적용할 
                    조인포인트를 선별하는데 그것을 정의한 모듈 즉, 포인트컷을 설정하는데 필요한 주석이다. 설정하는 방법은
                    @Pointcut("~")
                    private void ~() {}
                    와 같이 사용하게 된다. 여기서 ~에 포인트컷을 표현할 수 있는 명시자를 넣는것이며 넣을 수 있는 명시자는 execution,within,bean등이
                    있으며, 보통 execution 명시자를 가장 많이 사용한다고 한다. 추가 내용이지만, 보통 주석에 속성값을 넣는다고 하면 내가 본것들은 전부
                    주석에 속성값을 넣는다 할 때 이 "" 큰 따옴표를 붙여서 넣어 주었었다.(이 부분 다른부분 있는 경우 그때가서 다시 정리)
                    또한, 만약 이 방법을 사용한다면, 메서드를 만들어주어서 거기에다가 주석을 적용하는건데, 이때 먼저 알아야 할것이 본래
                    포인트컷을 설정하는것은 @Around주석의 속성값에서 설정하는것으로 보인다.(다를 경우 나중에 다시보기) 아래 @Around 속성값을
                    이용하여 포인트컷을 설정하는것도 그렇고, 만약에 여기 메서드를 이용하여 @Pointcut으로 사용하는 경우에 결과적으로, @Around
                    주석에 해당 메서드를 호출해서 적용한다.(예시. @Around("메서드()"))(여기서 짚고 넘어가야 할게 있다면, 스프링부트 시작하기 초록책
                    45pg에 보면, 설정파일에서도 메서드() 이런식으로 사용하는데, 여기서는 이를 호출이라 생각했다. 앞으로 그렇게 생각해도 상관없을것
                    같다. 또한, 여기서도 이 @Around의 속성값에 @Pointcut 메서드를 적용하여 이 메서드를 실행하는것도, 실행이라고 본다. 지금까지 이
                    두 부류만 실행이라고 보긴한다. 내가 본게 이것이 다다.)
                    그래서, @Around에 따로 명시자값을 적어주지않고 @Pointcut이 적용된 메서드를 실행해주는 값을 넣게되면, 자동으로 @Pointcut 속성값의 
                    명시자가 @Around 속성값에 적용되는것으로 보인다. 즉, 기존의 메서드 실행해서 반환값주는것이랑은 조금 다른것으로 보면 된다. 또한, 해당 @Pointcut에 대한
                    메서드에 자세하게 본다면, private을 쓰는데가 있고, public을 쓰는데가 있는데, 내생각에 이거는 @Around의 속성값에서 호출하기 위함, 즉
                    같은 영역안에서 호출하게 되는거니 private이나 public이나 상관없는거 같다. 실제로 아래 참조링크를 보더라도 어디는 private 혹은 public
                    가 쓰이는것을 확인할 수 있다. 근데, 나는 왠지 private을 쓰는걸 더 선호할 것 같다. 그다음은 반환형에 대해서인데 반환형은 void를 그대로
                    전부 사용하고 있었다. 이 부분은 반환하는 값도 없고 반환하는것에대해 쓰이지도 않으니 전부 void로 해놓은것같다. 그리고 마지막으로는 메서드
                    이름인데, 이는 임의로 정해놓은것 같다. 즉, 적당히 지으면되는것 같다.
                    [직접해봄]    
                    [참조링크 : https://galid1.tistory.com/498] / 포인트컷을 설정하여 사용하는 방법 2가지
                    [참조문헌 : 스프링부트 시작하기 초록책 109pg] / 포인트컷을 표현할 수 있는 명시자에는 여러 종류가 있고 일반적으로 execution을 가장 많이 사용한다고 한다.
                    [참조문헌 : 스프링5 161pg] / private사용
                    [참조링크 : https://github.com/madvirus/spring5fs/blob/master/sp5-chap07/src/main/java/aspect/ExeTimeAspect.java] / private사용
                    [참조링크 : https://seypark.tistory.com/105] / public사용        
                    +
                    만약 @Pointcut을 쓰지 않고 포인트컷을 설정하고 싶다면, @Around의 속성값으로 바로 위의 포인트컷을 표현하는 명시자들을
                    적어주면 된다. 이는 포인트컷을 설정하는데 필요한 주석인 @Pointcut을 사용하지 않고, 포인트컷을 설정하는 방법으로 다른 예시들을
                    보았을때, @Pointcut에 들어갈 명시자 속성값을 그대로 @Around 속성값에 명시자를 적어주면 되는것같다. 여기서는 포인트컷을 설정하는
                    방법중에 어떠한 방법이 더 좋다는 나와있지 않다. 그러나 하나의 포인트컷을 여러 종류의 Advice(어드바이스)에 적용시키기 위해 따로
                    @Pointcut을 사용하여 적용하는것 같다. 아래 참조링크를 봐도 사용을 그렇게 하고 있다. 만약에 하나의 어드바이스에만 포인트컷을
                    적용하는것이라면 굳이 @Pointcut을 사용할 이유는 없어 보인다.
                    [참조링크 : https://galid1.tistory.com/498] / 포인트컷을 설정하는 또 다른 방법    
                    [참조링크 : https://velog.io/@geunwoobaek/3AOP%EB%9E%80] / @Pointcut을 사용하지 않고 @Around로 포인트컷 설정가능   
                    [참조링크 : https://owin2828.github.io/devlog/2019/12/30/spring-7.html] / @Pointcut을 사용하지 않고 @Around로 포인트컷 설정가능
                    [참조링크 : https://galid1.tistory.com/498] / @Around를 이용한 예시
                    [참조링크 : https://owin2828.github.io/devlog/2019/12/30/spring-7.html] / @Around를 이용한 예시, @Pointcut을 사용하지 않고 @Around로 포인트컷 설정가능        
                    [참조링크 : https://seypark.tistory.com/105] / @Pointcut을 사용하여, 여러 어드바이스에 적용하고 있다.
                    +
                    이 명시자에는 and와 or을 사용할 수도 있는데(&&와 ||로도 사용가능), and가 의미하는것은 적어놓은 명시자들을 모두 만족하는것만
                    포인트컷으로 지정하고 or이면 각각의 명시자들에 해당하는 것들을 모두 포인트컷으로 지정한다는 말이다. 예시의 경우는 아래의 참조문헌과
                    참조링크를 보도록 하자.
                    [참조문헌 : 스프링부트 시작하기 초록책 107pg] / or사용예시    
                    [참조문헌 : 스프링부트 시작하기 초록책 110pg] / or,and에 대한 내용   
                    [참조링크 : https://javawork.tistory.com/entry/Spring-pointcut-%ED%91%9C%ED%98%84%EC%8B%9D-2] / or,and에 대한 내용, &&, || 사용예시   
                    +
                    위에서, 다시한번 포인트컷이 무엇인지 정리하자면, 이 execution, within, bean을 포인트컷을 표현할 수 있는 명시자라고 했다.
                    즉, 이 명시자로 적은 부분들이 포인트컷으로 보면 되는것이다. 이를 첫번째 참조문헌에 정리해 놓았고(참조문헌에 보면, 포인트컷을 표현할 수 있는 명시자는
                    여러개(execution, within, bean 3개만 있는것으로 봐도 될것같다. 나중에 다를시에 다시 정리, 아무리 검색해도 이 3가지 밖에 안나왔다.)가 되는것 같지만, 
                    제일 많이 쓰이는게 execution이고 그 밖의 within, bean이 있는것으로 보인다. 아래 명시자와 관련해서는 execution은 자세하게 알아보고, within, bean은 필요한 
                    만큼만 알아볼것이다.), 실제 적용되는 프로젝트에서 포인트컷을 나타내는 다른것이 또 있는데, 바로 포인트컷의 첫번째 의미인 'Joinpoint의 부분 집합으로, 
                    실제 Advice가 적용되는 joinpoint(조인포인트)를 나타낸다.' 로 해석하게 되면, 두번째 참조문헌처럼 명시자에 의해 선택되는 메서드들이 
                    포인트컷에 해당하는거다.
                    [참조문헌 : 스프링부트 시작하기 초록책 109pg]  
                    [참조문헌 : 스프링5 161pg]          
                5.추가로 Around에 대해 정리하겠다.
                    Around 자체는 Around Advice로 쓰여서 그 의미가 핵심기능 메서드의 호출 전, 후 또는 익셉션 발생 시점이나 익셉션이 발생하더라도
                    그 시점에 공통기능을 실행하는 공통기능 구현체를 의미한다. 즉 Around Advice와 함께 쓰여지는 의미로 Advice를 기억해도 될 것 같다. 그리고 @Around
                    의 의미는 앞선 Around Advice에 해당 하는 공통기능 구현체를 작성하고 이를 적용하겠다는 의미이다. 또한, @Around 주석은 다른 기능으로도 쓰이는데, 
                    두번째는 여기의 속성값에 포인트컷 설정 명시자를 적어주어서 포인트컷을 설정하는 역활을 한다는것이다.
                    Around의 개념대로, 
                    [참조문헌 : 스프링5 160pg] / Around Advice의미    
                    [참조문헌 : 스프링부트 시작하기 초록책 109pg] / Around Advice의미
            (7).포인트컷 명시자에 관하여(execution,within,bean명시자)
                execution, within, bean은 모두 Advice를 적용할 메서드를 지정하는데 사용되는데, 즉 포인트컷을 지정하는데 사용되는건데,
                각각의 차이점들은 보면, 단순 명시자내의 형식만 다를 뿐 사용의 목적은 같다.
                1.execution 명시자
                    (1-1).접근제어자, 리턴타입, 클래스이름, 메서드이름, 파라미터를 설정하여, 해당되는 메서드를 포인트컷으로 지정
                        [참조링크 : https://maeryo88.tistory.com/200]     
                        [참조문헌 : 스프링5 168pg]    
                    (1-2).execution 명시자의 기본형식은 다음과 같다.
                        execution(수식어패턴(=접근제어자)? 리턴타입패턴 클래스이름패턴?메서드이름패턴(파라미터패턴))
                        여기서 알아야 할 것이 굉장히 많은데, 하나하나 살펴보도록 하겠다.
                        [참조문헌 : 스프링5 168pg]     
                    (1-3).우선, 수식어패턴부터 리턴타임패턴 그리고 마지막 파라미터패턴까지 모두 패턴이라는 이름을 붙여놓았다. 그러나 다른 참조링크를 보니
                        패턴이라는 말을 안써도 되는것 같기도 하다. 또한 참조링크를 또 보니, 메서드이름패턴에서 메서드를 뺀 이름패턴만 적던지, 메서드이름패턴에서
                        메서드와 패턴만 뺀 이름만 적던지 하는것도 있다. 이러한 표현법들이 모두 가능한것같다.
                        [참조문헌 : 스프링5 168pg] / 모두 패턴이라 적혀져있다.    
                        [참조링크 : https://seypark.tistory.com/105] / 모두 패턴이라 적혀져있다. + 위의 메서드이름패턴만 적혀있는곳에 이름패턴으로만 적혀져있다.
                        [참조링크 : https://icarus8050.tistory.com/8] / 팬턴빼고 적혀져 있다. + 위의 메서드이름패턴만 적혀있는곳에 이름만 적혀져있다.    
                        [참조링크 : https://velog.io/@shson/%EC%8A%A4%ED%94%84%EB%A7%81Spring-AOP-AspectJ-Pointcut-%ED%91%9C%ED%98%84%EC%8B%9D-1-1-execution] / 팬턴빼고 적혀져 있다. + 위의 메서드이름패턴만 적혀있는곳에 이름만 적혀져있다.           
                    (1-4).잘 보면, 어디는 수식어패턴혹은 수식어를 쓰고 어디는 접근제어자라 쓴다. 찾아보니, 자바 수식어라고 구글에 검색해보면 '수식어'만은
                        나오지않고, 항상 '접근수식어'만 검색이 된다. 세번째 참조링크에도 '접근수식어'라 나온경우다. 여기에서보면, 접근수식어와 접근제어자를
                        같은 의미로 쓰고있다. 즉, '수식어'만 쓰는경우 '접근수식어'로 이해하고 이를 '접근제어자'와 같은 의미로 보면 될 것 같다.(틀릴 경우 나중에
                        다시 정리하기) 또한 수식자라는것도 있는데, 이건 나중에 필요시 정리하도록 하자.
                        [참조문헌 : 스프링부트 시작하기 초록책 109pg] / 수식어패턴 아니면 수식어 말고 접근제어자라고 쓰고있다.    
                        [참조링크 : https://galid1.tistory.com/498] / 수식어패턴 아니면 수식어 말고 접근제어자라고 쓰고있다.   
                        [참조링크 : https://01092090536.tistory.com/153] / 접근수식어와 접근제어자를 혼용해서 쓰고있다.  
                    (1-5).아래 첫번쨰 참조문헌과 두번째 참조인 참조링크에는 명시자 기본 형식에서 ?를 사용함으로써 생략가능 여부를 표현했다.
                        그러나, 아래 세번째 참조인 참조링크를보면 []로 생략가능 여부를 나타내게 하기도 했다. 만약 틀린 부분이 있다면 그때가서
                        다시 정리하도록 하자. 
                        [참조문헌 : 스프링5 168pg] / ?로 생략가능 여부를 적어놓았다. 
                        [참조링크 : https://seypark.tistory.com/105] ? 로 생략가능 여부를 적어놓았다.    
                        [참조링크 : https://icarus8050.tistory.com/8] / []로 생략가능 여부를 적어놓았다.   
                    (1-6).수식어, 수식어패턴, 접근제어자부터 봐보겠다.
                        여기에는 public, protected등이 올 수 있는데, 스프링 AOP는 public 메서드에만 적용할 수 있기 때문에 사실상
                        public만 의미가 있다. 이게 무슨 말이냐면, 위에서 프록시가 생성되는 과정과 적용되는 과정을 정리한 것에서 보면 알겠지만,
                        간단하게 말하면, joinPoint.proceed()를 통해서 대상객체의 핵심기능 메서드가 실행되는데, 우선적으로 joinPoint.proceed()이니
                        Aspect클래스에서도 따로 대상객체의 핵심기능 메서드 코드가 없는걸보니, 프록시 객체에서 대상객체의 핵심기능 메서드가 실행되는게 아니라
                        ProceedingjoinPoint라는 인터페이스형 변수에 이 인터페이스의 구현체 클래스가 변수에 대입되서, 해당 변수의 메서드인 proceed()가
                        실행되기에, 적어도 이 구현체 객체에서 대상객체의 메서드가 호출되거나, 아니면 또 다른 객체에서 호출되어서 그 코드가 proceed()에
                        있는걸수도 있겠다. 확실한건 아래 스프링5 168pg 참조문헌에 보면, 스프링 AOP는 public 메서드에만 적용할 수 있따는것을 보니,
                        대상객체의 자체 내에서 메서드를 호출하는것 같지는 않다.
                        또한, ProceedingjoinPoint나 joinPoint 혹은 proceed()에 대한 내용이 책이나 참조링크 모두 상세한 설명이 없어서 이정도로만
                        이해해도 충분할것 같다.
                        [직접해봄]    
                        [참조문헌 : 스프링5 168pg] / public만 의미가 있다.
                        [참조문헌 : 스프링5 165pg] / ProceedingJoinPoint의 proceed()메서드를 호출하고나서 어딘가에서 대상객체의 핵심기능 메서드를 호출은 한다는것을 보여주고 있다.
                        +
                        위에서 이러다 보니, 수식어 수식어패턴 혹은 접근제어자를 아예 생략하는 경우나 아니면 public을 그냥 적어주는경우가 있는데,
                        참조링크나 참조문헌을 봐도 적어주기도하고 public만 적어주기도 하니, 내키는대로 그때마다 정해주면 될것같다. 또한, 적어주는것
                        여부에 따른 차이도 검색해보니 없는것으로 보인다. 
                        [참조문헌 : 스프링5 168~169pg]    
                        [참조문헌 : 스프링부트 시작하기 초록책 107pg]    
                        [참조링크 : https://galid1.tistory.com/498]    
                        [참조링크 : https://maeryo88.tistory.com/200]     
                    (1-7).그 다음은 리턴타입에 관해서다.
                        리턴타입은 반드시 명시해주어야 하는것으로, 메서드의 해당 리턴타입에 해당하는것만을 지정하게
                        해주는것이다. *는 모든 리턴타입이 가능하다는것이고, void는 말 그대로 void 리턴타입만 설정한다는
                        것이다. 추가로 알아야할 것은 아래에 모든 예시들중에 void만 소문자로 적고 나머지 Integer와 String
                        그리고 Long에 대해서는 모두 대문자로 적어주었다. 이 부분에 대해서 인지하고 넘어가자.
                        그리고 나중에 내가 쓸때는 문제가 될시에 다시 정리하도록 하자.
                        [참조문헌 : 스프링5 168pg] / 리턴타입은 반드시 명시 & *,void,Long을쓰는 예시    
                        [참조링크 : https://velog.io/@shson/%EC%8A%A4%ED%94%84%EB%A7%81Spring-AOP-AspectJ-Pointcut-%ED%91%9C%ED%98%84%EC%8B%9D-1-1-execution] / 리턴타입 String
                        [참조링크 : https://icarus8050.tistory.com/8] / Integer 리턴타입 
                        [참조링크 : https://sjh836.tistory.com/157] / *,void에 대한 설명  
                    (1-8).그 다음은 클래스 이름과 메서드이름에 관해서다.
                        이 부분에 대해서는 클래스이름과 메서드이름에 대해서 함께 설명하는게 좋을 것 같다.
                        1.클래스 이름
                            클래스 이름 혹은 인터페이스이름은 생략할 수 도 있는데, 쓰게 된다면 다음과 같다. 여러가지가 있는데, 구분지어놓지 않고
                            바로 설명하도록 하겠다. 클래스명의 규칙은 정확하게 클래스명만 적어주거나, *클래스명, *와 같이 3가지로 표현이 가능하다.
                            해당 자세한 내용들은 아래 참조링크를 참조하도록 하자(*에 대해서는 아래 공통사항에서 보겠다.) 그 다음 클래스명 말고, 패키지 
                            경로에서는(사실 이걸 클래스 이름이라고 한번에 보는게 맞지만) .. 으로 해당 디렉토리의 하위 모드 패키지를 선택한다. 즉, 추가로 설명하자면, 
                            io.icednut.spring.exercise.. 와 같이 쓴다면, io.icednut.spring.exercise로 시작하는 모든 패키지를 선택한다는 뜻이다.
                            [직접해봄] / 인터페이스명, 구현체 클래스명 모두 다 적용이 됬었다.
                            [참조링크 : https://sjh836.tistory.com/157] / 클래스명, *클래스명에 대한 설명    
                            [참조링크 : http://closer27.github.io/backend/2017/08/03/spring-aop/] / 패키지 경로의 ..에 관하여 & *클래스명에 관하여    
                            +
                            클래스 이름은 반드시 풀 패키지명으로 입력해야 한다고 나와있다. 내가 직접해봤을때도, 전부 풀패키지명을
                            적어주지 않으면 제대로 정상작동하지 않았었다. 스프링5책이나 스프링부트 시작하기 초록책에도 전부 풀패키지명을
                            적어주었었다. 이 부분중에 틀린경우가 있다면 나중에 다시 정리하도록 하자.
                            [직접해봄]    
                            [참조링크 : https://icarus8050.tistory.com/8]      
                        2.메서드 이름
                            메서드 이름은 반드시 적어야하는 값이다. 메서드의 값은 *, 메서드명, 메서드명*와 같이 3가지로 나눠서 볼 수 있다.
                            클래스 이름은 안적더라도, 메서드이름은 위의 3가지중에 반드시 하나는 적어주어야 한다.
                            [참조링크 : https://sjh836.tistory.com/157] / 메서드 표현식 *와 메서드명*에 대하여   
                            [참조링크 : http://closer27.github.io/backend/2017/08/03/spring-aop/] / 메서드 표현식 *와 메서드명*에 대하여      
                            [참조문헌 : 스프링5 169pg] / *, 메서드명*, 메서드명의 예시   
                        [공통이해]
                            예시들을 들면서, 공통내용에 대해 알아보도록 하겠다.
                            (1).execution(* com.java.ex.Car.accelerate())의 경우
                                여기서 보면, 패키지명 적다가 갑자기 대문자가 나온다. 이 경우에는 패키지명이 아닌 클래스나
                                인터페이스 파일명으로 볼 수 있다. 그리고 그다음 바로 메서드에 대한 얘기가 나오면된다.
                                여기서 추가로 얘기하자면, 이 대문자가 나오는거에서 구현체 클래스가 올 수도 있고, 아니면
                                구현체 클래스가 올 수도 있다.
                                [직접해봄]    
                                [참조링크 : https://galid1.tistory.com/498]    
                                +
                                추가로, 직접해본것들인데 만약 이 명시자로 지정한것중에 인터페이스의 메서드를 지정하면 해당 인터페이스형 변수이면서 구현체 클래스를 가리키는
                                변수명에 해당하는 객체를 호출할때는, 모두다 프록시 객체를 사용하여 나타낸다. 아니면 인터페이스와 이를 구현한 구현체 클래스의 메서드를 한꺼번에 포인트컷으로
                                지정하더라도 똑같이 해당 인터페이스형 변수이면서 구현체 클래스를 가리키는 변수명에 해당하는 객체를 호출할때 모두다 프록시 객체를 사용하여 나타냈었다.
                                만약에 특정 인터페이스를 구현한 구현체 클래스의 메서드를 포인트컷으로 지정하는데, 다른 구현체 클래스의 메서드는 지정하지 않고 한 구현체 클래스의 메서드만
                                포인트컷으로 지정하면 인터페이스형 변수이면서 구현체 클래스를 가리키는 변수를 호출할때 이 포인트컷으로 지정한 구현체 클래스만 프록시 객체를 호출하고 나머지
                                구현체 클래스는 프록시 객체를 호출하지 않는다. 이건동적프록시를 직접해본거다. 
                                [직접해봄]    
                                +
                                CGLIB의 경우는 클래스 혹은 구현체 클래스를 선택하면 당연히 프록시 객체가 생성이 된다. 좀 더 구체적인 직접 해본 예시를 들자면,
                                컨트롤러같은 일반 클래스에 적용시 CGLIB으로 인해 프록시 객체가 생성되고, 구현체 클래스를 포인트컷으로 지정했을 경우에, 당연히 구현체 클래스더라도,
                                구현체 클래스형인 변수나 아니면 빈(이 경우 해당 구현체 빈이 1개만 있다고 생각하자.)을 사용할 경우 일반 클래스방식과 똑같이 CGLIB이 적용이 된다. 또한,
                                만약 인터페이스형 변수에 해당 구현체 클래스 객체가 바인딩되는 상황이더라도, 내부적으로 이미 이 인터페이스형이면서 구현체 클래스 반환하는 빈 객체 설정에서(구현체 클래스
                                @Component시 자동으로 적용되는 설정으로 본다.) 구현체 클래스 대신 이 CGLIB프록시 객체를 넣어 인터페이스형으로 자동 형변환되어 반환하는것으로 보인다.
                                즉, 인터페이스 구현체 클래스의 메서드를 포인트컷으로 지정하면 기존의 구현체 클래스형만의 빈과 인터페이스형이면서 해당 구현체 클래스 반환하는 빈의 설정이
                                둘다 바뀌는것으로 보고 있다. 그리고 만약 인터페이스의 메서드를 포인트컷으로 지정한 경우에도 직접해봤는데, 이 경우에는 위에서 인터페이스형 구현체 클래스의 메서드를
                                포인트컷으로 설정해주어서 해당 구현체 빈과 인터페이스형이면서 구현체 자동형변환된 빈 설정 둘다에 CGLIB 설정을 적용 했는데 이 또한 똑같이 적용되는것 같다. 다만,
                                해당 인터페이스를 구현한 구현체의 설정한 메서드 모두에 포인트컷이 적용되는것같다.(하나의 구현체는 해봤는데, 스프링부트 시작하기 초록책 107pg의 boardService인터페이스에
                                해보고, private final boardService boardServiceImpl로 직접해봄 그 외의 구현체는 안해봄 하지만 그런것 같다. 이 부분 나중에 틀리면 다시보기) 또한, 직접 
                                private final boardServiceImpl boardServiceImpl로 구현체 클래스형만으로도 했는데 정상작동했다. 즉, 확인시에 CGLIB 프록시 객체로 확인되었다는 말이다.
                                확인해봤었다. 마지막으로, 인터페이스와 해당 인터페이스 구현체의 메서드를 모두 한꺼번에 포인트컷으로 지정해도, 구현체 클래스형 변수나, 인터페이스형이며 구현체
                                객체 자동형변환 변수 모두 정상작동했었다. 즉, 중복으로 이렇게 적용해도 괜찮은것같다. 
                                [직접해봄]    
                                [참조링크 : 스프링부트 시작하기 초록책 107pg]
                                +
                                바로 위의 추가사항인데 내가 어느 참조문헌인가 참조링크에서 인터페이스의 구현체를 상속받은 클래스도 해당 인터페이스형으로
                                자동 형변환이 가능하다고 했다. 근데 찾을 수가 없어서 직접해봤더니 실제로 됬었다. 스프링 프로젝트에서 빈 설정에 반환형을 인터페이스형으로
                                하고, 반환되는 객체를 해당 상속받은 객체로 한다음 ctx로 인터페이스형으로 빈을 받았는데 정상적으로 작동했고, 실제로 getClass와 getName으로
                                확인해보니 이 상속받은 클래스였다.
                                [직접해봄]    
                            (2).execution(* com.java..*.*())의 경우
                                이거는 com.java의 패키지명의 하위 모든 패키지에 해당하며 ..*에서 이 *는 모든 클래스혹은 인터페이스를 뜻하는 말이다.
                                그리고 나서 .*라고 적혀져 있는 부분은 모든 메서드를 뜻한다.
                                [참조링크 : https://galid1.tistory.com/498]    
                            (3).execution(public * chap07..*(..))의 경우
                                보통, 다른데 보면 패키지명을 적어준경우 클래스나 인터페이스명까지 적어주어야 하는것이 기본이다. 그러나,
                                위의 예시처럼 chap07..*으로 chap07 하위패키지에 속하면서 모든 클래스의 모든 메서드를 의미하기도 한다. 즉, 원래는
                                execution(public * chap07..*.*(..))이 맞는건데 위의 경우도 정상적으로 작동했었다. 직접해봤다. 또한, 스프링부트 시작하기
                                초록책의 예시를 보면, execution(* board..select*(*))에서도 해설에 board 패키지의 모든 하위 패키지에 있으며 select로 시작하는
                                메서드라고 말하고 있다. 즉, 이 패키지명을 적을때 .. 적는거에서는 이러한 예외도 가능한가보다.
                                [직접해봄]    
                                [참조문헌 : 스프링5 168pg]    
                                [참조링크 : 스프링부트 시작하기 110pg]    
                    (1-9).파라미터 혹은 파라미터 패턴에 대해 보겠다.
                        파라미터팬터에 주로 쓰이는 문자는 *와 ..로 알고있다.(그 외에도 있지만 그건 필요시 나중에 다시 정리하도록 하자.) *의 의미는 모든 값을 표현하고, 
                        ..를 쓸경우 0개 이상을 의미한다. 즉, 정리하자면 파라미터에 ..만 쓴다면 0개 이상의 파라미터 즉, 모든 파라미터를 뜻하며, (*)이면 1개의 파라미터
                        (*,*)이면 두개의 파라미터가 쓰이는 메서드를 뜻한다. 즉, 이렇게 파라미터 개수를 조절할 수도 있꼬 만약에 ()처럼 아무것도 적어주지않는다면, 어떠한
                        파라미터도 없는 메서드를 의미한다. 각종 예씨들은 아래 참조링크에 적어놓았다.
                        [참조링크 : https://icarus8050.tistory.com/8] / *와 ..에 관하여
                        [참조링크 : https://sjh836.tistory.com/157] / *와 ..에 관하여    
                        [참조링크 : https://galid1.tistory.com/498] / 아무것도 안쓰면 파라미터가 없는 메서드를 의미한다.    
                        [참조링크 : https://icarus8050.tistory.com/8] / 각종 예시들
                2.within 명시자
                    (2-1).특정 패키지의 클래스 혹은 인터페이스를 설정하여, 해당 되는 클래스 혹은 인터페이스의 모든 메서드를 포인트컷으로 지정한다.
                        이때 패키지명도 다 적어준다. 즉, 결과적으로 패키지명과 클래스명 혹은 인터페이스명을 적어주어서 해당하는것의 모든 메서드를
                        포인트컷으로 지정한다.
                        [참조링크 : https://maeryo88.tistory.com/200]    
                        [참조링크 : https://galid1.tistory.com/498]    
                    (2-2).within 명시자의 기본형식은 다음과 같다.
                        within(클래스or인터페이스 경로) 
                        또한, 이때도 모든 패키지명을 다 적어주어야 하는것으로 알고있다.
                        [참조링크 : https://galid1.tistory.com/498] / 기본형식이 나와있다.   
                        [참조링크 : https://maeryo88.tistory.com/200] / 기본형식이 나와있지 않지만, 모든 예시가 이와같이 적혀져있다.
                        [참조링크 : https://icarus8050.tistory.com/8] / 기본형식이 나와있지 않지만, 모든 예시가 이와같이 적혀져있다.  
                    (2-3).확인은 안해봤지만, execution명시자 처럼, within명시자도 클래스명을 넣어줄때 인터페이스명도 입력가능하고, 클래스명이 적용되는방식이
                        execution과 같을것으로 보고있다. 만약 다르다면 그때 다시 정리하도록 하자.
                        [직접해봄]    
                    (2-4).예시들을 살펴보겠다.
                        (1).within(com.java.ex.*)인 경우
                            이 경우 com.java.ex 하위의 모든 클래스의 모든 메서드를 적용하겠다는 의미이다.
                            [참조링크 : https://galid1.tistory.com/498]    
                        (2).within(com.java.ex..*)인 경우
                            이 경우 com.java.ex 패키지의 하위 패키지를 포함해 모든 클래스의 모든 메서드를 적용하겠다는 의미이다.
                            [참조링크 : https://galid1.tistory.com/498]    
                        (3).within(com.java.ex.Car)인 경우
                            이 경우 com.java.ex 패키지의 Car 클래스 혹은 인터페이스의 모든 메서드에 적용하겠다는 의미이다.
                            [참조링크 : https://galid1.tistory.com/498]    
                        (4).within(board.service.*ServiceImpl)인 경우
                            이 경우 board.service 패키지 밑에 있는 ServiceImpl이라는 이름으로 끝나는 클래스 혹은 인터페이스의 모든 메서드에 적용하겠다는 의미이다.
                            [참조문헌 : 스프링부트 시작하기 초록책 111pg]        
                3.bean 명시자
                    (3-1).빈 이름을 설정하여, 해당 빈의 모든 메서드를 포인트컷으로 지정
                        즉, 패키지명이나 메서드 등은 쓰지않고, 오직 빈 이름만 적어주어서 해당 빈의 모든
                        메서드를 포인트컷으로 지정하게 된다. 희안한건 '빈이름' 이라고 말한다는거다.
                        [참조링크 : https://maeryo88.tistory.com/200]    
                        [참조링크 : https://galid1.tistory.com/498]    
                    (3-2).bean 명시자의 기본형식은 다음과 같다.
                        bean(빈 이름)
                        [참조링크 : https://galid1.tistory.com/498]    
                        [참조링크 : https://maeryo88.tistory.com/200] / 기본형식이 나와있지 않지만, 모든 예시가 이와같이 적혀져있다.
                        [참조링크 : https://icarus8050.tistory.com/8] / 기본형식이 나와있지 않지만, 모든 예시가 이와같이 적혀져있다.   
                    (3-3).희안한것은 클래스나 인터페이스명이 아니라 빈이름이라고 말하고있으니,
                        빈이름의 경우 첫글자가 소문자이다. 그러기에 전부 첫글자가 소문자이고 within의 경우
                        클래스명 혹은 인터페이스명이니 모두 대문자로 시작한다. 이 부분 인지만 하자.
                        [참조문헌 : 스프링부트 시작하기 초록책 111pg] / 여기서도 within은 첫글자 대문자, bean의 경우 첫글자 소문자다.    
                        [참조링크 : https://maeryo88.tistory.com/200] / bean의 경우 첫글자 소문자 & within의 경우 첫글자 대문자
                        [참조링크 : https://galid1.tistory.com/498] / bean의 경우 첫글자 소문자 & within의 경우 첫글자 대문자
                    (3-4).예시들을 살펴보겠다.
                        (1).bean(car)인 경우
                            이 경우, car라는 빈의 이름을 갖고있는 빈의 모든 메서드에 포인트컷을 적용한다는 의미이다.
                            [참조링크 : https://galid1.tistory.com/498]     
                        (2).bean(boardServiceImpl)인 경우
                            이 경우, boardServiceImpl이라는 이름을 가진 빈의 모든 메서드에 포인트컷을 적용한다는 의미이다.
                            [참조문헌 : 스프링부트 시작하기 초록책 111pg]    
                        (3).bean(*ServiceImpl)인 경우
                            이 경우, ServiceImpl이라는 이름으로 끝나는 빈의 모든 메서드에 포인트컷을 적용한다는 의미이다.
                            [참조링크 : 스프링부트 시작하기 초록책 111pg]        
                        (4).bean(some*)인 경우
                            이 경우, some이라는 이름으로 시작하는 빈의 모든 메서드에 포인트컷을 적용한다는 의미이다. 이거는 보통
                            *명 으로만 사용되었던거같은데 클래스명 적는 방식에서 빈에서는 이러한 예시가 있다. 이 부분은 내가 직접 검증해보지
                            못했지만, 나중에 사용하게 된다면 다시 정리해보자.
                            [참조링크 : https://icarus8050.tistory.com/8]                                             
            (8).ProceedingJoinPoint 그리고 Signature에 대한 정리
                1.
                    [참조링크 : ]    
                2.
                    [참조링크 : ]                
.
.
.
    [추가사항]
        1.분명, @Component와 @ComponentScan과 같은 방법으로 설정파일에 등록하고 빈을 만들어 내는경우 @Component가 붙은 클래스의 명에서 첫번째 글자만
            소문자로 바꾼게, 빈의 이름이 된다고 했었다. 그런데, 직접 해본것중에 예외가 있었던게 바로 첫번째, 두번째 글자가 모두 대문자인 경우에는 이 @Component와
            @ComponentScan을 사용하여 빈이 등록됬는데도 첫번째 글자가 소문자로 바뀌지 않고 그대로 대문자로 빈 이름이 등록됬었다.(실제로, ctx.getBean("빈이름",~)으로
            빈 이름에 첫글짜 소문자 넣었더니 안되고 대문자 넣었더니 됬다.) 즉, 이렇게 연속으로 앞글자 그리고 두번째 글자가 대문자이면 첫번째 글자를 대문자로
            빈을 등록하나 보다. 나는 TTest1.class, TTest2.class 이렇게 두개 클래스로 해봤었다.
            [직접해봄]   
            [참조문헌 : 스프링5 132pg]   
        2.위의 .getClass()메서드 내용과 관련된 .getName() 메서드에 대해서도 더 자세하게 보겠다.
            (2-1).우선 getClass()에 대해 보겠다.
                1.우선, getClass()메서드는 모든 클래스의 최상위 클래스 Object 클래스의 메서드이다. 즉, 모든 클래스는 getClass()를 기본적으로 갖고있다.
                    (따로, 오버라이딩 하지않는이상 그 기능 그대로 간다.)
                    [참조문헌 : 자바 책 352 ~ 353pg]   
                2.여기서 .getClass()메서드의 기능은 객체의 Class 클래스를 반환한다는건데, 그 의미는 Class형의 인스턴스를 값으로 반환하는데, 이 Class형의 인스턴스는
                    해당 getClass()메서드를 사용한 인스턴스에 해당하는 클래스나 인터페이스의 class파일에 저장된 정보를 갖고오는것이다.
                    [참조문헌 : 자바 책 378pg ]   
                3.추가로 클래스나 인터페이스 둘다 컴파일이 되고 나면, .class라는 class파일로 생성이 된다고 한다.
                    [참조문헌 : 자바 책 378pg]   
                    [참조링크 : https://jang-sn.tistory.com/55]    
                    [참조링크 : https://gbs1995.tistory.com/15]    
            (2-2).getName()메서드에 대해 알아보겠다.
                1.이 getName()메서드는 Class형의 클래스의 메서드이다. 즉, Class형 인스턴스만 쓸 수 있는것이며 이것이 적용될 수 있는 이유는,
                    애초에, Class형의 클래스가 존재하고 어떤 인스턴스에 .getClass()를 사용하게 되면, 해당 인스턴스에 해당하는 .class 파일에서
                    정보를 모두 긁어 갖고와 Class형 인스턴스로 갖고오는것같다. 그리고 해당 Class형 인스턴스에 .getName() 메서드를
                    사용하게 된다면, 저장되었던 정보중 하나를 갖고오는거다.
                    [참조문헌 : 자바책 378pg]    
                2.getName()메서드는 해당 클래스의 이름을 값으로 제공한다. 근데, 여기서 보면 해당 메서드를 직접사용하면
                    패키지명과함꼐 해당파일명도 다 함께 제공한다는것을 알 수 있다. 이는 일반 클래스형이나 아니면 구현체 형인데
                    자동형변환된 인스턴스에 사용하건 상관없이 다 같았다.
                    [직접해봄]    
                    [참조링크 : https://ifuwanna.tistory.com/282] / 패키지명이 포함된 파일명 반환   
                    [참조링크 : https://woochan-autobiography.tistory.com/222]   
                    [참조링크 : https://zzdd1558.tistory.com/57]   
                    +
                    getSimpleName()이란 메서드가 있는데, 이를 사용하게 되면 패키지명은 안뜨고, 해당 .class의 파일명만
                    뜨게 된다.
                    [직접해봄]   
                    [참조링크 : https://ifuwanna.tistory.com/282]   
                3.그럼, 당연히 일반 클래스의 경우(상속은 안해봤다.)에는 패키지명과 해당 클래스명이 함꼐 뜨고, 인터페이스형으로 자동형변환된
                    구현체 인스턴스에 getCLass().getName()을 사용해보니, 해당 구현체 클래스의 패키지명과 클래스명이 떳었다. 즉, 애초에 인터페이스형으로
                    자동형변환된 구현체 인스턴스(자동형변환된 인스턴스가 대입된 인터페이스형 변수에 사용했었다.)에서 .getClass()를 사용하게되면,
                    구현체의 .class파일에서 정보들을 갖고와 Class형 인스턴스에 저장하는것 같다. (또한, 여기서는 ctx.getBean을 이용해서 빈으로 직접
                    해본것인데, 별 문제없을것으로 보인다.)
                    [직접해봄]    
            (2-3).위에서 보면, 예시들에 보면, ~.getClass().getName()와 같이 쓰이는게 보인다. 
                자바에서, 애초에, ~.getClass()를 하고 해당 Class형 인스턴스로 바로 적용이 되어서 Class형의 메서드인
                getName()을 사용할 수 있게 해놓은것 같다. 만약 이와 비슷하거나 다른 경우 더 자세히 알아야할 필요가 있다면
                그때 더 자세히 정리하도록 하자. 직접해봤을때, 클래스 빈이나 자동형변환된 구현체 빈 모두 사용가능했었다.
                [직접해봄]        
                +
                아래 참조문헌을 보니, ~getClass().getSimpleName()도 되는걸 보니, 애초에 getClass()를 쓰고 Class형 관련
                메서드들을 이어서 쓸 수 있는것 같다. 아래 참조링크는, 인터페이스형 변수였고 구현체의 자동형변환된 인스턴스가
                들어간것이 작동하는것이다. 만약 추가로 알아야할 사항이 있다면 그때 다시 봐보자.
                [참조문헌 : 스프링5 155pg]    
.
.
.