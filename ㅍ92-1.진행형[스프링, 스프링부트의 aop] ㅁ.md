.
.
.
1.AOP의 핵심 기능에 공통 기능을 삽입하는 3가지 방법과 그 중에 사용할 방법에 대해 알아보겠다.
    1.컴파일 시점에 코드에 공통 기능을 삽입하는 방법
        1-1.컴파일 하기 직전에 공통 기능을 삽입하는것이다.
            [참조링크 : https://niklasjang.github.io/spring/spring-aop/] / 컴파일 전에 공통기능 삽입   
    2.클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법
        2-1.클래스 로딩 시점 즉, 클래스 로더가 JVM의 메모리에 class파일을 올릴때 바이트 코드에 공통 기능을 삽입하는것이다.
            [참조링크 : https://niklasjang.github.io/spring/spring-aop/]    
    3.런타임에 프록시 객체를 생성해서 공통 기능을 삽입하는 방법
        3-1.런타임 즉, main함수가 실행되고 JVM에서 해당 바이트코드들을 실행하며, 인스턴스 혹은 빈객체를 생성하고 등록할때
            프록시 객체를 생성해서 공통 기능을 삽입한다는 것이다.(여기 부분 혹시 틀린부분 있으면 나중에 자세히 보기)
            [참조링크 : https://niklasjang.github.io/spring/spring-aop/]   
    [추가사항]    
        1.작성한 자바소스 파일이 어떻게 사용되어지고 그 중간중간 과정에서의 의미있는 용어들이나 부분에 대해 보겠다.
            1-1.우선, 작성한 자바소스는 즉, 확장자가 .java인 파일을 자바 컴파일러를 통해 자바 바이트코드로 컴파일 한다.
                [참조링크 : https://steady-snail.tistory.com/67]   
                [참조링크 : https://tjdrnr05571.tistory.com/19]    
            1-2.컴파일된 바이트코드를 JVM(자바 가상 머신)의 클래스로더에게 전달하며, 그리고나서 클래스 로더가 클래스(바이트코드)
                를 JVM내의 Runtime Data Area 즉, JVM의 메모리에 올린다. 이 클래스로더가 JVM내에 클래스를 올리는것을 클래스 로딩이라 한다.
                [참조링크 : https://tjdrnr05571.tistory.com/19]    
                [참조링크 : https://steady-snail.tistory.com/67]    
                [참조링크 : https://gbsb.tistory.com/2]    
                [참조링크 : https://taes-k.github.io/2019/07/16/java-class-loading/] / 클래스 로딩   
            1-3.아래 참조링크를 보면, 컴파일 과정을 마친 응용 프로그램이 사용자에 의해서 실행되어지는 '때'가 바로
                런타임이라고 한다. 근데 두번째 참조링크를 보면, 이 main함수가 실행될때를 런타임의 시작이라고 보며 세번째 네번째
                참조링크를 참조하여, 이 main함수가 실행되는것을 다른말로 JVM메모리에 올라온 바이트 코드들을 실행한다 라고 볼 수 있을것 같다.
                만약 더 자세하게 봐야하거나, 고쳐야 할 것이 있다면 다시 봐보도록 하자.
                [참조링크 : https://dd-corp.tistory.com/9] / 실행되어지는 때를 런타임
                [참조링크 : https://taes-k.github.io/2019/07/16/java-class-loading/] / main함수를 동작시키는 중에 class를 로드할때 런타임 로드라 하는것보니, main함수를 동작시키고나서를 런타임의 상황이라고 볼 수 있을것같다.(틀리거나 더 정확하게 봐야한다면 다시보기) 
                [참조링크 : https://steady-snail.tistory.com/67] / JVM메모리에 올라온 바이트 코드들을 실행     
                [참조링크 : https://gbsb.tistory.com/2] / JVM메모리에 올라온 바이트 코드들을 실행 + 그 외 기타내용 
                [참조링크 : https://gbsb.tistory.com/2] / JVM이 바이트코드를 해석하여 자바 프로그램이 실행
            [추가사항]   
                자바에서 인스턴스 생성(new 생성자)이나 스프링이나 스프링부트에서 빈 객체를 생성하는것 모두 런타임에서 하는
                것이다.
                [참조문헌 : 스프링5 47pg] / 여기보면, 런타임시에 자바 설정에서 정보를 읽어와 빈 객체를 생성하고 관리한다.
        2.JRE 그리고 JVM / 자바 소스코드와 자바 컴파일러 그리고 바이트코드
            2-1.JRE와 JVM의 관계를 정리하자면, JRE는 JVM이 자바프로그램을 실행시킬 때 필요한 라이브러리들과
                기타 등등 파일을 가지고 있다고 한다. 즉, JRE는 JVM의 실행환경을 구현한것이다. 그러기에 아래 참조
                문헌에 보면 JRE가 설치되어있으면, JVM이 설치되어있는것이라고 한다.
                [참조링크 : https://dohwankim.tistory.com/35]   
                [참조문헌 : 자바 21pg]   
            2-2.자바 소스코드(.java파일)는 자바 컴파일러에 의해 바이트 코드(.class파일)로 바뀌고 이 바이트 코드들은 리눅스나 윈도우의
                JVM에서 실행이 되는것이다. 이때 바이트 코드는, 운영체제에 맞는 완벽한 기계어가 아닌 중간 기계어 이며, 자바 가상 머신이
                운영체제에 맞는 완벽한 기계어로 바꿔주게 되어 실행이 되는거다.
                [참조문헌 : 자바 21pg]   
.
.
.
2.인터페이스형과 구현체형 사이에서의 알아야할 지식들 정리
    1.인터페이스와 설정파일, @Component의 빈 생성과 빈 주입에 관하여
        1-1.인터페이스형 반환형의 메서드에서, 반환되는 값이 구현체형 인스턴스이거나, 아니면 반환되는 값이 인터페이스형으로 형변환된 구현체형인것에
            차이가 있냐는것이다. 원래는 이전까지는 인터페이스형 반환형 메서드에서 구현체 인스턴스가 인터페이스형으로 형변환되어서 인터페이스형 변수로
            값이 반환되었을때는, 당연히 그냥 형변환된 구현체 인스턴스가 인터페이스형 변수로 반환됬다고 봤는데, 다른 그저 구현체 인스턴스만 반환됬을때는
            어떨지 몰랐다. 그런데, 직접 구현체 인스턴스만 반환된 경우,(해당 메서드의 반환형은 인터페이스형) 이 경우는 해당 구현체형의 인스턴스가 인터페이스형으로
            형변환된 후에 나오게 된다. 직접 설정파일에 각각 인터페이스형 반환형 메서드에 한개는 구현체 인스턴스만 반환하고 다른 하나는 인터페이스형 변수에 구현체형
            인스턴스를 대입하여 자동형변환을 시킨후 해당 인터페이스형 변수를 반환했다. 그리고 나서 각각 ctx.getBean("빈 이름",인터페이스.class) 으로 해당 빈 객체를
            갖고온다음에, 인터페이스형 변수에 넣으니 잘 들어갔다. 그러나 각각(이때 인터페이스형은 Test였고, 하나 구현체는 Test1, 다른 하나 구현체는 Test2이였다.), ctx.getBean
            으로 반환되는 빈을 각각 구현체 Test1형의 변수와 구현체 Test2형의 변수에 넣으려고 하니 형이 맞지 않다고 각자 오류가 났었다. 또한, 아래 정리에 추가로 getClass,getName
            메서드를 사용한것에 대해 정리했다.
            또한,
            getClass()를 사용했을때 해당 클래스 정보를 담긴 Class 형 객체를 반환하게 되는데, 인터페이스형으로 자동형변환된 인터페이스형 변수에 쓰거나
            아니면, 그냥 구현체형의 인스턴스인데 인터페이스형으로 자동형변환되고 인터페이스형의 변수가 가리키고 있지않은 상태의 인스턴스자체에 getClass()를
            쓰거나, 둘다 .getClass()로 받아오는 클래스 정보는 모두 구현체형의 클래스 정보를 받아왔었다. 직접 둘다 해보고 getName()으로 확인까지 했었다. 
            [직접해봄]   
            [참조링크 : https://woochan-autobiography.tistory.com/222] / .getClass()사용시 Class형 객체 반환(Class형 인스턴스반환으로 봐도될듯) 
            [정리]    
            즉, 정리하자면, 애초에, 
                1.인터페이스를 구현한 구현체의 경우, 자동형변환이 이루어지면 구현체 인스턴스의 형 자체가 변하는것이다. 
                2.인터페이스형 반환형 메서드에서 구현체 인스턴스 자체를 반환하면 형변환된 구현체 인스턴스가 반환되고, 
                    인터페이스형 변수에 형변환하여 해당 변수를 반환하면 형변환된 인터페이스형 변수가 반환되는거다.
                3.인터페이스형으로 형변환된 구현체인스턴스를 가리키는 변수에다 쓰던, 아니면 ctx.getBean(~)으로 직접(여기에다 직접 메서드씀) 
                    자동형변환된 구현체 인스턴스를 쓰던지, (여기서, 이 ctx.getBean으로 갖고온것은 설정파일에서 인터페이스 반환형 메서드에서 구현체 인스턴스 자체만 반환한거를 쓴거다.) 어느것이든
                    getClass().getName()으로 하면, 해당 구현체 클래스의 패키지명과 클래스명이 떳었다.
            [직접해봄]   
        1-2.구현체형이 인터페이스형으로 형변환이 이루어지면, 단순히 구현체 인스턴스의 주소값을 인터페이스형 변수가 가르키는것 외에도 애초에
            구현체 인스턴스 자체가 형변환이 일어나게 된다. 아 그러면, 여태 단순히 인터페이스형의 변수에 의해 해당 인터페이스형의 멤버변수나 메서드를 이용할
            수 있었던게 아니라, 구현체같은 인스턴스 자체가 형변환을 일으켜서 그런게 가능했고, 형변환을 했기에 그걸 인터페이스형 변수가 가리킬 수 있었던 거다.
            위에보면 왜 그런지 자세히 알 수 있다.
            [직접해봄]   
            [참조문헌 : 자바책 319pg]    
        1-3.위의 내용들에서, 설정 파일에서 메서드의 반환형이 인터페이스형이고 여기서 구현체 클래스의 인스턴스만 반환하던, 아니면
            구현체 클래스의 인스턴스를 인터페이스형 변수로 가리켜서 그 인터페이스형 변수를 반환하던지, 이는 main함수가 있는 클래스에서
            ctx.getBean("메서드명",인터페이스형.class)으로 이것들을 각각 둘다 빈값을 갖고오게 했는데, 둘다 어느 하나도 구현체 클래스를 import
            할 필요가 없었다.(필요하면 import해야하는 상황이였음) 또한, 이는 일반 자바에서 방금한것과 같이 똑같이 일반 인터페이스형 반환 메서드에
            사용했어도 똑같은 결과가 나올것이다. 만약 다르다면 나중에 다시 정리하자. 그러나 같을것이다.
            [직접해봄]   
        1-4.위의 1.3과 같이 인터페이스형 변수(service같은거)에 @Autowired나 생성자 주입으로 구현체 빈을 주입하는 경우에도 import문이 필요하지 않았었다. 
            직접 예를 들은것은 @Controller에서 Service인터페이스형에 관해서이며, 근데 이 경우는 일종의 구현체가 인터페이스형 변수에 대입되는거로 자동형변환이
            일어나는것으로 보이는데 위의 1.3에서 import문이 필요없었던거랑은 조금 다른것으로 보인다. 아마 내부적으로 처리하는것으로 이 또한 import문이 
            필요하지 않다는것을 알았다.(설정파일에서 파라미터로 자동주입하는것은 필요한지 안필요한지는 나중에 알아봐야할때 알아보자. 또한, 다른것들도.)
            [직접해봄]   
        1-5.직접해봤더니, 인터페이스형 변수에 생성자주입이나 @Autowired를 쓰게되면 알아서 구현체의 빈이 주입이 된다. 이는 구현체가 하나밖에 없는경우
            인터페이스형의 변수명이 아무거나 되도 구현체 빈이 주입이 되고, 만약에 여러개인 경우에는 해당 구현체의 빈의 이름을 인터페이스형 변수명으로 해서
            어떤 구현체를 주입할지 알려주어야 한다. 그렇지않으면 어떤 구현체 빈을 주입할지 몰라서 예외를 발생시키며, 이는 @Controller에서 서비스 인터페이스로도
            해본거지만, 직접 스프링에서 따로 인터페이스와 구현체 빈을 이용해서 해본 결과다. 찾아보니까, 이는 일반 클래스파일의 타입형 빈이 싱글톤이 아닐경우,
            변수명으로 같은 '형'의 빈을 주입하는 방법말고도 @Qualifier와 @Component, @Service등에 한정자를 추가로 적용해주는 방법이 있다. 이를 인터페이스형
            변수에도 똑같이 적용하는것이 있는데, 이 방법도 있고 다른 방법도 있는것같은데 이는 나중에 필요할시 다시 봐보도록 하겠다.
            [직접해봄]    
            [참조문헌 : 스프링5 책 115pg ~ 129pg] /    
            [참조링크 : https://hyeonguj.github.io/2020/02/07/java-interface-1/]   
            [참조링크 : https://sunghs.tistory.com/15]   
            [참조링크 : https://velog.io/@owljoa/Spring-Boot-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%8B%9C-%EC%84%9C%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%8B%9D%EB%B3%84-%EB%B0%A9%EB%B2%95]   
        1-6.@Component 빈과 설정파일에서 인터페이스형으로 추가한 빈 그리고 ctx.getBean 마지막으로 생성자주입, @Autowired주입, 설정파일 파라미터명 주입과의 관계 
            (1).먼저, 인터페이스와 이를 구현한 구현체 클래스 2개가 있다고 하고, 설정파일에는 딱히 아무것도 안써주었다고 하자.(구현체 클래스는 @Component로 빈 등록)
                그러고 나서, 인터페이스형 변수를 생성자주입하는데 쓰거나 @Autowired로 인터페이스형 변수에 주입하거나 설정파일의 파라미터에 인터페이스형 파라미터가 쓰인다고
                하면, 모두 구현체 클래스가 알맞게 들어간다. 또한, 어떤 인터페이스가 있고 이를 구현한 구현체 클래스가 하나이며 이를 @Component로 하고 설정파일에는 아무것도 안적어주었을 경우에도, 
                설정파일의 빈 메서드에서 파라미터에 해당 인터페이스형의 변수가 써져있다면 정상적으로 해당 구현체가 주입이 됬었다. 또한, 여기서는 구현체가 하나여서 그런지 해당 
                파라미터명이 아무거나 넣어도 그대로 다 정상적으로 작동하였다.(여기서 @Component로 구현체를 빈으로 등록했을때는(1개만 빈 등록) 설정파일의 파라미터에서 인터페이스형이 쓰이는 경우, 해당 파라미터명을
                아무거나해도 주입이 되는지는 확인하지 않았으나 가능한것으로 간주하고 한다. 문제 있을시에 다시 정리하자.) (만약 구현한 구현체 클래스가 빈이 2개이상일 경우, 파라미터명을 빈이름으로 적어준경우 해당 빈이 
                주입되는지에 관해서는 나중에 필요시 해보자.) 또한, ctx.getBean("빈이름",인터페이스명.class) 으로 받아오려는 경우에는, 빈이름에는 만약 구현체 클래스가 2개이고
                이 중 하나만, @Component로 빈 등록이 되있다면 빈이름에는 이 @Component된 클래스의 빈이름을 적어주어야 한다. 그렇지않으면 다른 빈이름들을 적어주면 예외가
                발생하게된다. 여기서는 다른 아무 설정없이 @Component로 구현체가 1개만 빈으로 등록되어있어도 이랬다.
                [직접해봄]    
                +
                추가로, 만약에 @Component가 된 여러개의 구현체가 있다면, ctx.getBean("빈이름",인터페이스명.class) 에서, 해당 등록된 빈의 이름을 getBean에서 빈이름에
                정확히 적어주면 해당 구현체의 빈을 갖고왔었다.
                [직접해봄]
            (2).직접 설정 클래스에 인터페이스형 메서드를 설정하고, 반환되는값을 구현체 클래스의 인스턴스나 구현체 클래스의 인스턴스이며 이를 가리키는 인터페이스형
                변수인 경우 ctx.getBean("해당메서드이름",인터페이스명.clss)으로 설정 파일에서 작성한 반환값이 반환된다.(자동형변환된 구현체 빈 혹은 이를 가리키는 변수) 또한,
                이 경우에도 해당 메서드이름을 정확히 인터페이스 반환형 메서드 이름과 똑같아야지 제대로 작동한다. 그 외의 메서드이름을 적어준다면 모두 예외 발생한다. 여기서
                새로 알게 된점은, getBean에서 class명 적는곳에 인터페이스명을 적어도 작동한다는것이며, 설정파일에 인터페이스 반환형을 적을 수 있고, 또 이 반환형으로
                자동 형변환된 구현체 인스턴스나, 이를 가리키는 변수를 반환하여 이 것을 getBEan()에서 갖고온 빈으로도 쓸 수 있다는거다. (또한, 이렇게 설정파일을 추가할시, 인터페이스 형으로
                자동형변환된 인스턴스 자체를 반환하거나 아니면 인터페이스형 변수가 이를 가리킨 변수가 반환한경우 둘다 해봤는데, 설정파일 파라미터의 인터페이스형에 대한 주입도 정상적으로
                이루어졌고(Datasource로 직접해봄) 또한, 생성자주입이나, @Autowired주입에 인터페이스형을 썻는데, 해당 설정파일에 적힌게 정상적으로 주입됬다. 이때 다른 구현체가 @Component쓰인것도
                아니였다. 또한, 이때도 설정파일에 해당 인터페이스형 메서드 하나만 적어주어서 그런지, 생성자주입이나 @Autowired 그리고 설정파일 파라미터형 변수명 모두 변수명이 제각각 달랐는데도
                모두 정상작동했다.) 물론 여기서도, 설정파일에 해당 인터페이스형 메서드가 하나밖에 없어도 getBean("빈이름",인터페이스명.class)에서 빈이름을 정확히 해당 메서드 이름과 같지 않으면
                예외를 발생했었다.
                [직접해봄]   
                [참조문헌 : 스프링부트 시작하기 48pg] / 설정파일에 인터페이스형이며 반환값은 형변환된 인스턴스인데 해닫 설정파일 다른 빈등록 메서드에서 파라미터로 인터페이스형 파라미터가 쓰였다.
                [참조문헌 : 스프링부트 시작하기 45 ~ 48pg] / DataSource로 직접 해봄  
                +
                여기서도 설정파일에 인터페이스 반환형 메서드를 만들고, 구현체 인스턴스나 구현체 인스턴스를 가리키는 인터페이스형 변수를 반환값으로 반환할때 해당하는 인터페이스 반환형
                메서드를 2개만들고 메서드 이름만 다르게 했는데, getBean("빈이름",인터페이스명.class)에서 빈이름에 각각의 방금 적은 메서드 이름을 빈이름에 정확히 적어주니 해당 빈 객체를
                갖고왔었다.
                [직접해봄]   
            (3).또한, 인터페이스형이 있고 이를 구현한 구현체가 2개 있을때 하나의 구현체는 @Component를 붙여서 빈을 등록하고, 하나는 설정파일에서 빈 메서드의 반환형이
                인터페이스형으로 하고 적절한 메서드명을 정해주고 반환값으로 구현체 인스턴스나 구현체 인스턴스를 가리키는 인터페이스형 변수를 반환한다고 해보면, main함수에서
                ctx.getBean("빈이름",형.class)에서 해당하는 빈이름을 적어주는것에 따라서, 설정파일 혹은 @Component한 빈을 갖고온다.
                [직접해봄]     
            (4).마지막으로, getBean에 대한 추가적인 내용인데, 내가 만약 설정파일에 일반 클래스 반환형에 메서드이름을 정해주거나 @Component로 설정을 대신해준다 해도, 싱글톤이라 해도
                각각, getBean에서 메서드이름에 해당 설정파일의 메서드이름이나 @Component 해준 클래스 파일명(첫글자 소문자)를 제대로 해주지 않으면 예외 발생한다. getBean에서는 그렇다.
                [직접해봄]     
        [정리]    
            1.아래 AOP를 사용하기위해 프록시 객체가 적용되는것을 이해하기 위한, 내용 정리이다. 우선, 여기서 핵심은 @Component로 빈 등록, @Bean을 이용한 빈 등록, @Autowired나 생성자주입 설정파일 파라미터 주입,
                마지막으로 ctx.getBean을 이용한 빈 객체 가져오기를 서로 각자 다른 역활을 하는것으로 인지하는것에서 출발해야 한다. 우선 제일 중요한건, 인터페이스의 구현체 클래스에서 @Component로 빈 등록을 한다는 말은
                해당 구현체 클래스 형의 빈타입과 해당 클래스 명의 첫글자만 소문자로한 빈 이름이 빈으로 등록된다고 볼 수 있지만, 동시에 해당 클래스는 구현한 인터페이스형도 될 수 있기에, 빈 타입은 인터페이스형으로
                하고 빈이름은 해당 구현체 클래스의 빈 이름의 첫글자만 소문자로 한것이 빈으로 등록됬다고 보는것이다. 즉, 구현체를 @Component로 빈 등록하면 구현체 형과 인터페이스형 두 타입의 빈이 동시에 등록된다고
                봐도된다. 그래서 main함수에서 ctx.getBean("구현체 클래스 이름",인터페이스명.class)에서 구현체만 @Component로 등록했는데도 이렇게 getBean을 적어주면(구현체 클래스 이름과 인터페이스명.class)
                정상적으로 빈을 불러오는데, 여기서 직접해보니 반환되는 형이 인터페이스형으로 이미 형변환된 구현체형을 값으로 갖고왔었다.(실제로 getBean으로 갖고온 빈을 구현체 형으로 할려하니 예외 발생했다.) 근데,
                여기서도 애초에 인터페이스형으로 이미 형변환된 구현체빈을 갖고오는걸 보니, @Autowired나 생성자주입, 설정파일 파라미터에 쓰이는 인터페이스형들도 모두 빈이 주입될때 이미 형변환이 끝난
                구현체 빈을 주입하는것같다.(import문 이해에도 도움)
                [직접해봄]    
            2.두번째는 설정파일로 반환형은 인터페이스형으로 하면서, 반환되는 값은 구현체 인스턴스나 이를 가리키는 인터페이스형 변수이다. 여기서 신기한것은 직접해본봐로는 만약, 이 해당 빈만
                등록을 하고 해당 구현체는 따로 빈 등록을 하지 않는경우는 어떻게 될까이다. 이 경우에 ctx.getBean("메서드이름",구현체명.class)로 하고 메서드 이름에는 설정파일에 인터페이스 반환형의
                앞선 메서드명을 적어주고 구현체명은 해당 설정파일의 인터페이스 반환형 메서드에 쓰인 구현체 클래스를 적어주면, 해당 구현체 클래스에 해당하는 빈을 반환한다. 그러나 내가 해당 구현체
                타입에 대해서 @Autowired나 생성자주입 아니면 설정파일의 파라미터에 쓰게되면 주입할 해당 타입의 빈이 없다고 예외를 발생시킨다. 즉, 내 생각에는 이 설정파일에 인터페이스 반환형으로 등록한
                메서드를 써주게 되면, 첫번째로 해당 인터페이스형의 메서드 명에 해당하는 빈이 등록이 되고(자동형변환된 구현체 인스턴스 혹은 이를 가리키는 변수) 그리고 나서, 예외적으로 설정파일의 인터페이스 반환형
                메서드에 쓰인 구현체만 ctx.getBean("메서드이름",구현체명.class)와 같이 메서드이름에는 해당 설정파일의 인터페이스반환형 메서드이름을 써주면, 실제로 구현체 타입의 빈을 값을 반환한다.(직접 구현체 타입 변수로 확인해봄)
                내 생각에는 이 부분만 예외적으로 허용한다고 밖에 볼 수 없다. 나중에 필요시 다시 봐보도록 하자.
            [결론]   
                설정파일에 인터페이스형의 메서드를 써주던, 구현체에 @Component로 빈을 등록하던, 인터페이스형의 빈이 생성되고 관리되며 이를 이용하는 방식을 결론적으로
                동일한것으로 보인다. 오히려, 구현체와 관련된 빈 사용에 대해서만 차이가 난다.
                [직접해봄]    
    2.위의 1. 내용들을 토대로 보면, @Service나 @Mapper 인터페이스들이 어떻게 @Controller나 @Service에서 구현체가 주입되는지 이제는 알 수 있다. 바로
        구현체가 하나이기때문에 그냥 인터페이스형 변수(@Autowired나 생성자주입에)를 쓰면 해당 구현체 빈이 주입되는거다.
        [직접해봄]    
    3.자바의 메서드의 파라미터나 생성자의 파라미터에 인터페이스형이 쓰이게 되고, 거기에 구현체 인스턴스가 실제로 들어가게되면,
        그 구현체 인스턴스는 자동 형변환이 된다음에, 생성자 함수나 메서드 함수에서 적용이 되는거다. 즉, 첫번째로 자바 객체의 생성자나 메서드의
        파라미터에 인터페이스형을 쓸 수 있는게 허용이 되고 두번째로, 거기에는 구현체 인스턴스만 들어갈 수 있는데, 그럴경우 자동형변환되서 생성자나 메서드
        함수내에서 자동형변환된 파라미터변수로 사용된다는거다. 그래서 검증을 했더니 함수 내에서 해당 구현체 인스턴스를 인터페이스형 변수에 대입하는것은 가능했는데, 
        해당 구현체 형의 변수에 대입하려하면 형이 맞지 않다고 나왔다. 이게 비슷하게 쓰인게 아래 스프링부트 시작하기 초록책 48pg인데, 지금 설명한것과 차이점은
        내가 봤을때 자바의 메서드나 생성자의 파라미터에 쓰이는경우 실제 구현체 인스턴스가 주입되는 경우 자동형변환되서 함수내에서 적용이 되지만, 아래 스프링부트의
        설정파일의 메서드에서 사용된 파라미터의 인터페이스형은 애초에 주입되는값이 형변환된 값이고 그대로 그게 함수내에서 쓰이는것으로 보인다. 이는 내가 직접 보고
        생각한 것이다. 조금 같은듯 다른것으로 생각하는게 편할것같다.
        [직접해봄]   
        [참조문헌 : 스프링5 155pg]   
        [참조문헌 : 스프링부트 시작하기 초록책 48pg]   
.
.
.
    3.AOP와 스프링 AOP에 대한 개념설명
        (3-1).AOP의 개념과 스프링 AOP에 대해 보겠다.
            1.AOP의 개념
                AOP의 기본 개념은 핵심 기능에 공통 기능을 삽입한다는 것이다. 즉, 핵심기능을 구현한 코드와 공통 기능을 구현한 코드를 분리함으로써,
                핵심 기능의 코드를 수정하지 않으면서 공통 기능의 구현을 추가하고 이 공통기능 코드를 재활용 하는것이 AOP이다. 
                [참조문헌 : 스프링5 158pg]   
                [참조링크 : https://engkimbs.tistory.com/746]
            2.SPRING AOP에 대해
                spring에서는 이 AOP라는 기법대로 코드를 짜보겠다는거다. 스프링은 이 AOP의 기능을 프록시를 이용해서 구현한다.
                [참조문헌 : 스프링5 158pg]
.
.
.
    4.스프링 프록시를 구하는 두가지(1).JDK Dynamic Proxy와 (2).CGLIB 방법이 있는데, 이 두가지 방법들에 대해서 정리하겠다.         
        (1).JDK Dynamic Proxy
            (1-1).시작하기에 앞서, 동적로딩에 대해 먼저 알아야 한다.
                우선 동적로딩에 대해 알아볼것인데, (핵심 기능에 공통기능을 삽입하는 3가지 방법의 글에 간단하게 클래스로더와 클래스로딩
                그리고 JVM 메모리에 올리는것에 대해 정리되어있다. 이것 참고하기) 클래스 로더에서는 받은 바이트코드(.class 파일의 코드들)를
                JVM의 메모리에 올리는것을 클래스로딩이라고 한다 했다. 추가로 아래 첫번째 참조링크에 보면, 이는 다른 말로 해당 .class 객체를 생성하는
                동작이라고 한다. 근데 이 클래스 로더가 해당 자바 프로그램 실행시에 모든 클래스 파일(.class = 바이트코드)들을 한번에 JVM 메모리에 로드
                시키지 않고, 요청이 들어온 순간만 로딩(객체 생성)시킨다고 한다. 즉, 이러한 행위를 동적로딩이라 하는데, 다시 한번 정리하자면 동적로딩이란
                모든 클래스가 Java프로그램 실행시에 로딩(객체 생성) 되지 않고, 필요한 시점에 클래스파일(.class)을 로딩(객체 생성)시킨다는것이다.
                동적로딩 외의 로딩은 필요시 자세히 찾아보도록 하자.
                [참조링크 : https://futurists.tistory.com/43]   
                [참조링크 : https://stack07142.tistory.com/306] / 동적로딩의 개념
                +
                동적로딩에는 두가지 종류가 있다. 하나는, 로드 타임 동적 로딩이다. 로드타임 동적로딩은
                하나의 클래스를 로딩하는 과정에서 필요한 다른 클래스를 동적으로 로딩하는 것 이다. 
                아래 예시는 로드타임 동적로딩에 관한 예시이다.
                public class Hello { 
                    public static void main(String[] args) { 
                        System.out.println("Hello, world!"); 
                    }
                }
                이 코드를 보면, Hello 클래스를 로드(객체 생성)할 때 이 클래스가 참조하고 있는 Object, String, System. 클래스가 아직 로드(객체 생성)
                되지 않았으므로, Hello 클래스를 로드(객체 생성)하는 일을 중단하고 우선 이 클래스들을 로딩(객체 생성)해야 한다. 이 처럼 한 클래스의 로드(객체 생성)
                에 필요한 다른 클래스들을 동적 로딩하는 것을 로드타임 동적로딩이라한다.
                [참조링크 : https://futurists.tistory.com/43] / 예시들
                [참조링크 : https://stack07142.tistory.com/306] / 로드타임 동적로딩과 런타임 동적로딩
                +
                다른 하나는 런타임 동적로딩으로 코드를 실행하는 순간에 필요한 클래스를 로딩하는 것이다. 즉, 런타임 시에
                필요한 경우 클래스를 로딩하여 사용한다는것이다. 이것에 대한 개념만 알아두고 자세한 예시는 아래 JDK Dynamic Proxy가
                런타임 동적로딩을 통해 만들어지니, 이것으로 예시를 보이겠다.
                [참조링크 : https://stack07142.tistory.com/306] / 로드타임 동적로딩과 런타임 동적로딩
                [참조링크 : https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html] / JDK Dynamic Proxy는 프록시를 동적으로 생성해준다.    
            (1-2).자바의 리플렉션(reflection)에 대해 알아보자.
                자바의 리플렉션이란 구체적인 클래스 정보들을 알지 못할때, 해당 클래스의 정보들에 대해 접근 할 수 있게 해주는 자바 API이다. 
                즉, 자바 프로그램을 실행하게되면 자바 파일은 클래스 파일(바이트코드)로 컴파일 되어 모든 클래스파일들은 Static영역에 위치하게된다.
                (이 부분 틀린부분 있으면 나중에 다시 봐보도록 하자.) 그러기에, 클래스 파일 이름만 알고있다면, 리플렉션 api를 이용해서 해당 클래스
                정보를 갖고와 해당 클래스를 동적로딩(객체 생성)이 가능하게 해준다. 즉, 자바의 리플렉션은, 다른 클래스 들의 정보를 갖고오게 해주어,
                해당 클래스를 동적 로딩(객체 생성)하게 해주는 기능이 있는것이다. 
                [참조링크 : https://taes-k.github.io/2021/05/15/dynamic-proxy-reflection/] / 자바 리플렉션 정의   
                [참조링크 : https://brunch.co.kr/@kd4/8] / 자바 리플렉션 정의   
                [참조링크 : https://brunch.co.kr/@kd4/8] / 모든 클래스 파일은 Static영역에 저장된다.
                [참조링크 : https://madplay.github.io/post/java-reflection] / 근데 여기서 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적로딩(객체생성)할 때 쓴다는것보니, 리플렉션은 런타인 동적로딩에만 쓸 수 있나보다.(나중에 틀리거나,필요시 자세히 보기, 아래 링크가 그 내용)   
                [참조링크 : https://velog.io/@agugu95/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%86%8D%EB%8F%84-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EA%B8%B0%EB%B2%95%EB%93%A4] / 추가적인 로드타임 런타임 동적로딩, 리플렉션에 관하여
                +
                자바 리플렉션에서 제공하는 기능중 하나인 Class.forName()메서드 말고도 많은 메서드가 있다.
                [참조링크 : https://jongminlee0.github.io/2019/06/29/reflection/]
            (1-3).이제 스프링, 스프링부트 AOP에 사용되는 프록시 중 하나인 JDK Dynamic Proxy에 대해 정리하겠다.
                (1).DK Dynamic Proxy(동적 프록시)는 왜 JDK Dynamic Proxy로 불리느냐이다. 바로, 이 동적 프록시는 자바 리플렉션을 이용해서
                    동적으로 생성하는 프록시 객체이기 떄문이다.(내가 설명한 글들을 토대로라면 사실상 동적로딩을 통해 프록시를 생성한다라고 볼 수 있다.
                    근데 어디서든 동적으로 프록시 생성한다고 하지, 동적로딩을 통해 생성한다고 말을 안한다. 인지만 하기.) 그러하기 때문에 동적 프록시라고
                    한다. 즉, 좀 더 자세히 얘기하자면, 아래에 (2)의 과정에 자세히 설명하도록 하겠다.
                    [참조링크 : https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html]    
                    [참조링크 : https://taes-k.github.io/2021/05/15/dynamic-proxy-reflection/]     
                    [참조링크 : https://sabarada.tistory.com/97]     
                    [참조문헌 : 스프링5 158pg] / 런타임에 프록시(JDK Dynamic Proxy) 객체를 생성한다.        
                (2).JDK Dynamic Proxy가 생성되는 과정에 대해 알아보도록 하겠다.
                    1.우선 JDK Dynamic Proxy 즉, 어느 빈을 프록시로 생성할지에 대해서는 '포인트컷'이라는걸 적용해서 지정한다.(구체적인 방법에 대해서는 아래에 포인트컷에서 보고
                        여기서는 JDK Dynamic Proxy가 생성되는 과정에서 필요한 정보만 정리하도록 하겠다.) 포인트컷은 동적 프록시 생성이 기본인 스프링에서는, 인터페이스 아니면 인터페이스를
                        구현한 구현체 클래스를 지정하고 그에 해당하는 메서드를 지정할 수 있다. 즉, 추가적으로 말하면 JDK Dynamic Proxy를 이용하는 경우, 포인트컷은 인터페이스의 메서드나
                        아니면 인터페이스를 구현한 구현체 클래스의 메서드만 우리가 봐왔고 의미가 있는것으로 알고있다. 그 외가 JDK Dynamic Proxy, 동적프록시에 있다면 다시 정리하기로 하자.
                        [직접해봄]    
                        +
                        추가적인 얘기를 해주면, 포인트컷으로 지정된 메서드가 실행되면, 동적으로 프록시 객체를 생성해서 빈으로 등록하여 사용하게 되는것인데, 이때 먼저
                        해야할 것이 동적프록시는 사용되는 방식이 항상 인터페이스명에 구현체 자동형변환 반환 형식에서만 사용이 되는데, 이때 먼저 가장 확인되는것이 해당 인터페이스명
                        변수에 어떤 구현체 클래스가 할당되는지다. 이게 정해져야 그 다음 프록시 객체가 생성되던지 하는거다. 구현체가 여러개인경우 변수명을 해당 구현체 클래스명의
                        첫글자만 소문자로 바꿔서(@Component로 한 경우) 적어서 어떤 구현체 클래스가 적용되어 사용되는지 명시해주거나 아니면, 구현체 클래스가 하나인 경우 변수명을
                        어떠한것을 해도 해당 구현체 클래스가 사용이되니 상관이 없었다. 이것 모두 직접 해보았다.
                        [직접해봄]     
                    2.이제 만약, 인터페이스의 구현체 클래스의 메서드를 포인트컷으로 지정하게 된다면, 동적프록시 객체가 생성되는 과정을 적도록 하겠다. 우선, 인터페이스형이면서
                        해당 인터페이스의 구현체 클래스가 자동형변환되서 들어가는 변수의 메서드가 쓰이게 되면, 위의 1.과정을 거치고 나서, 해당 동적프록시를 생성하게되는데, 말했다시피
                        @Component로 빈 생성하고 만약 해당 클래스가 구현체이면, 해당 구현체형이면서 구현체 클래스의 첫 글자만 소문자로 바꾼것이 이름인 빈을 등록하고, 또한 인터페이스형
                        이면서, 빈 이름은 구현체 클래스의 첫글자만 소문자인 반환되는값은 구현체 클래스 객체로 자동형변환된 빈도 하나가 등록이 된다. 그러니, 만약 인터페이스의 구현체 클래스의
                        메서드를 포인트컷으로 지정하게 된다면, 해당 구현체형은 정상적으로 빈을 등록하지만 실제로 생성자주입이나 이런걸로 구현체형 변수를 주입하려고 하면, 실질적으로 이 '형'의
                        빈은 프록시 형이라 하고 못쓰게한다. 즉, 해당 구현체형의 빈의 경우 등록은 되지만 직접적으로는 못쓰는것같고, 그 다음 인터페이스형인 빈은 반환하는 구현된 클래스 객체를
                        반환하는게 아니라 만들어진 해당 인터페이스를 구현한 프록시 객체가 대신 들어가서 자동 형변환되는것으로 알고있다. 이렇게 인터페이스의 구현체 클래스의 메서드를 포인트컷으로
                        지정하게 되면, 빈 등록하는 과정에서 2가지가 변하게 된다.
                        [직접해봄]    
                        +
                        추가로, 만약에 인터페이스의 메서드를 포인트컷으로 지정하게 된다면, 해당 인터페이스형이면서 인터페이스를 구현한 구현체 클래스를 자동형변환하여 반환하게
                        되는 변수의 메서드가 쓰이게 되면, 해당 변수는 구현체 클래스에 상관없이(당연히 빈 등록되고 기타 등등이 있겠지만 이러한 변수 제외하고) 1.의 과정만 잘 적용
                        된다면 모두가 다 바로 위의 2.의 첫 글의 과정처럼 적용이 되게된다. 이것도 모두 직접 해본거다.
                        [직접해봄]    
                    3.그러면, 어떻게 프록시 객체가 생성이되어서, 자동형 변환이 되고 또한 기존의 구현체 형의 빈은 어떻게 쓰이는지 보도록 하겠다.(물론, 이건 내 가정이고 실제로 다를 수 있다.)
                        구현체 형의 빈의 경우는 위에서 설명을 했고, 이제 인터페이스형의 구현체 클래스 객체대신에 프록시 객체가 들어가게 되는데, 이때 프록시 객체가 생성되는것에 대해 설명하도록
                        하겠다. 우선, 내가 말하는것이 분명 다를것이다. 그러나 이러한 정도까지만 알면될것같고, 나머지는 나중에 필요시 더 사실적으로 찾아보도록 하자. 우선 프록시 객체가 생성이 되는데,
                        기본적으로 리플렉션을 이용하여, 해당 구현체 클래스의 바이트 코드들에 대한 정보를 갖고와 프록시 객체를 생성하고, 또한 해당되는 인터페이스를 구현하는 구현체로써 만들게 된다.
                        포인트컷이 적용되지 않는 메서드들은 그냥 그대로 쓰고, 만약에 포인트컷이 적용되는 메서드들은 또 다르게 코딩이 되는데, 다음 번호에 설명하도록 하겠다.
                        [직접해봄]    
                        +
                        동적프록시(Dynamic Proxy)는 오직 인터페이스를 통해서만 생성할 수 있다고 한다. 
                        더 자세한 내용들은 있는데 이 정도만 알아도 될 것 같다. 실제로는 여기 적혀져 있는것보다
                        훨씬 복잡하다.
                        [참조링크 : https://yeti.tistory.com/225]    
                        [참조링크 : https://huisam.tistory.com/entry/springAOP]
                    4.우선, 기존의 대상 객체의 멤버변수가 프록시 객체의 멤버변수에 그대로 값이 들어가지 않는것으로 본다. 또한, 다른 일반 포인트컷이 적용이 안된 메서드의
                        경우, 해당 메서드도 @Override하여 해당 메서드를 실행시에, 대상객체의 일치하는 메서드를 '호출'하는것으로 알고있다. 즉, 프록시 객체의 멤버변수를 대상객체의
                        멤버변수를 가져다 대입하지 않아도, 포인트컷이 적용되지 않은 메서드 호출시에 대상객체의 메서드를 호출하여 사용되기 때문에 괜찮다. 이 부분 필요하면 나중에 더 자세히 
                        보도록 하고, 이 모든것도 자바의 리플렉션을 이용하는것으로 알고있다.(물론, 실제는 다르다. 실제는 더 복잡하나, 우선적으로 필요한 이해를 하는거다. 이 부분 나중에 다시 
                        볼 필요가 있을때 다시보자.) 포인트컷이 적용된 메서드의 경우에는, 아래 ProceedingJoinPoint형에 대한 정리문을 보면 알겠지만 우선, @Override를 하고 프록시 객체 멤버변수에 
                        Aspect 객체 변수를 만들어 사용하지 않는다. 즉, 어떠한 멤버변수도 프록시 객체에 등록하지 않고 포인트컷이 적용된 메서드가 호출시에, 알아서 Aspect클래스의 빈의 어드바이스에 
                        해당하는 메서드가 호출이되고, 그리고 그 어드바이스 메서드의 파라미터(ProceedingJoinPoint형 변수)에 해당 대상객체의 정보와 대상객체의 핵심기능 메서드에 대한 정보 
                        그리고 핵심기능 메서드 호출시에 전달되는 파라미터 인자가 한번에 전송이 되는것으로 보인다.
                        [직접해봄]    
                        [참조문헌 : 스프링5 165pg]    
                    [추가사항]    
                        1-1.한가지 궁금한것이, 보면 아래 참조문헌에서 분명 Controller에 BoardService형으로 인터페이스형으로 구현체 객체를 자동형변환해서
                            쓰고 있다. 근데 BoardService는 보면 멤버변수가 없고, BoardServiceImpl만 멤버변수가 있다. 그럼에도 불구하고, 인터페이스형이면서
                            구현체 객체를 자동형변환해서 쓰이는 변수에서 메서드를 사용하는데, 이 메서드는 엄연히 구현체 클래스인 BoardServiceImpl의 멤버변수를
                            이용해서 구현하는것이다. 그럼에도 불구하고 정상적으로 작동했다. 이 부분 봤을때, 실제로 멤버변수가 구현체에만 있어도, 해당 멤버변수의
                            메서드를 사용한 구현체의 메서드를 인터페이스형 변수에서 그대로 사용할 수 있나보다. 라고 생각했는데 전혀 아니다. 아래 결론에 적어놓도록
                            하겠다. 
                            [직접해봄]    
                            [참조문헌 : 스프링부트 시작하기 초록책 BoardService와 BoardServiceImpl]    
                        1-2.사실상 그러면, 여기서 이해하는 방향으로는 프록시 객체 만들때(인터페이스형으로 자동 형변환전) Aspect 클래스를 프록시 객체에 멤버변수로
                            사용하지는 않고, 포인트컷이 지정된 메서드 내에 어드바이스에 해당하는 메서드를 그냥 내부적으로 Aspect클래스의 빈의 메서드를 호출시키는데 사용한다고
                            보면 될것 같다. 근데 사실상 인터페이스형으로 자동 형변환되면, 구현체클래스의 멤버변수는 직접적으로 사용할 수 없다. 그러나 위의 추가사항1-1과 마찬가지로, 
                            자동형변환하기 전의 객체의 멤버변수의 메서드를 해당 객체의 메서드내에서 호출하여 사용할때 정상적으로 작동하였다. 이 부분도 인지하고 넘어가는게 좋을거같다.
                            근데 이게 되는 이유를 아래 결론에 적어놓겠다.
                            [직접해봄]    
                        [결론]    
                            우선, 예전에는 이렇게 인터페이스형으로 자동형변환된 구현체 객체를 가리키는 변수를 사용할때는 그냥 해당 변수의 메서드를 호출시에,
                            단순, @Override된 구현체 클래스의 메서드를 대신 사용한다고만 인지하고 있었는데, 좀 더 구체적으로 들어가게된다면 아래 자바 참조문헌에 보면
                            메서드를 호출하게 되면, 해당 메서드 주소를 찾아서 메서드 영역(코드영역)에서 메서드를 찾아서 사용하게 된다. 그런데 보면 구현체 클래스에서 메서드를 사용하건,
                            인터페이스형으로 형 변환된 구현체 클래스 변수에서 메서드 호출하건 둘다 동일한 메서드 주소를 가리키게 되어 메서드 영역에서 메서드를 사용하게 된다.
                            또한, 구현체 클래스를 직접 사용한다 할때 이 클래스형의 인스턴스(자바에서 본거다.)가 여러개더라도, 모든 인스턴스가 동일한 메서드를 호출하면 메서드 영역에
                            있는 하나의 메서드를 모두 호출하게 된다. 즉, 메서드는 멤버변수처럼 매번 새롭게 생성되는게 아니다. 이런것을 모두 따져봤을때, 인터페이스형이면서 자동 형변환된
                            구현체 객체의 메서드를 호출하더라도, 구현체 클래스형에서 호출되는 메서드와 똑같은 방식과 똑같은 주소의 메서드가 호출되니, 인터페이스형 변수의 멤버변수에
                            필요한 변수가 있지않더라도 정상적으로 메서드들이 작동하게 되는것이다.
                            [직접해봄]    
                            [참조문헌 : 자바 255pg ~ 256pg]     
                            [참조문헌 : 자바 254pg]    
                (3).이제 이 JDK Dynamic Proxy을 실제 사용하여 실행되는 과정에 대해 보겠다.
                    만약 클라이언트가 포인트컷에 해당하는 메서드를 실행하게되면, 프록시 객체의 해당 메서드가 실행이되고, 그 다음
                    Aspect클래스의 어드바이스에 해당하는 메서드가 실행이된다.(이렇게 되는거 위에 정리해놨다. 또한, 아래 참조문헌 보면 이해가 더 잘될거다.)
                    그런다음 그 해당 어드바이스 메서드의 파라미터에 스프링 컨테이너에서 알아서 해당 실행 메서드에 관련된것과 핵심기능 메서드를 갖고있는 대상객체
                    그리고 해당 메서드에 전달된 파라미터에 관한 정보를 ProceedingJoinPoint형 변수에 전달하게 된다.(이 부분은 위와 아래에 정리해놓았다.) 그리고 나서
                    공통기능 코드가 실행이 되고, 그 와중에 ProceedingJoinPoint형 변수의 proceed()메서드가 실행이 되면, 해당프록시 객체의 호출메서드에 해당하는 대상객체의
                    핵심기능 메서드가 호출된다. 그렇게 대상객체의 핵심기능 메서드가 실행이 되는것으로 알고있다.(물론, 정확히는 대상객체의 핵심기능 메서드가 어떻게 실행되는지는
                    알 수 없으나 이정도만 알아도 충분할것같다.)
                    [직접해봄]    
                    [참조문헌 : 스프링5 165pg]          
            [추가사항]    
                1.아래 참조문헌에 보면, 프록시 클래스를 getClass().getNAme()하면 com.sun.proxy.$Proxy17과 같은
                    결과값이 나오게 된다. 근데 이게 아래 참조문헌에서 자바의 버전이나 스프링 버전에 따라 이름이 달라질 수 
                    있다고 한다. 알아두자.
                    [참조문헌 : 스프링5 164pg]    
                2.이 JDK Dynamic Proxy는 동적프록시로, 애초에 인터페이스기반으로 만들어지는 프록시 객체이기 떄문에
                    그렇기에, AOP를 사용하려는 대상에 대해서, 즉, 대상객체가 인터페이스를 구현한 구현체여야 하며, 사용하는
                    방법도 해당 인터페이스형이면서 대상객체를 자동형변환시키는 변수로 사용하여야만 한다.
                    [직접해봄]    
                    [참조링크 : https://huisam.tistory.com/entry/springAOP]    
                    [참조링크 : ]        
        (2).CGLIB 프록시
            (2-1).스프링부트 AOP에 사용되는 프록시 중 하나인 CGLIB에 대해 정리하겠다.
                (1).CGLIB도 런타임 위빙을 통해 프록시 객체가 생성되는것이고 전반적으로 봤을때도 동적으로 생성되는건데, 이거는 동적 프록시라고
                    부르지 않느냐는 것이다. 아래 첫번째 참조링크에 보면, 동적프록시가 두종류가 있다고 하고 CGLIB과 JDK Dynamic Proxy를 언급하는데 여기 외에는
                    모두 Dynamic Proxy(동적프록시)와 CGLIB으로 프록시 종류를 나눈다. 그리고 두번째 참조링크를 보면, CGLIB도 동적으로 생성하는 방식이라고 나와있다.
                    그러나, 대부분 JDK Dynamic Proxy와 CGLIB을 비교할때 Dynamic Proxy(동적프록시)와 CGLIB 이렇게 비교하면서 설명문에 적혀있다. 이 부분은
                    조금 애매하긴한데, 정리하자면 사실 CGLIB 프록시 객체는 동적으로 생성해주는 프록시 객체가 맞다. 더 자세히 하면 런타임 동적로딩으로 볼 수
                    있을거같다. 그러나, 사람들이 JDK Dynamic Proxy와 비교할때 그냥 편리상 동적프록시로 부르고 이를 CGLIB과 비교할때 그냥 그렇게 쓰는것같다.
                    즉, CGLIB도 동적 프록시로 내 생각에는 보는게 맞고 실제로도 동적으로 생성되는것이나, 그냥 편의상 JDK Dynamic Proxy와 비교할때 이걸 동적프록시로
                    부를때는 그냥 구별되게만 이해하면 될것같다. 나중에 필요시 더 자세하게 정리하도록 하자.
                    [참조링크 : https://sabarada.tistory.com/97] / 동적프록시에는 JDK Dynamic proxy와 CGLIB이 있다고 명시
                    [참조링크 : https://eminentstar.tistory.com/76] / CGLIB은 동적으로 생성해주는 것
                (2).CGLIB과 JDK Dynamic Proxy모두 런타임 위빙 방식이라고 어느 참조링크를 보던 그렇게 나와있다. 그러나, CGLIB의 경우 사실상 
                    런타임 위빙방식이긴하나, 상세히보면 바이트코드를 조작하여 프록시 객체를 생성해주는데 어디에도 나와있지는 않지만 분명 클래스파일 로드 시점에
                    바이트코드를 조작하여 프록시 객체를 생성해주는것으로 보여진다. 그럼에도 불구하고 로드 시점 위빙이라고 부르지 않는 이유는 아마도 공통기능을
                    바이트코드에 삽입하는 방식이 아닌, 조작하여 따로 프록시 객체를 만드는 방식때문에 그럴수도 있고, 아니면 런타임중에 행해지는것이기 때문에 그냥
                    런타임 위빙이라고 하는것일 수도 있겠다. 이 부분은 이렇게만 알고 나중에 필요하면 자세히 알아봐도 괜찮을것같다.
                    [참조링크 : http://wonwoo.ml/index.php/post/1576] / 바이트코드를 조작해 프록시 객체를 만든다.     
                    [참조링크 : https://serverwizard.tistory.com/92] / 바이트코드를 조작해 프록시 객체를 만든다.    
                    +
                    추가로 아래 참조링크를 보면, CGLIB의 바이트코드조작하며 하는 런타임 위빙 방식이 마치 AspectJ의 위빙방식과
                    닮았다고 했다. 이 정도만 인지하고 있자.
                    [참조링크 : https://ehdvudee.tistory.com/22]
                    +
                    [결론]    
                        아래 참조링크에 보면, 애초에, AspectJ를 사용하면 클래스들이 Aspect와 함께 바로 컴파일되기 때문에, 즉 런타임 전에 모두 작업이 끝나기에
                        런타임시에는 아무것도 하지 않는다. 그리고 로드 시점 위빙도 1.로드타임 동적로딩과 같은 형태나 2.런타임 전에 행해진 위빙을 로드 시점 위빙이라 하나보다. 
                        우리가 본 CGLIB같은 경우는 런타임에 행해지는 것들이다. 즉, 위에서 한 말이 맞았다. 로드 시점이라고 해도 어느 부분의 시점에 따라 나뉘는것으로 보인다. 여깄는 부분
                        더 알아야할 필요성이 있으면 그때 다시 봐보도록 하자.
                        [참조링크 : https://logical-code.tistory.com/118]
                (3).CGLIB 생성되는 과정에 대해 알아보도록 하겠다.
                    1.우선, 기존의 Aspect클래스에 적용된 포인트컷과 @Around에 대해 얘기하겠다. Aspect 클래스가 빈으로 등록되면, JDK Dynamic Proxy에서 그랬던것처럼( @EnableAutoConfiguration
                        에 정리 되있다.) @EnableAutoConfiguration 주석으로 인해 @Aspect가 붙었던 클래스의 빈을 찾아서 포인트컷 설정을 적용해주고 어드바이스를 사용할 수 있게 설정해준다고 한다. 이 부분은 
                        여기까지 보면 될것같다. 즉, JDK Dynamic Proxy와 이 부분은 동일하다고 볼 수 있다.
                        [직접해봄]        
                    2.포인트컷이 적용될때, 인터페이스의 메서드를 포인트컷으로 설정하던, 아니면 구현체 클래스의 메서드를 포인트컷으로 설정하던 아니면 마지막으로
                        그냥 일반 클래스의 메서드를 포인트컷으로 설정하던 모두 정상적으로 적용이 됬었는데, 그 이유는 일반 클래스(컨트롤러에 해봤다.)에 포인트컷 적용시에
                        CGLIB 프록시 객체가 생성되는 방식이 만약 포인트컷이 적용된 메서드가 호출되게 되면 그때, CGLIB 프록시 객체가 만들어지는데 만들어 지는 방식은 기존의
                        대상객체를 상속받아서 만들어진다. (지금부터는 조금 다를 수 있지만, 이렇게 우선 이해하자.) 이때, 멤버변수는 아예 작성하지 않고 그대로 모두 받아들이는것
                        같고(사실 받아들여도 사용하지는 않지만,) 추가로 Aspect 클래스를 멤버변수로 사용하지도 않는다. 포인트컷이 적용되지않은 메서드의 경우에는 @Override하여
                        내부적으로 알아서 호출이 될때, 대상객체의 해당되는 메서드를 호출시켜주는것 같다. 그 외에 포인트컷이 적용된 메서드의 경우에는 @Override하여 해당 메서드 호출시 
                        Aspect클래스형의 빈의 어드바이스 메서드를 호출하도록 되게 한것같다. 이것도 내부적으로 처리되는것 같다. 이렇게 하고 해당 프록시 객체가 생성이되면, 원래 대상객체형의 
                        빈설정에서 반환하는값에 대상객체말고 이 프록시 객체를 대신 넣는것이다. 또한, 대상객체는 빈이 만들어져있으나, 해당 대상객체 '형'의 빈으로는 사용하지 못하고 필요할때만 
                        호출되게끔하는것같다. 그렇게, 프록시 객체는 대상객체인 상위클래스로 자동형변환이 되어 반환이 되고 이게 대상객체 '형'의 빈으로 설정이 되는것같다. 
                        추가로, 생성할 프록시 객체의 핵심기능 메서드에 대해 오버라이딩하여 사용한다고 나와있다.
                        [직접해봄]    
                        [참조링크 : https://huisam.tistory.com/entry/springAOP] / 핵심기능 메서드에 대해 오버라이딩하여 사용한다.
                        +
                        그리고, 구현체 클래스의 메서드를 포인트컷으로 설정하게 된다면, 당연히 해당 구현체 클래스형의 변수를 사용하게 된다면, 일반 클래스에서 적용되고 사용되던
                        방식과 동일하게 적용이되어 CGLIB 프록시 객체가 적용이되고 만약에 인터페이스형 변수이면서 해당 대상객체를 자동형변환하여 쓰는 변수가 사용된다면, 위에서 대상객체
                        형의 빈 설정에서 CGLIB 프록시 객체를 대신 반환했었는데 이 객체를 그대로 인터페이스형이면서 대상객체를 반환하는것에서 대상객체 대신에 이 CGLIB프록시 객체를 대신
                        넣게 되는것이다. 그러면 인터페이스형이면서 자동형변환된 CGLIB객체가 사용되게 된다. 그러면, 포인트컷이 지정되지 않은 메서드를 호출할때, 대상객체의 메서드를 정상적으로
                        호출하게되고, 포인트컷이 지정된 메서드를 호출하게 된다면, 내부적으로 어드바이스에 해당하는 메서드가 호출이되고, 이 어드바이스의 파라미터에 해당 대상객체의 정보와 
                        호출된 대상객체의 핵심기능 메서드의 정보 그리고 전달된 인자에 대해 전달이된다.(ProceedingJoinPoint형 객체)
                        [직접해봄]    
                        +
                        마지막으로, CGLIB을 사용하는데 있어서 포인트컷을 인터페이스의 메서드로 설정하였을때인데, 이때는 해당 인터페이스를 구현한 모든 구현체 클래스의 메서드를 포인트
                        컷으로 설정이 되는것같다. 그래서, 인터페이스형이면서 구현체 클래스를 반환하는 변수에 쓸때 어떠한 구현체를 쓰던 모두 프록시 객체가 적용이 된다
                        [직접해봄]    
                        +   
                        [추가내용]    
                            1.추가적인 내용인데, 일반 클래스의 메서드에 포인트컷을 하면 당연히 잘 적용이 됬고, 구현체 클래스의 메서드에 포인트컷을 설정하면, 해당 구현체형의
                                빈 설정에 영향을 주고 동시에, 해당 인터페이스형이면서 구현체 객체를 반환하는 빈 설정에도 구현체 객체대신 해당 CGLIB 프록시 객체를 넣어 한번에
                                두개의 빈 설정이 적용이 된다. 만약 인터페이스의 메서드를 포인트컷으로 지정한다면, 이를 구현한 구현체 클래스에 이 2개의 빈 설정이 모두 적용이
                                된다. 실제로 컨트롤러로 일반 클래스를 해봤고, 구현체 클래스를 포인트컷으로 설정하고 해당 인터페이스형 변수에 구현체객체를 자동형변환시키는 변수와
                                아니면 해당 구현체형만 쓰는(BoardServiceImpl) 변수를 직접 각각해봤는데 둘다 잘 적용이 됬었다. 
                                [직접해봄]     
                            2.추가로, 인터페이스형이면서 자동형변환된 객체를 쓰는 변수의 경우 JDK Dynamic Proxy와 마찬가지로 우선 해당 변수에 적절한 빈이 잘
                                바인딩되있는지부터 본다. 즉, 구현체 클래스가 한개면 변수명을 아무거나 해도 되지만, 만약 @Component로 등록한 구현체 클래스가 여러개면
                                이것도 해당 빈 이름에 맞게 변수명을 적어주어야 한다.
                                [직접해봄]        
                (4).이제 이 CGLIB을 실제 사용하여 실행되는 과정에 대해 보겠다.
                    이제 바로 위의 1번의 3가지 경우에 적절히 맞게 프록시 객체가 생성이되면,(단, 인터페이스형 변수는 적절하게 빈이 바인딩이 되야겠지만) 
                    이제 이 포인트컷에 해당하는 메서드를 실행하게 된다. 그렇게 되면, Aspect클래스의 어드바이스에 해당하는 메서드도 호출이 되고, 이 어드바이스에
                    파라미터에 적절한 대상객체에 대한 정보와 해당 대상객체의 핵심기능 메서드 그리고 핵심기능 메서드에 전달되는 인자에 대해서도 전달이 된다. 그러고나서
                    공통기능 등이 실행이 되는데, 이 코드 안에 ProceedingJoinPoint형의 변수의 proceed()메서드가 실행이 된다면, 해당 대상객체의 핵심기능 메서드가
                    호출이 되는것으로 알고있다. 여기에서 더 필요한 부분이 있다면 나중에 다시 정리하도록 하자.
                    [직접해봄]    
            (2-2).CGLIB은 final 예약어에 대해 잘 알아두어야 하는데 우선 프록시 객체를 적용하려는 대상객체가 즉, 클래스가 final이 적혀져 있으면 안된다.
                그렇게 된다면, 애초에 해당 클래스는 상속할 수 없어서 프록시 객체를 만들 수 없다. 그 다음은 만약 @Bean으로 설정파일에서 등록해준경우에는 해당
                @Bean메서드에 final 예약어를 붙이면 안된다고 한다. 우선 메서드에 final를 붙이면 하위 클래스에서 재정의 할 수 없다고 하는데, 사실상 이건 정확하게
                안다기보다 그냥 @Bean으로 빈 설정파일에 등록해준경우 여기는 final은 쓰면 안되겠구나 정도로만 이해하고 넘어가도 될것 같다. 그 다음은 대상객체의 메서드에
                대해서인데, 이해하는 방향이 여기서 내가 정리하기론 프록시 객체의 모든 메서드는 @Override하여 사용한다고 적어놓았었다. 그러면 당연히 final 예약어를 사용할 수
                없다. 만약에 이거 관련해서 더 볼 거 있으면 그때 정리하고 대상객체의 생성자가 private등과 같은 자세한 얘기는 나중에 필요시 다시 하도록 하자.
                [참조문헌 : 자바책 305pg] / final이 붙은 클래스는 상속할 수 없다. & final이 붙은 메서드는 하위 클래스에서 재정의 할 수 없다.
                [참조링크 : http://wonwoo.ml/index.php/post/1708] / @Bean 메서드에 final 예약어를 적으면 오류가 발생한다.  
                [참조링크 : https://huisam.tistory.com/entry/springAOP] / final이 적혀진 클래스는 상속이 안되고, private 접근자가 된 메서드는 재정의를 할 수 없다.
                [참조링크 : https://serverwizard.tistory.com/92] / 클래스에 final을 붙이면 안된다, @Bean 메서드에 final을 붙이면 안된다.
        [추가사항]    
            (1).JDK Dynamic Proxy와 Cglib 프록시 객체 생성은 모두 런타임에 프록시 객체를 생성하는 방식이다. 즉, 런타임 위빙 방식이다.
                또한, 두번째 참조링크에서 보듯이, JDK Dynamic Proxy와 CGLIB방식 모두 기존의 코드에 변경하지 않으면서 진행하는 방법들이다.
                아래 참조링크 말고도 수많은 참조링크에서도 그렇게 나온다.
                [참조링크 : https://huisam.tistory.com/entry/springAOP]    
                [참조링크 : https://yeti.tistory.com/225] / JDK Dynamic Proxy와 CGLIB방식 모두 기존의 코드는 변경하지 않으면서 기능을 추가할 수 있는 프록시 기술을 구현한 방법들이다.   
            (2).정리해 보도록 하겠다. 우선 스프링이나 스프링부트에서 설정파일에 @EnableAspectJAutoProxy(proxyTargetClass = ~)로 ~에 어떤 값을 넣느냐에
                따라서, JDK Dynamic Proxy를 사용하던 아니면 CGLIB을 사용하던 할 수 있다. 아니면 properties파일에 spring.aop.proxy-target-class=~ 를 적어넣고, ~에 false나 true를
                써넣어서 적용시킬수도 있다.(물론, 스프링이나 스프링부트 둘다 직접해보진 않았다. 또한, 스프링은 CGLIB 속성값 true를 넣었을때 이게 CGLIB인지 검증은 하지 않았다. 나중에 필요시 
                직접 더 자세하게 보면 될것같다.) 예를 들면, 스프링에서는 @Configuration이 붙은 클래스 파일에 @EnableAspectJAutoProxy(~)를 적어넣어서 이 ~ 안에 proxyTargetClass의 값을 설정하여 
                동적프록시 혹은 CGLIB을 사용하게 할 수 있다. 물론 스프링에서는 이 기본값이 false로 되어있어서 JDK Dynamic Proxy가 기본으로 사용되게 되있다. 이걸 true로 지정하게 되면, CGLIB을 
                사용한다고 한다.(여기서 실제로 CGLIB이 사용되는지는 확인 안해봤으나 나중에 필요시 다시 봐보도록 하자.) 또한, 이 proxyTargetClass의 값이 false로 되어있더라도 만약에 인터페이스가 
                존재하지 않는다면 자동으로 CGLIB을 사용해서 프록시 객체를 만들어준다고 한다.(여기도 실제로 CGLIB이 사용되는지는 확인안해봤으나 나중에 필요시 다시 봐보도록 하자.)
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy] / 설정파일 @Configuration에서 @EnableAspectJAutoProxy(proxyTargetClass = ~)로 설정한다 & JDK Dynamic Proxy사용을 기본으로 두더라도 인터페이스가 없는 경우는 CGLIB Proxy를 사용한다고 한다.     
                [참조링크 : https://dreamchaser3.tistory.com/9] / JDK Dynamic Proxy사용을 기본으로 두더라도 인터페이스가 없는 경우는 CGLIB Proxy를 사용한다고 한다.         
                [참조링크 : https://mio-java.tistory.com/44] / @EnableAspectJAutoProxy(proxyTargetClass = ~)를 이용하여 동적프록시 사용할지 CGLIB사용할지 정함    
                [참조링크 : https://seungwoo0429.tistory.com/26] / properties파일로도 spring.aop.proxy-target-class=~ 로도 설정이 가능하다.
                +
                스프링부트에서는 기본적으로 디폴트 설정이 proxyTargetClass가 true로 되어있다. 그러나, 설정파일 즉, @SpringBootApplication이 붙은 main 클래스가
                설정파일일텐데, 물론 여기에서 자동으로 @EnableAspectJAutoProxy설정을 해주지만, 또 따로 이 주석을 써주어서 @EnableAspectJAutoProxy(proxyTargetClass = ~)
                이렇게 주석 속성값을 넣어줄 수도 있나보다. 그렇게 proxyTargetClass의 값을 false로 해주어도 이 기본 proxyTargetClass의 값이 true인것은 바뀌지 않는다. 만약
                이걸 바꿔주려면, properties에서 spring.aop.proxy-target-class=false를 따로 명시해주어서 적어주어야만 적용되는것으로 알 고 있다. 여기서 실제로 properties파일까지 설정
                을 spring.aop.proxy-target-class=false까지 해보면서 적용은 안해봤지만 @SpringBootApplication이 있는 클래스 파일에서 @EnableAspectJAutoProxy(proxyTargetClass = false)
                로 했는데 변경되지 않은것은 직접 해봤다. 만약에 나중에 properties파일로 변경해서 사용해야 할 때 있으면 그때 또 다시 정리하자.
                [직접해봄]    
                [참조링크 : https://github.com/spring-projects/spring-boot/issues/12194] / 스프링부트 2.0부터는 CGLIB이 디폴트이며, @EnableAspectJAutoProxy와 @EnableTransactionManagement 같은 주석을 사용해서 그 값을 바꿀 수 없다고 한다.     
                [참조링크 : https://github.com/spring-projects/spring-boot/issues/12194] / 그래서, properties 파일에 spring.aop.proxy-target-class=~를 적어주면 ~에 따라 값이 변경된다고 한다.
                [참조링크 : https://stackoverflow.com/questions/55853108/spring-boot-2-forces-cglib-proxy-even-with-proxytargetclass-false] / 여기서도 properties파일에 spring.aop.proxy-target-class=~를 적어주면 설정값을 바꿀 수 있다고 나온다.    
                [참조링크 : https://eminentstar.tistory.com/76] / 스프링부트는 기본설정이 CGLIB이다.
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy] / 스프링부트는 기본설정이 CGLIB이다.
                +
                여기는 스프링부트에 관해서만 나와있기는 한데, spring.aop.proxy-target-class=~에서 ~값에 true가 들어가면 CGLIB이 기본설정이고
                아니면 ~에 false가 들어가면 동적프록시가 기본 설정이라고 나와있다. 아마 스프링도 이와 별반 다르지 않을것같다.
                [참조링크 : https://hyunsoori.tistory.com/11]    
                +
                약간 다른 얘기긴 한데, 여기서는 주석에 속성값 넣어줄떄 ""를 안붙이고 하네
                [직접해봄]    
            (3).동적프록시는 자바의 Reflection을 사용하기 때문에 바이트코드를 조작하여 상속을 하여 
                프록시 객체를 생성해주는 CGLIB 보다는 성능이 좋지 않다고 한다.
                [참조링크 : https://huisam.tistory.com/entry/springAOP]     
                [참조링크 : http://wonwoo.ml/index.php/post/1708]     
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy]            
            (4).그것도 정리해야해, @mapper가 붙은 mapper인터페이스를 스프링부트에서 포인트컷으로 해당 인터페이스의 메서드를 설정하였는데, 실제로 스프링부트 시작하기
                초록책 책에 나오는 boardServiceImpl 클래스의 멤버변수 BoardMapper형에 들어가는 프록시의 종류는 JDK Dynamic Proxy인 동적프록시가 들어갔었다. 이를 실제로
                확인했었는데 그 이유를 간략하게 정리하겠다. 물론 이는 mapper인터페이스에서 구현체가 어떻게 만들어지는지에 기반을 해서 내가 이해하기 쉽게 정리한거지 실제로는
                조금 다를 수도 있다. 우선, 이 @mapper가 붙은 인터페이스형의 변수에 대입되는것은 이 인터페이스의 구현체일텐데 이것또한 런타임 동적로딩으로 구현체 객체가 만들어져서
                변수에 대입이 되는것일거다. 그러면, 먼저 @mapper가 붙은 인터페이스형의 구현체 객체가 먼저 생성이 되고 CGLIB의 경우 이 구현체형의 객체를 빈으로 등록하지 못하게 막고, 
                대신에 CGLIB 프록시 객체가 들어가며, @mapper가 붙은 인터페이스형이면서 자동형변환하는 이 구현체 객체 대신에 CGLIB객체가 들어갔을텐데(이 매퍼 인터페이스의 구현체는 
                @Component로 빈이 등록되는것으로 알고있다.) 어떠한 이유로 안되는것같다. 내 생각에 애초에 구현체 객체의 바이트코드를 조작해야하는데, 이 구현체 객체를 만들때 
                이 객체자체의 바이트코드가 아예 없거나 아니면 다른 형식의 바이트코드여서 안되는걸 수도 있다는 생각이 든다. 그러니까 이 구현체 객체가 생성이 되고 동적프록시를
                사용해서, 매퍼 인터페이스를 구현하는 것으로 만들으며, 멤버변수는 아무것도 넣지 않고 각각의 메서드를 오버라이드해서 포인트컷이 지정안된 메서드는 단순히 대상객체의
                해당하는 메서드를 호출하게 하고, 포인트컷에 해당하는 메서드는 Aspect클래스 빈의 해당하는 어드바이스 메서드를 호출하게 만들어서 이 동적 프록시 객체를 매퍼인터페이스형이면서
                구현체객체를 자동형변환하게 되는 빈으로 등록하게 되어, 실제 BoardMapper 인터페이스형(스프링부트 시작하기 초록책에 나옴)에 이 동적프록시 객체가 대신 사용되고 들어가게 되는거다.
                (당연히, 매퍼인터페이스의 구현체 객체는 직접적으로 사용하지 못한다.)
                [직접해봄]    
            (5).위빙(weaving)의 뜻에 대해 먼저 알아보고 가겠다.
                아래 참조링크들과 참조문헌을 보면, 첫번째 참조링크에서 위빙은 포인트컷으로 지정한 핵심 비즈니스 로직을
                가진 메소드가 호출될 때, 어드바이스에 해당하는 공통기능의 메소드가 삽입되는 과정을 의미한다고 했다(이건 런타임 위빙). 또한, 두번째
                참조문헌에서는 Advice를 핵심 로직 코드에 적용하는 것을 weaving이라고 했다. 세번째 참조링크를 보면, 공통기능과 핵심기능을
                linking을 하는 과정이 AOP의 Weaving(위빙)이라고 나와있다. 하지만, 이거를 있는 그대로 이해하려면 어려우니 이렇게 생각하면 된다.
                핵심코드가 있는 자바파일이나 클래스 파일에 공통기능 코드를 핵심기능 소스코드에 직접적으로 삽입시키거나(컴파일 시점 위빙, 로드 시점 위빙(클래스 로딩 시점 위빙)), 
                아니면 프록시 객체를 생성하는 방식에서, 포인트컷으로 지정한 핵심 비즈니스 로직을 가진 메소드가 호출될 때 공통기능과 핵심기능이 적용되어서 연동되는 과정을 위빙이라고
                보면 될것같다.(그러고나서 프록시 객체가 생성되는것은 위빙이라고 보기 어려울것같다.)
                [참조링크 : https://sa1341.github.io/2019/05/25/%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B0%9C%EB%85%90-%EB%B0%8F-Proxy%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B5%AC%EB%8F%99%EC%9B%90%EB%A6%AC/]    
                [참조문헌 : 스프링5 159pg]       
                [참조링크 : https://ehdvudee.tistory.com/22]   
                [참조문헌 : 스프링5 158pg] / 여기에도, 컴파일 시점 위빙과 클래스 로딩 위빙 그리고 런타임 위빙에 대해 나와있다.
                [참조링크 : https://logical-code.tistory.com/118] / 여기서 컴파일 시점 Weaving에서 설명을 보면 'Weaving된 class 파일' 이라 말하는것 보니, 공통기능 소스 코드가 핵심 로직 코드에 입력혹은 삽입되는것을 위빙(Weaving)이라는걸 알 수 있다.
                [참조링크 : https://logical-code.tistory.com/118] / 컴파일 시점 위빙, 로드 시점 위빙(클래스 로딩 시점 위빙)에 대해 나와있고, 컴파일 전 위빙도 여기 링크에 나와있지만 이건 나중에 필요시 다루기로 하자.
                [참조링크 : https://dahye-jeong.gitbook.io/spring/spring/2020-04-10-aop-aspectj] / 런타임 위빙에 관한 설명이며, 런타임시에 포인트컷으로 지정한 메서드가 호출시에 일어나느 위빙이라고 한다.
                [참조문헌 : 스프링부트 시작하기 초록책 106pg] / 여기서도 컴파일 시점 위빙이나, 로딩 위빙(클래스 로딩)은 공통기능 코드가 핵심기능 코드사이에 직접적으로 삽입된다고 나와있다.
                +
                아래 Spring AOP와 AspectJ에 대해 설명하는거에 나올텐데, Spring AOP는 런타임 Weaving(위빙)만을 지원하고,
                AspectJ 의 경우, 컴파일 전 위빙, 컴파일 시점 위빙, 로드 시점 위빙(클래스 로딩시)의 3가지 위빙방식만을 지원한다.
                이는 아래 참조문헌에도 나와있으며, 단, 책에서는 컴파일 전 위빙은 안나와있다.
                [참조링크 : https://logical-code.tistory.com/118] / AspectJ 지원 위빙 3가지 방식
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy] / 스프링 AOP는 런타임 위빙만 지원
                [참조링크 : https://logical-code.tistory.com/118] / 스프링 AOP는 런타임 위빙만 지원
                [참조문헌 : 스프링 158pg]       
                +
                아래 참조링크에 런타임 위빙은 Aspect 대상 객체의 프록시를 사용하는 애플리케이션의 실행 시에 위빙된다고 나와있다. 즉,
                말 그대로 런타임 중에 위빙이 되는거다.
                [참조링크 : https://logical-code.tistory.com/118]    
                +
                런타임 위빙의 경우 런타임 위빙이 일어나더라도, 실제로 소스파일이나 클래스 파일에는 전혀 변화가 없다고 한다
                [참조링크 : https://wjdtn7823.tistory.com/m/64]    
                +
                로드 시점 위빙은 클래스파일이 바이트 코드로 되어있어서 바이트코드를 조작하는 방식인것이다.
                [참조링크 : https://jaehun2841.github.io/2018/07/22/2018-07-22-spring-aop4/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%93%9C-%EC%8B%9C-%EC%9C%84%EB%B9%99-ltw-load-time-weaving]    
            (6).Spring AOP와 AspectJ에 대해 설명하도록 하겠다.
                스프링에서 AOP기능을 제공하는데, 그것이 바로 스프링 AOP이다.(아래 @EnableAspectJAutoProxy도 스프링AOP 기능에 포함된다고 본다, 비록
                (6).에서 보이는 실질적인 spring-aop와 spring-context처럼 모듈은 다르지만 말이다.) 즉, 스프링 안에서 할 수 있는 간단한 AOP구현만 제공하는것이다.
                즉, 완전한 AOP를 의도한것이 아니다. 반면에 AspectJ는 완전한 AOP를 제공하는 것이 목적으로써, 근원적으로 AOP를 완벽히 지원하기위한 것이다.
                [참조링크 : https://logical-code.tistory.com/118]   
                [참조링크 : https://gmoon92.github.io/spring/aop/2019/02/09/why-used-aop.html] / 스프링에서 제공하는 AOP란 스프링 AOP를 의미 
                +
                스프링 AOP에서는 런타임 위빙만을 지원하며, 이는 즉 런타임 위빙을 사용한다는것은 프록시 객체를 생성해서 사용한다는 말과같다. 
                또한, 추가로 Spring AOP는 메소드 실행에 대한 JoinPoint만 제공한다.
                [참조링크 : https://logical-code.tistory.com/118]    
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy]    
                +
                AspectJ는 런타임 위빙은 지원하지않고, 컴파일 시점 위빙, 컴파일 전 위빙, 로드 시점(클래스 로딩) 위빙만을 지원한다.
                반대로 Spring AOP는 런타임 위빙만을 지원하는거다. 그렇기에, CGLIB이나 JDK Dynamic Proxy모두 프록시 객체를 생성하기에 스프링AOP를
                적용하는것이며 둘다 런타임 위빙을 사용한 Spring AOP로 구현되는것이다.
                [참조링크 : https://logical-code.tistory.com/118]    
                +
                그렇다면, 스프링 AOP만 이용하면 될것을 왜 AspectJ에 대한 의존성까지 추가하면서 이용하는 이유가 뭘까.
                바로, 두번째 참조링크에서 보듯이 스프링AOP에서 제공하기 힘들거나 아니면 더 효율적인 방안을 사용하기 위해, 
                AspectJ에 대한 의존성을 추가하고 사용하는것같다. 우선 눈에 보이는 코드로는 Aspect클래스에서 쓰이는 @Aspect, @Around,
                @Pointcut과 Signature, ProceedingJointPoint의 사용의 경우다. 추가로 첫번째 참조링크를 보면, 스프링 AOP는 이러한 AspectJ의
                어노테이션을 사용하더라도, 잘 AOP가 구현될수 있도록 구현방식을 제공하고 있다고 한다.
                [참조링크 : https://gmoon92.github.io/spring/aop/2019/02/09/why-used-aop.html]    
                [참조링크 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy]        
                +
                스프링 AOP는 첫번쨰 참조링크를 보면 메서드 실행 포인트컷(Pointcut)만 지원한다고 나와있다. 그리고 AspectJ의
                경우에는, 모든 Pointcut을 지원한다고 나와있다. 그런데, 여기서 짚고 넘어가야할것이 조인포인트(JoinPoint)가 아래 개념을
                보면 알겠지만, Advice를 적용 가능한 지점을 의미하며, 그 예시로는 메서드 호출이나 필드 값 변경 혹은 여러가지 지점들이 있다.
                그 중에 실제로 Advice가 적용되는 지점을 Pointcut(포인트컷)이라고 하는거다. 그렇기에, 여기서 메서드 실행 포인트컷만 지원한다라고 적혀
                있는것에서 메서드 실행 조인포인트만 지원한다고 해도 같은말로 볼 수 있는거다. 실제로 두번쨰 참조링크에서는 조인포인트로 표현했다.
                [참조링크 : https://logical-code.tistory.com/118]    
                [참조문헌 : https://tram-devlog.tistory.com/entry/Spring-AOP-weaving-proxy]     
            (7).@EnableAspectJAutoProxy에 대해서도 함꼐 정리하도록 하겠다.  
                이 주석은, 아래 (5).에서도 나와있지만, spring-aop모듈과 사용되는 모듈이 조금 다르다. 그러나 이 @EnableAspectJAutoProxy도 스프링AOP 기능의 
                일부분이라고 여기는게 맞는것 같다. 이 주석의 기능은, 첫번째 참조문헌에서는 프록시 생성과 관련된 객체를 빈으로 등록한다고 나와있고,  두번째 참조링크
                에는 위에서 포인트컷으로 지정된 메서드를 호출시에 가로챌 수 있게 해주는 옵션이라고도 하고 마지막 세번쨰 참조링크에서는, AspectJ의 기능을 가져다
                쓰는데, 이 AspectJ의 기능을 사용할 수 있게 해준다고 한다. 이것도 나중에 구체적으로 알아야 하면 그때 다시 정리하도록 하고 여기서는 간단하게 정리해서
                사용되는 스프링AOP 기능과 AspectJ의 일부 기능들이 정상적으로 작동하게 해주는 주석이라고 이해하면 될것같다. 이 주석을 쓰지 않는다면 정상적으로 작동하지
                않는다.
                [직접해봄] / 이 주석을 빼고 스프링 프로젝트에서 사용했더니 AOP가 정상작동하지 않았다.   
                [참조문헌 : 스프링 163pg]  
                [참조링크 : https://jeong-pro.tistory.com/171]       
                [참조링크 : https://araikuma.tistory.com/309]    
                +
                추가로 @EnableAspectJAutoProxy에 대한 이해를 할 필요가 있는데, 이 주석은 이 @Aspect 주석을 붙인 클래스를
                빈으로 등록하려는 설정파일에 붙여야 하는 주석이다.(@ComponentScan과 @Component으로 빈을 등록하는 설정파일이던, 아니면
                직접 @Bean으로 설정파일에 코드를 작성하여 빈으로 등록하려는 설정파일이던) 아래 스프링 163pg의 참조문헌에 보면, @EnableAspectJAutoProxy에
                대한 기능얘기가 나오는데, 이것정도는 인지하고 왜 빈으로 등록한 설정파일에 적어줘야하는지로만 알고있자. 추가 기능이란, 이 @EnableAutoConfiguration주석을
                붙이면, 빈으로 등록한 것중에 @Aspect 애노테이션이 붙은 빈 을 찾아서 해당 빈 객체의 @PointCut설정과 @Around설정을 사용한다고 한다.(책에서도 빈 객체를 찾는다고
                나와있는데, 등록된 빈 객체 즉, 만들어진 객체를 찾는것으로 이해해도 될 것 같다. 이 부분 나중에 정확히 알아야 할 시에 다시 정리하도록 하자.)
                또한, @Component으로 @Aspect를 붙인 클래스를 빈 등록한 설정파일에서 직접해보았고, 이 설정파일에 @EnableAutoConfiguration를 안쓰니 정상작동하지 않았다.
                그리고 @Bean을 사용한 경우에도 직접은 안했지만 아래 참조문헌 163pg를 보면 똑같이 @Bean으로 빈 등록한 설정파일에 @EnableAutoConfiguration를 사용하고있다.
                [직접해봄]    
                [참조문헌 : 스프링 163pg] / 설정파일에 붙여주어야 한다.   
                [참조문헌 : 스프링부트 시작하기 초록책 107pg] / 여기는 Application 클래스에 @SpringBootApplication 주석에서 이러한 작동을 한다.
                +
                스프링부트에서는, 아래 첫번째 참조링크를 참고하면 @SpringBootApplication주석을 사용하게 되면, @EnableAutoConfiguration 주석을
                포함하게 된다. 근데 자동설정 주석을 사용하면 @Conditional타입의 주석인 @ConditionalOnClass와 @ConditionalOnPropery 주석을
                사용하게 되는데, 이 중에 @ConditionalOnClass는 AOP같은것을 실행시키기 위해 필요한 클래스들을 알아서 클래스패스에서 보고
                추가하게 된다고 한다. 참조링크를 보면, EnableAspectJAutoProxy.class도 추가된것을 볼 수 있다. 이렇게 사용하게 된다면,
                마치, @EnableAspectJAutoProxy 주석을 직접 사용한것과 동일하게 작동한다고 한다. 그렇기에 스프링부트 프로젝트에서는
                Application클래스(스프링부트에서는 이게 설정파일이다.)에서 @SpringBootApplication에 따로 
                @EnableAutoConfiguration를 추가하지 않아도 된다고 한다.
                [참조링크 : https://stackoverflow.com/questions/48625149/spring-aop-works-without-enableaspectjautoproxy]    
                [참조링크 : https://blog.junu.dev/38] / 스프링부트 사용시에 @EnableAspectJAutoProxy 따로 안써줘도 됨   
            (8).이 @EnableAspectJAutoProxy라는 주석은 스프링의 org.springframwork:spring-context모듈에서 갖고오는 주석이다.(스프링부트는 해당 스프링부트
                의존성 추가시 이 org.springframework:spring-context모듈이 다 포함되어있다.) 또한, 나머지 Aspect 클래스에서 사용되는 주석인 @Aspect, @Around, 
                @PointCut과 ProceedingJoinPoint 그리고 Signature를 사용하는 경우에는 모두 org.aspectj:aspectjweaver 모듈에서 갖고온 것들로만 사용하게 된다. 
                그리고 org.springframework:spring-aop 모듈은(org.springframework:spring-context모듈 하위에 있는) 직접적으로
                사용되어지는 코드가 보이진 않는다.
                [직접해봄]              
            (9).Advice(어드바이스), joinpoint(조인포인트), Pointcut(포인트컷), Weaving(위빙), Aspect(어스펙트)의 용어 정리
                1.Aspect
                    첫번쨰 참조링크에서는 흩어진 괌심사를 모듈화 한것이라 나오고, 두번째 참조링크에서는 여러 객체에 공통적으로
                    적용되는 관심 사항을 Aspect라고 한다. 마지막으로 세번째 참조문헌에서는 그냥 여러 객체에 공통으로 적용되는 기능을 Aspect
                    라고 한다고 한다. 트랜잭션이나 보안 등이 Aspect의 좋은 예라고 한다. 즉, 정리해봤을때 코드로 보기보다는 말 그대로 공통적인
                    기능이라고 보고 이해하면 될 것 같다. 또는 공통적인 기능을 모듈화한것 이라고도 볼 수 있을것같다. 두가지 기준으로 보는게 나을듯 하다.
                    추가로 마지막 네번째 참조문헌에 보면, Aspect는 한 개 이상의 포인트컷과 어드바이스의 조합으로 만들어져있다고 하는데, 
                    이는 Aspect를 공통적인 기능을 모듈화한 개념으로 적용해서 생각하면 될 것 같다.
                    [참조링크 : https://engkimbs.tistory.com/746]     
                    [참조링크 : https://logical-code.tistory.com/118]    
                    [참조문헌 : 스프링5 159pg]    
                    [참조문헌 : 스프링부트 시작하기 초록책 106pg]
                    +
                    Aspect로 사용할 클래스에 @Aspect를 붙인다고 한다. 이 @Aspect 주석의 경우 해당 클래스가 공통기능을 모듈화한
                    클래스라는 것을 알려주는 주석이라고 한다. 즉, Aspect클래스라는것을 알려주는 주석이다. 이 @Aspect가 붙었다고 해서 
                    자동으로 빈으로 등록되는것은 아니니, @Component를 붙여주거나 직접 설정파일에서 빈을 등록해주어야 한다. 두번째 참조링크에서도 
                    @Aspect 주석을 붙이는것 자체가 이 클래스가 Aspect를 나타내는 클래스라는 것을 명시한다고 한다. 즉, 좀 더 자세하게 설명하자면, 위의 @EnableAspectJAutoProxy 주석에 대한
                    기능을 보면, 스프링 프로젝트 실행시에 @Aspect가 붙은 클래스의 빈이 생성이 되어서 등록이 될거다.(아마, 자동으로 생성되는것으로 이해. 또한
                    이것이 스프링에서 AOP의 시작이라고 봐도 될듯 하다.) 그리고나서, @EnableAspectJAutoProxy의 기능중 하나라고 봤듯이 등록된 빈 중에
                    @Aspect가 설정이 된 빈을 찾아서 해당 빈의포인트컷에 대한 설정과 @Around의 사용을 위한 기본 설정이 되는것으로 사용이된다고 한다.
                    즉,
                    정리하자면, @Aspect를 붙이는것은 해당 클래스를 공통기능을 가진 클래스로 알리고 사용된다는 것이다.
                    또한 마지막 참조문헌에 보면, @Aspect 애노테이션을 적용한 클래스는 Advice와 포인트컷을 함께 제공한다고 한다.
                    [참조링크 : https://galid1.tistory.com/498]    
                    [참조링크 : https://engkimbs.tistory.com/746]         
                    [참조문헌 : 스프링5 161pg]     
                    +
                    Aspect로 사용되는 클래스 혹은 Aspect 클래스를 같은것으로 보고 
                    위에서 보았듯이, Aspect의 개념중 하나인 공통기능을 모듈화한
                    클래스라고 이해하면 될것 같다.
                    [참조문헌 : 스프링5 160pg]                 
                2.Weaving
                    위빙은 위에 정리해 놓았다.
                3.Advice
                    첫번쨰 참조링크에는 어드바이스(Advice)란, 타겟에 제공할 부가기능을 담고 있는 모듈이라고 한다. 두번째 참조링크에는
                    여기서도 실질적인 부가기능을 담은 구현체라고 적어놓았다. 세번째는 JointPoint에 삽입되어서 동작할 수 있는 코드라고 나와있다.
                    즉, 여기서 부가기능이란 공통기능을 의미하고, 실질적인 공통기능에 대해 적힌 코드 라고 봐도될듯 하다. 마지막 네번째 참조문헌에
                    보면, 여기서만 마치 공통기능을 '언제' 적용할지로 언제라는 개념으로 어드바이스를 설명하고 있지만, 그다음 160pg를 보면, 언제라는
                    의미를 담은 단어들은 따로 붙이는것으로 보아, 그냥 직관적으로 이해하기위해, 실질적인 공통기능을 구현한 코드 라고 이해하는게 맞는것같다.
                    '언제'(메서드 호출전, 메서드 호출후 ...)라는 개념은 그 단어에서 포함된다고 이해하자. 아니면, 공통기능의 구현체라고 이해해도 될것같다.
                    [참조링크 : https://shlee0882.tistory.com/206]    
                    [참조링크 : https://engkimbs.tistory.com/746]    
                    [참조링크 : https://atoz-develop.tistory.com/entry/AspectJ-Weaver%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%95%A0%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95]                  
                    [참조문헌 : 스프링5 159pg]    
                3.Joinpoint
                    첫번쨰 참조링크를보면, 어드바이스를 적용할 수 있는 위치를 말한다고 한다. 두번째 참조링크를 보아도, Advice가 적용될 수 있는
                    위치를 의미하며, 메서드 진입 지점, 생성자 호출 시점 등등이 있다. 마지막으로 세번째 참조문헌에도 Advice를 적용 가능한 지점을 의미한다고
                    나와있다. 추가로 스프링AOP에서는 메서드 조인포인트 혹은 포인트컷만 지원한다는 내용은 위에 스프링AOP에 대한 설명에 정리해 놓았다.
                    즉, 의미를 정리하자면, 말 그대로 Advice를 적용 가능한 지점이라고 생각하면 될것같다.
                    [참조링크 : https://shlee0882.tistory.com/206]    
                    [참조링크 : https://engkimbs.tistory.com/746]    
                    [참조문헌 : 스프링5 159pg]    
                4.Pointcut
                    포인트컷(Pointcut)에 대해 각기 다르게 정의해놓았는데, 그 두가지가 바로 아래 두가지다.
                    (1).첫번째는 Joinpoint의 부분 집합으로 볼 수 있는데, 실제 Advice가 적용되는 joinpoint(조인포인트)를 나타낸다고 한다.
                        첫번째 참조문헌에서 이렇게 말했다. 두번째 참조링크는, 다양한 JoinPoint(조인포인트)중에 어떤것을 사용할지 선택이라고
                        나와있다. 즉, 이런걸로 보아 Pointcut은 실제로 Advice가 적용되어 사용되는 joinpoint라고 이해하면 될것같다.
                        추가로, @Pointcut처럼 Aspect클래스에 쓰이는것이 있는데, 이러한 주석사용들에 대해서는 따로 정리하도록 하자.
                        용어와 주석에 대해서는 조금 다르게 이해할 필요가 있다.
                        [참조문헌 : 스프링159pg]    
                        [참조링크 : https://atoz-develop.tistory.com/entry/AspectJ-Weaver%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%95%A0%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B0%98%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95]    
                    (2).두번째 의미로는 스프링부트 시작하기 초록책에서는 포인트컷(Pointcut)이란, 어드바이스를 적용할 조인포인트를
                        선별하는 과정이나 실제 그 기능을 정의한 모듈을 의미한다고 한다. 여기서는 조인포인트를 선발한다고 했는데, 스프링 AOP는
                        메서드 조인포인트만 제공하지만, 여기서는 여러종류의 조인포인트를 제공되고, 그 중에 고른다고 여겨지는것같다. 또한,
                        조인포인트를 선별하는 과정 혹은 실제로 이 기능을 정의한 모듈을 의미하는것같다.
                        [참조문헌 : 스프링부트 시작하기 초록책 106pg]    
                    +
                    @Pointcut에 대하여
                    위에서 설명한 두번째 개념을 적용하여, 이 주석을 쓰는건, 어드바이스를 적용할 
                    조인포인트를 선별하는데 그것을 정의한 모듈 즉, 포인트컷을 설정하는데 필요한 주석이다. 설정하는 방법은
                    @Pointcut("~")
                    private void ~() {}
                    와 같이 사용하게 된다. 여기서 ~에 포인트컷을 표현할 수 있는 명시자를 넣는것이며 넣을 수 있는 명시자는 execution,within,bean등이
                    있으며, 보통 execution 명시자를 가장 많이 사용한다고 한다. 추가 내용이지만, 보통 주석에 속성값을 넣는다고 하면 내가 본것들은 전부
                    주석에 속성값을 넣는다 할 때 이 "" 큰 따옴표를 붙여서 넣어 주었었다.(이 부분 다른부분 있는 경우 그때가서 다시 정리)
                    또한, 만약 이 방법을 사용한다면, 메서드를 만들어주어서 거기에다가 주석을 적용하는건데, 이때 먼저 알아야 할것이 본래
                    포인트컷을 설정하는것은 @Around주석의 속성값에서 설정하는것으로 보인다.(다를 경우 나중에 다시보기) 아래 @Around 속성값을
                    이용하여 포인트컷을 설정하는것도 그렇고, 만약에 여기 메서드를 이용하여 @Pointcut으로 사용하는 경우에 결과적으로, @Around
                    주석에 해당 메서드를 호출해서 적용한다.(예시. @Around("메서드()"))(여기서 짚고 넘어가야 할게 있다면, 스프링부트 시작하기 초록책
                    45pg에 보면, 설정파일에서도 메서드() 이런식으로 사용하는데, 여기서는 이를 호출이라 생각했다. 앞으로 그렇게 생각해도 상관없을것
                    같다. 또한, 여기서도 이 @Around의 속성값에 @Pointcut 메서드를 적용하여 이 메서드를 실행하는것도, 실행이라고 본다. 지금까지 이
                    두 부류만 실행이라고 보긴한다. 내가 본게 이것이 다다.)
                    그래서, @Around에 따로 명시자값을 적어주지않고 @Pointcut이 적용된 메서드를 실행해주는 값을 넣게되면, 자동으로 @Pointcut 속성값의 
                    명시자가 @Around 속성값에 적용되는것으로 보인다. 즉, 기존의 메서드 실행해서 반환값주는것이랑은 조금 다른것으로 보면 된다. 또한, 해당 @Pointcut에 대한
                    메서드에 자세하게 본다면, private을 쓰는데가 있고, public을 쓰는데가 있는데, 내생각에 이거는 @Around의 속성값에서 호출하기 위함, 즉
                    같은 영역안에서 호출하게 되는거니 private이나 public이나 상관없는거 같다. 실제로 아래 참조링크를 보더라도 어디는 private 혹은 public
                    가 쓰이는것을 확인할 수 있다. 근데, 나는 왠지 private을 쓰는걸 더 선호할 것 같다. 그다음은 반환형에 대해서인데 반환형은 void를 그대로
                    전부 사용하고 있었다. 이 부분은 반환하는 값도 없고 반환하는것에대해 쓰이지도 않으니 전부 void로 해놓은것같다. 그리고 마지막으로는 메서드
                    이름인데, 이는 임의로 정해놓은것 같다. 즉, 적당히 지으면되는것 같다.
                    [직접해봄]    
                    [참조링크 : https://galid1.tistory.com/498] / 포인트컷을 설정하여 사용하는 방법 2가지
                    [참조문헌 : 스프링부트 시작하기 초록책 109pg] / 포인트컷을 표현할 수 있는 명시자에는 여러 종류가 있고 일반적으로 execution을 가장 많이 사용한다고 한다.
                    [참조문헌 : 스프링5 161pg] / private사용
                    [참조링크 : https://github.com/madvirus/spring5fs/blob/master/sp5-chap07/src/main/java/aspect/ExeTimeAspect.java] / private사용
                    [참조링크 : https://seypark.tistory.com/105] / public사용        
                    +
                    만약 @Pointcut을 쓰지 않고 포인트컷을 설정하고 싶다면, @Around의 속성값으로 바로 위의 포인트컷을 표현하는 명시자들을
                    적어주면 된다. 이는 포인트컷을 설정하는데 필요한 주석인 @Pointcut을 사용하지 않고, 포인트컷을 설정하는 방법으로 다른 예시들을
                    보았을때, @Pointcut에 들어갈 명시자 속성값을 그대로 @Around 속성값에 명시자를 적어주면 되는것같다. 여기서는 포인트컷을 설정하는
                    방법중에 어떠한 방법이 더 좋다는 나와있지 않다. 그러나 하나의 포인트컷을 여러 종류의 Advice(어드바이스)에 적용시키기 위해 따로
                    @Pointcut을 사용하여 적용하는것 같다. 아래 참조링크를 봐도 사용을 그렇게 하고 있다. 만약에 하나의 어드바이스에만 포인트컷을
                    적용하는것이라면 굳이 @Pointcut을 사용할 이유는 없어 보인다.
                    [참조링크 : https://galid1.tistory.com/498] / 포인트컷을 설정하는 또 다른 방법    
                    [참조링크 : https://velog.io/@geunwoobaek/3AOP%EB%9E%80] / @Pointcut을 사용하지 않고 @Around로 포인트컷 설정가능   
                    [참조링크 : https://owin2828.github.io/devlog/2019/12/30/spring-7.html] / @Pointcut을 사용하지 않고 @Around로 포인트컷 설정가능
                    [참조링크 : https://galid1.tistory.com/498] / @Around를 이용한 예시
                    [참조링크 : https://owin2828.github.io/devlog/2019/12/30/spring-7.html] / @Around를 이용한 예시, @Pointcut을 사용하지 않고 @Around로 포인트컷 설정가능        
                    [참조링크 : https://seypark.tistory.com/105] / @Pointcut을 사용하여, 여러 어드바이스에 적용하고 있다.
                    +
                    이 명시자에는 and와 or을 사용할 수도 있는데(&&와 ||로도 사용가능), and가 의미하는것은 적어놓은 명시자들을 모두 만족하는것만
                    포인트컷으로 지정하고 or이면 각각의 명시자들에 해당하는 것들을 모두 포인트컷으로 지정한다는 말이다. 예시의 경우는 아래의 참조문헌과
                    참조링크를 보도록 하자.
                    [참조문헌 : 스프링부트 시작하기 초록책 107pg] / or사용예시    
                    [참조문헌 : 스프링부트 시작하기 초록책 110pg] / or,and에 대한 내용   
                    [참조링크 : https://javawork.tistory.com/entry/Spring-pointcut-%ED%91%9C%ED%98%84%EC%8B%9D-2] / or,and에 대한 내용, &&, || 사용예시   
                    +
                    위에서, 다시한번 포인트컷이 무엇인지 정리하자면, 이 execution, within, bean을 포인트컷을 표현할 수 있는 명시자라고 했다.
                    즉, 이 명시자로 적은 부분들이 포인트컷으로 보면 되는것이다. 이를 첫번째 참조문헌에 정리해 놓았고(참조문헌에 보면, 포인트컷을 표현할 수 있는 명시자는
                    여러개(execution, within, bean 3개만 있는것으로 봐도 될것같다. 나중에 다를시에 다시 정리, 아무리 검색해도 이 3가지 밖에 안나왔다.)가 되는것 같지만, 
                    제일 많이 쓰이는게 execution이고 그 밖의 within, bean이 있는것으로 보인다. 아래 명시자와 관련해서는 execution은 자세하게 알아보고, within, bean은 필요한 
                    만큼만 알아볼것이다.), 실제 적용되는 프로젝트에서 포인트컷을 나타내는 다른것이 또 있는데, 바로 포인트컷의 첫번째 의미인 'Joinpoint의 부분 집합으로, 
                    실제 Advice가 적용되는 joinpoint(조인포인트)를 나타낸다.' 로 해석하게 되면, 두번째 참조문헌처럼 명시자에 의해 선택되는 메서드들이 
                    포인트컷에 해당하는거다.
                    [참조문헌 : 스프링부트 시작하기 초록책 109pg]  
                    [참조문헌 : 스프링5 161pg]          
                5.추가로 Around에 대해 정리하겠다.
                    Around 자체는 Around Advice로 쓰여서 그 의미가 핵심기능 메서드의 호출 전, 후 또는 익셉션 발생 시점이나 익셉션이 발생하더라도
                    그 시점에 공통기능을 실행하는 공통기능 구현체를 의미한다. 즉 Around Advice와 함께 쓰여지는 의미로 Advice를 기억해도 될 것 같다. 그리고 @Around
                    의 의미는 앞선 Around Advice에 해당 하는 공통기능 구현체를 작성하고 이를 적용하겠다는 의미이다. 또한, @Around 주석은 다른 기능으로도 쓰이는데, 
                    두번째는 여기의 속성값에 포인트컷 설정 명시자를 적어주어서 포인트컷을 설정하는 역활을 한다는것이다.
                    [참조문헌 : 스프링5 160pg] / Around Advice의미    
                    [참조문헌 : 스프링부트 시작하기 초록책 109pg] / Around Advice의미
            (10).포인트컷 명시자에 관하여(execution,within,bean명시자)
                execution, within, bean은 모두 Advice를 적용할 메서드를 지정하는데 사용되는데, 즉 포인트컷을 지정하는데 사용되는건데,
                각각의 차이점들은 보면, 단순 명시자내의 형식만 다를 뿐 사용의 목적은 같다.
                1.execution 명시자
                    (1-1).접근제어자, 리턴타입, 클래스이름, 메서드이름, 파라미터를 설정하여, 해당되는 메서드를 포인트컷으로 지정
                        [참조링크 : https://maeryo88.tistory.com/200]     
                        [참조문헌 : 스프링5 168pg]    
                    (1-2).execution 명시자의 기본형식은 다음과 같다.
                        execution(수식어패턴(=접근제어자)? 리턴타입패턴 클래스이름패턴?메서드이름패턴(파라미터패턴))
                        여기서 알아야 할 것이 굉장히 많은데, 하나하나 살펴보도록 하겠다.
                        [참조문헌 : 스프링5 168pg]     
                    (1-3).우선, 수식어패턴부터 리턴타임패턴 그리고 마지막 파라미터패턴까지 모두 패턴이라는 이름을 붙여놓았다. 그러나 다른 참조링크를 보니
                        패턴이라는 말을 안써도 되는것 같기도 하다. 또한 참조링크를 또 보니, 메서드이름패턴에서 메서드를 뺀 이름패턴만 적던지, 메서드이름패턴에서
                        메서드와 패턴만 뺀 이름만 적던지 하는것도 있다. 이러한 표현법들이 모두 가능한것같다.
                        [참조문헌 : 스프링5 168pg] / 모두 패턴이라 적혀져있다.    
                        [참조링크 : https://seypark.tistory.com/105] / 모두 패턴이라 적혀져있다. + 위의 메서드이름패턴만 적혀있는곳에 이름패턴으로만 적혀져있다.
                        [참조링크 : https://icarus8050.tistory.com/8] / 팬턴빼고 적혀져 있다. + 위의 메서드이름패턴만 적혀있는곳에 이름만 적혀져있다.    
                        [참조링크 : https://velog.io/@shson/%EC%8A%A4%ED%94%84%EB%A7%81Spring-AOP-AspectJ-Pointcut-%ED%91%9C%ED%98%84%EC%8B%9D-1-1-execution] / 팬턴빼고 적혀져 있다. + 위의 메서드이름패턴만 적혀있는곳에 이름만 적혀져있다.           
                    (1-4).잘 보면, 어디는 수식어패턴혹은 수식어를 쓰고 어디는 접근제어자라 쓴다. 찾아보니, 자바 수식어라고 구글에 검색해보면 '수식어'만은
                        나오지않고, 항상 '접근수식어'만 검색이 된다. 세번째 참조링크에도 '접근수식어'라 나온경우다. 여기에서보면, 접근수식어와 접근제어자를
                        같은 의미로 쓰고있다. 즉, '수식어'만 쓰는경우 '접근수식어'로 이해하고 이를 '접근제어자'와 같은 의미로 보면 될 것 같다.(틀릴 경우 나중에
                        다시 정리하기) 또한 수식자라는것도 있는데, 이건 나중에 필요시 정리하도록 하자.
                        [참조문헌 : 스프링부트 시작하기 초록책 109pg] / 수식어패턴 아니면 수식어 말고 접근제어자라고 쓰고있다.    
                        [참조링크 : https://galid1.tistory.com/498] / 수식어패턴 아니면 수식어 말고 접근제어자라고 쓰고있다.   
                        [참조링크 : https://01092090536.tistory.com/153] / 접근수식어와 접근제어자를 혼용해서 쓰고있다.  
                    (1-5).아래 첫번쨰 참조문헌과 두번째 참조인 참조링크에는 명시자 기본 형식에서 ?를 사용함으로써 생략가능 여부를 표현했다.
                        그러나, 아래 세번째 참조인 참조링크를보면 []로 생략가능 여부를 나타내게 하기도 했다. 만약 틀린 부분이 있다면 그때가서
                        다시 정리하도록 하자. 
                        [참조문헌 : 스프링5 168pg] / ?로 생략가능 여부를 적어놓았다. 
                        [참조링크 : https://seypark.tistory.com/105] ? 로 생략가능 여부를 적어놓았다.    
                        [참조링크 : https://icarus8050.tistory.com/8] / []로 생략가능 여부를 적어놓았다.   
                    (1-6).수식어, 수식어패턴, 접근제어자부터 봐보겠다.
                        여기에는 public, protected등이 올 수 있는데, 스프링 AOP는 public 메서드에만 적용할 수 있기 때문에 사실상
                        public만 의미가 있다. 이게 무슨 말이냐면, 위에서 프록시가 생성되는 과정과 적용되는 과정을 정리한 것에서 보면 알겠지만,
                        간단하게 말하면, joinPoint.proceed()를 통해서 대상객체의 핵심기능 메서드가 실행되는데, 우선적으로 joinPoint.proceed()이니
                        Aspect클래스에서도 따로 대상객체의 핵심기능 메서드 코드가 없는걸보니, 프록시 객체에서 대상객체의 핵심기능 메서드가 실행되는게 아니라
                        ProceedingjoinPoint라는 인터페이스형 변수에 이 인터페이스의 구현체 클래스가 변수에 대입되서, 해당 변수의 메서드인 proceed()가
                        실행되기에, 적어도 이 구현체 객체에서 대상객체의 메서드가 호출되거나, 아니면 또 다른 객체에서 호출되어서 그 코드가 proceed()에
                        있는걸수도 있겠다. 확실한건 아래 스프링5 168pg 참조문헌에 보면, 스프링 AOP는 public 메서드에만 적용할 수 있따는것을 보니,
                        대상객체의 자체 내에서 메서드를 호출하는것 같지는 않다.
                        또한, ProceedingjoinPoint나 joinPoint 혹은 proceed()에 대한 내용이 책이나 참조링크 모두 상세한 설명이 없어서 이정도로만
                        이해해도 충분할것 같다.
                        [직접해봄]    
                        [참조문헌 : 스프링5 168pg] / public만 의미가 있다.
                        [참조문헌 : 스프링5 165pg] / ProceedingJoinPoint의 proceed()메서드를 호출하고나서 어딘가에서 대상객체의 핵심기능 메서드를 호출은 한다는것을 보여주고 있다.
                        +
                        위에서 이러다 보니, 수식어 수식어패턴 혹은 접근제어자를 아예 생략하는 경우나 아니면 public을 그냥 적어주는경우가 있는데,
                        참조링크나 참조문헌을 봐도 적어주기도하고 public만 적어주기도 하니, 내키는대로 그때마다 정해주면 될것같다. 또한, 적어주는것
                        여부에 따른 차이도 검색해보니 없는것으로 보인다. 
                        [참조문헌 : 스프링5 168~169pg]    
                        [참조문헌 : 스프링부트 시작하기 초록책 107pg]    
                        [참조링크 : https://galid1.tistory.com/498]    
                        [참조링크 : https://maeryo88.tistory.com/200]     
                    (1-7).그 다음은 리턴타입에 관해서다.
                        리턴타입은 반드시 명시해주어야 하는것으로, 메서드의 해당 리턴타입에 해당하는것만을 지정하게
                        해주는것이다. *는 모든 리턴타입이 가능하다는것이고, void는 말 그대로 void 리턴타입만 설정한다는
                        것이다. 추가로 알아야할 것은 아래에 모든 예시들중에 void만 소문자로 적고 나머지 Integer와 String
                        그리고 Long에 대해서는 모두 대문자로 적어주었다. 이 부분에 대해서 인지하고 넘어가자.
                        그리고 나중에 내가 쓸때는 문제가 될시에 다시 정리하도록 하자.
                        [참조문헌 : 스프링5 168pg] / 리턴타입은 반드시 명시 & *,void,Long을쓰는 예시    
                        [참조링크 : https://velog.io/@shson/%EC%8A%A4%ED%94%84%EB%A7%81Spring-AOP-AspectJ-Pointcut-%ED%91%9C%ED%98%84%EC%8B%9D-1-1-execution] / 리턴타입 String
                        [참조링크 : https://icarus8050.tistory.com/8] / Integer 리턴타입 
                        [참조링크 : https://sjh836.tistory.com/157] / *,void에 대한 설명  
                    (1-8).그 다음은 클래스 이름과 메서드이름에 관해서다.
                        이 부분에 대해서는 클래스이름과 메서드이름에 대해서 함께 설명하는게 좋을 것 같다.
                        1.클래스 이름
                            클래스 이름 혹은 인터페이스이름은 생략할 수 도 있는데, 쓰게 된다면 다음과 같다. 여러가지가 있는데, 구분지어놓지 않고
                            바로 설명하도록 하겠다. 클래스명의 규칙은 정확하게 클래스명만 적어주거나, *클래스명, *와 같이 3가지로 표현이 가능하다.
                            해당 자세한 내용들은 아래 참조링크를 참조하도록 하자(*에 대해서는 아래 공통사항에서 보겠다.) 그 다음 클래스명 말고, 패키지 
                            경로에서는(사실 이걸 클래스 이름이라고 한번에 보는게 맞지만) .. 으로 해당 디렉토리의 하위 모드 패키지를 선택한다. 즉, 추가로 설명하자면, 
                            io.icednut.spring.exercise.. 와 같이 쓴다면, io.icednut.spring.exercise로 시작하는 모든 패키지를 선택한다는 뜻이다.
                            [직접해봄] / 인터페이스명, 구현체 클래스명 모두 다 적용이 됬었다.
                            [참조링크 : https://sjh836.tistory.com/157] / 클래스명, *클래스명에 대한 설명    
                            [참조링크 : http://closer27.github.io/backend/2017/08/03/spring-aop/] / 패키지 경로의 ..에 관하여 & *클래스명에 관하여    
                            +
                            클래스 이름은 반드시 풀 패키지명으로 입력해야 한다고 나와있다. 내가 직접해봤을때도, 전부 풀패키지명을
                            적어주지 않으면 제대로 정상작동하지 않았었다. 스프링5책이나 스프링부트 시작하기 초록책에도 전부 풀패키지명을
                            적어주었었다. 이 부분중에 틀린경우가 있다면 나중에 다시 정리하도록 하자.
                            [직접해봄]    
                            [참조링크 : https://icarus8050.tistory.com/8]      
                        2.메서드 이름
                            메서드 이름은 반드시 적어야하는 값이다. 메서드의 값은 *, 메서드명, 메서드명*와 같이 3가지로 나눠서 볼 수 있다.
                            클래스 이름은 안적더라도, 메서드이름은 위의 3가지중에 반드시 하나는 적어주어야 한다.
                            [참조링크 : https://sjh836.tistory.com/157] / 메서드 표현식 *와 메서드명*에 대하여   
                            [참조링크 : http://closer27.github.io/backend/2017/08/03/spring-aop/] / 메서드 표현식 *와 메서드명*에 대하여      
                            [참조문헌 : 스프링5 169pg] / *, 메서드명*, 메서드명의 예시   
                        [공통이해]
                            예시들을 들면서, 공통내용에 대해 알아보도록 하겠다.
                            (1).execution(* com.java.ex.Car.accelerate())의 경우
                                여기서 보면, 패키지명 적다가 갑자기 대문자가 나온다. 이 경우에는 패키지명이 아닌 클래스나
                                인터페이스 파일명으로 볼 수 있다. 그리고 그다음 바로 메서드에 대한 얘기가 나오면된다.
                                여기서 추가로 얘기하자면, 이 대문자가 나오는거에서 구현체 클래스가 올 수도 있고, 아니면
                                구현체 클래스가 올 수도 있다.
                                [직접해봄]    
                                [참조링크 : https://galid1.tistory.com/498]    
                                +
                                추가로, 직접해본것들인데 만약 이 명시자로 지정한것중에 인터페이스의 메서드를 지정하면 해당 인터페이스형 변수이면서 구현체 클래스를 가리키는
                                변수명에 해당하는 객체를 호출할때는, 모두다 프록시 객체를 사용하여 나타낸다. 아니면 인터페이스와 이를 구현한 구현체 클래스의 메서드를 한꺼번에 포인트컷으로
                                지정하더라도 똑같이 해당 인터페이스형 변수이면서 구현체 클래스를 가리키는 변수명에 해당하는 객체를 호출할때 모두다 프록시 객체를 사용하여 나타냈었다.
                                만약에 특정 인터페이스를 구현한 구현체 클래스의 메서드를 포인트컷으로 지정하는데, 다른 구현체 클래스의 메서드는 지정하지 않고 한 구현체 클래스의 메서드만
                                포인트컷으로 지정하면 인터페이스형 변수이면서 구현체 클래스를 가리키는 변수를 호출할때 이 포인트컷으로 지정한 구현체 클래스만 프록시 객체를 호출하고 나머지
                                구현체 클래스는 프록시 객체를 호출하지 않는다. 이건동적프록시를 직접해본거다. 
                                [직접해봄]    
                                +
                                CGLIB의 경우는 클래스 혹은 구현체 클래스를 선택하면 당연히 프록시 객체가 생성이 된다. 좀 더 구체적인 직접 해본 예시를 들자면,
                                컨트롤러같은 일반 클래스에 적용시 CGLIB으로 인해 프록시 객체가 생성되고, 구현체 클래스를 포인트컷으로 지정했을 경우에, 당연히 구현체 클래스더라도,
                                구현체 클래스형인 변수나 아니면 빈(이 경우 해당 구현체 빈이 1개만 있다고 생각하자.)을 사용할 경우 일반 클래스방식과 똑같이 CGLIB이 적용이 된다. 또한,
                                만약 인터페이스형 변수에 해당 구현체 클래스 객체가 바인딩되는 상황이더라도, 내부적으로 이미 이 인터페이스형이면서 구현체 클래스 반환하는 빈 객체 설정에서(구현체 클래스
                                @Component시 자동으로 적용되는 설정으로 본다.) 구현체 클래스 대신 이 CGLIB프록시 객체를 넣어 인터페이스형으로 자동 형변환되어 반환하는것으로 보인다.
                                즉, 인터페이스 구현체 클래스의 메서드를 포인트컷으로 지정하면 기존의 구현체 클래스형만의 빈과 인터페이스형이면서 해당 구현체 클래스 반환하는 빈의 설정이
                                둘다 바뀌는것으로 보고 있다. 그리고 만약 인터페이스의 메서드를 포인트컷으로 지정한 경우에도 직접해봤는데, 이 경우에는 위에서 인터페이스형 구현체 클래스의 메서드를
                                포인트컷으로 설정해주어서 해당 구현체 빈과 인터페이스형이면서 구현체 자동형변환된 빈 설정 둘다에 CGLIB 설정을 적용 했는데 이 또한 똑같이 적용되는것 같다. 다만,
                                해당 인터페이스를 구현한 구현체의 설정한 메서드 모두에 포인트컷이 적용되는것같다.(하나의 구현체는 해봤는데, 스프링부트 시작하기 초록책 107pg의 boardService인터페이스에
                                해보고, private final boardService boardServiceImpl로 직접해봄 그 외의 구현체는 안해봄 하지만 그런것 같다. 이 부분 나중에 틀리면 다시보기) 또한, 직접 
                                private final boardServiceImpl boardServiceImpl로 구현체 클래스형만으로도 했는데 정상작동했다. 즉, 확인시에 CGLIB 프록시 객체로 확인되었다는 말이다.
                                확인해봤었다. 마지막으로, 인터페이스와 해당 인터페이스 구현체의 메서드를 모두 한꺼번에 포인트컷으로 지정해도, 구현체 클래스형 변수나, 인터페이스형이며 구현체
                                객체 자동형변환 변수 모두 정상작동했었다. 즉, 중복으로 이렇게 적용해도 괜찮은것같다. 
                                [직접해봄]    
                                [참조링크 : 스프링부트 시작하기 초록책 107pg]
                                +
                                바로 위의 추가사항인데 내가 어느 참조문헌인가 참조링크에서 인터페이스의 구현체를 상속받은 클래스도 해당 인터페이스형으로
                                자동 형변환이 가능하다고 했다. 근데 찾을 수가 없어서 직접해봤더니 실제로 됬었다. 스프링 프로젝트에서 빈 설정에 반환형을 인터페이스형으로
                                하고, 반환되는 객체를 해당 상속받은 객체로 한다음 ctx로 인터페이스형으로 빈을 받았는데 정상적으로 작동했고, 실제로 getClass와 getName으로
                                확인해보니 이 상속받은 클래스였다.
                                [직접해봄]    
                            (2).execution(* com.java..*.*())의 경우
                                이거는 com.java의 패키지명의 하위 모든 패키지에 해당하며 ..*에서 이 *는 모든 클래스혹은 인터페이스를 뜻하는 말이다.
                                그리고 나서 .*라고 적혀져 있는 부분은 모든 메서드를 뜻한다.
                                [참조링크 : https://galid1.tistory.com/498]    
                            (3).execution(public * chap07..*(..))의 경우
                                보통, 다른데 보면 패키지명을 적어준경우 클래스나 인터페이스명까지 적어주어야 하는것이 기본이다. 그러나,
                                위의 예시처럼 chap07..*으로 chap07 하위패키지에 속하면서 모든 클래스의 모든 메서드를 의미하기도 한다. 즉, 원래는
                                execution(public * chap07..*.*(..))이 맞는건데 위의 경우도 정상적으로 작동했었다. 직접해봤다. 또한, 스프링부트 시작하기
                                초록책의 예시를 보면, execution(* board..select*(*))에서도 해설에 board 패키지의 모든 하위 패키지에 있으며 select로 시작하는
                                메서드라고 말하고 있다. 즉, 이 패키지명을 적을때 .. 적는거에서는 이러한 예외도 가능한가보다.
                                [직접해봄]    
                                [참조문헌 : 스프링5 168pg]    
                                [참조링크 : 스프링부트 시작하기 110pg]    
                    (1-9).파라미터 혹은 파라미터 패턴에 대해 보겠다.
                        파라미터팬터에 주로 쓰이는 문자는 *와 ..로 알고있다.(그 외에도 있지만 그건 필요시 나중에 다시 정리하도록 하자.) *의 의미는 모든 값을 표현하고, 
                        ..를 쓸경우 0개 이상을 의미한다. 즉, 정리하자면 파라미터에 ..만 쓴다면 0개 이상의 파라미터 즉, 모든 파라미터를 뜻하며, (*)이면 1개의 파라미터
                        (*,*)이면 두개의 파라미터가 쓰이는 메서드를 뜻한다. 즉, 이렇게 파라미터 개수를 조절할 수도 있꼬 만약에 ()처럼 아무것도 적어주지않는다면, 어떠한
                        파라미터도 없는 메서드를 의미한다. 각종 예씨들은 아래 참조링크에 적어놓았다.
                        [참조링크 : https://icarus8050.tistory.com/8] / *와 ..에 관하여
                        [참조링크 : https://sjh836.tistory.com/157] / *와 ..에 관하여    
                        [참조링크 : https://galid1.tistory.com/498] / 아무것도 안쓰면 파라미터가 없는 메서드를 의미한다.    
                        [참조링크 : https://icarus8050.tistory.com/8] / 각종 예시들
                2.within 명시자
                    (2-1).특정 패키지의 클래스 혹은 인터페이스를 설정하여, 해당 되는 클래스 혹은 인터페이스의 모든 메서드를 포인트컷으로 지정한다.
                        이때 패키지명도 다 적어준다. 즉, 결과적으로 패키지명과 클래스명 혹은 인터페이스명을 적어주어서 해당하는것의 모든 메서드를
                        포인트컷으로 지정한다.
                        [참조링크 : https://maeryo88.tistory.com/200]    
                        [참조링크 : https://galid1.tistory.com/498]    
                    (2-2).within 명시자의 기본형식은 다음과 같다.
                        within(클래스or인터페이스 경로) 
                        또한, 이때도 모든 패키지명을 다 적어주어야 하는것으로 알고있다.
                        [참조링크 : https://galid1.tistory.com/498] / 기본형식이 나와있다.   
                        [참조링크 : https://maeryo88.tistory.com/200] / 기본형식이 나와있지 않지만, 모든 예시가 이와같이 적혀져있다.
                        [참조링크 : https://icarus8050.tistory.com/8] / 기본형식이 나와있지 않지만, 모든 예시가 이와같이 적혀져있다.  
                    (2-3).확인은 안해봤지만, execution명시자 처럼, within명시자도 클래스명을 넣어줄때 인터페이스명도 입력가능하고, 클래스명이 적용되는방식이
                        execution과 같을것으로 보고있다. 만약 다르다면 그때 다시 정리하도록 하자.
                        [직접해봄]    
                    (2-4).예시들을 살펴보겠다.
                        (1).within(com.java.ex.*)인 경우
                            이 경우 com.java.ex 하위의 모든 클래스의 모든 메서드를 적용하겠다는 의미이다.
                            [참조링크 : https://galid1.tistory.com/498]    
                        (2).within(com.java.ex..*)인 경우
                            이 경우 com.java.ex 패키지의 하위 패키지를 포함해 모든 클래스의 모든 메서드를 적용하겠다는 의미이다.
                            [참조링크 : https://galid1.tistory.com/498]    
                        (3).within(com.java.ex.Car)인 경우
                            이 경우 com.java.ex 패키지의 Car 클래스 혹은 인터페이스의 모든 메서드에 적용하겠다는 의미이다.
                            [참조링크 : https://galid1.tistory.com/498]    
                        (4).within(board.service.*ServiceImpl)인 경우
                            이 경우 board.service 패키지 밑에 있는 ServiceImpl이라는 이름으로 끝나는 클래스 혹은 인터페이스의 모든 메서드에 적용하겠다는 의미이다.
                            [참조문헌 : 스프링부트 시작하기 초록책 111pg]        
                3.bean 명시자
                    (3-1).빈 이름을 설정하여, 해당 빈의 모든 메서드를 포인트컷으로 지정
                        즉, 패키지명이나 메서드 등은 쓰지않고, 오직 빈 이름만 적어주어서 해당 빈의 모든
                        메서드를 포인트컷으로 지정하게 된다. 희안한건 '빈이름' 이라고 말한다는거다.
                        [참조링크 : https://maeryo88.tistory.com/200]    
                        [참조링크 : https://galid1.tistory.com/498]    
                    (3-2).bean 명시자의 기본형식은 다음과 같다.
                        bean(빈 이름)
                        [참조링크 : https://galid1.tistory.com/498]    
                        [참조링크 : https://maeryo88.tistory.com/200] / 기본형식이 나와있지 않지만, 모든 예시가 이와같이 적혀져있다.
                        [참조링크 : https://icarus8050.tistory.com/8] / 기본형식이 나와있지 않지만, 모든 예시가 이와같이 적혀져있다.   
                    (3-3).희안한것은 클래스나 인터페이스명이 아니라 빈이름이라고 말하고있으니,
                        빈이름의 경우 첫글자가 소문자이다. 그러기에 전부 첫글자가 소문자이고 within의 경우
                        클래스명 혹은 인터페이스명이니 모두 대문자로 시작한다. 이 부분 인지만 하자.
                        [참조문헌 : 스프링부트 시작하기 초록책 111pg] / 여기서도 within은 첫글자 대문자, bean의 경우 첫글자 소문자다.    
                        [참조링크 : https://maeryo88.tistory.com/200] / bean의 경우 첫글자 소문자 & within의 경우 첫글자 대문자
                        [참조링크 : https://galid1.tistory.com/498] / bean의 경우 첫글자 소문자 & within의 경우 첫글자 대문자
                    (3-4).예시들을 살펴보겠다.
                        (1).bean(car)인 경우
                            이 경우, car라는 빈의 이름을 갖고있는 빈의 모든 메서드에 포인트컷을 적용한다는 의미이다.
                            [참조링크 : https://galid1.tistory.com/498]     
                        (2).bean(boardServiceImpl)인 경우
                            이 경우, boardServiceImpl이라는 이름을 가진 빈의 모든 메서드에 포인트컷을 적용한다는 의미이다.
                            [참조문헌 : 스프링부트 시작하기 초록책 111pg]    
                        (3).bean(*ServiceImpl)인 경우
                            이 경우, ServiceImpl이라는 이름으로 끝나는 빈의 모든 메서드에 포인트컷을 적용한다는 의미이다.
                            [참조링크 : 스프링부트 시작하기 초록책 111pg]        
                        (4).bean(some*)인 경우
                            이 경우, some이라는 이름으로 시작하는 빈의 모든 메서드에 포인트컷을 적용한다는 의미이다. 이거는 보통
                            *명 으로만 사용되었던거같은데 클래스명 적는 방식에서 빈에서는 이러한 예시가 있다. 이 부분은 내가 직접 검증해보지
                            못했지만, 나중에 사용하게 된다면 다시 정리해보자.
                            [참조링크 : https://icarus8050.tistory.com/8]                                             
            (11).ProceedingJoinPoint 그리고 Signature에 대한 정리
                1.우선, ProceedingJoinPoint에 대해서 알아보겠다.
                    (1-1).아래 참조문헌이나 참조링크를 봐도 그냥 ProceedingJoinPoint형의 매개변수를 전달받아서 사용한다. 라고만 주로 나와있다. 
                        또한, 직접 알아보니 ProceedingJoinPoint는 인터페이스이며, JoinPoint를 상속받는다. 직접 확인해보았다. 근데 아래 참조링크에 보면,
                        Around 어드바이스만 다른 어드바이스와 다르게, ProceedingJoinPoint형을 파라미터타입으로 선언해서 사용한다고 한다. 아마도 다른 어드바이스들은
                        JoinPoint형을 파라미터타입으로 사용하나 보다. 이때 JoinPoint형을 파라미터타입으로 사용하면, 그 인자를 스프링 컨테이너에서 넘겨준다고 한다. 아마
                        ProceedingJoinPoint형도 똑같을것같다. 이 부분 나중에 필요시 더 자세히 알아보자. 즉, 스프링 컨테이너에서 넘겨주는것은 알겠는데, 사실상 이 파라미터변수가
                        어떻게 적용되는지는 알려면 굉장히 복잡할 것 같아서, 프록시 객체를 만들때 포인트컷이 적용안된 메서드의 경우 그냥, 메서드 실행시에, 대상객체의 똑같은 메서드를
                        호출하게 해준다고 했는데, 이 또한 그냥 정확히 안다기보다, 프록시 객체를 만들때 어떤 설정이 있고, 만약 해당 포인트컷이 적용된 메서드 호출시에 자동으로 해당
                        대상객체와 해당 메서드에 대한 정보가 담긴 ProceedingJoinPoint형의 파라미터 인자가 전달된다고만 알자.(나는 Around만 썻으니 ProceeingJoinPoint형이다.)
                        만약 나중에 필요할 시에 더 자세히 보도록 하자. 이 정도로만, ProceedingJoinPoint를 알면될것같다.
                        [직접해봄]    
                        [참조문헌 : 스프링5 165pg]    
                        [참조링크 : https://ktko.tistory.com/entry/Spring-ProceedingJoinPoint%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C]     
                        [참조링크 : https://sjh836.tistory.com/157] / 스프링 컨테이너에서 JoinPoint 인자를 전달해준다함. 
                    (1-2).ProceedingJoinPoint형의 변수명을 joinPoint라고 하기도 하지만, 그냥 임의로 편하게 다르게 변수명을 하는 경우도 있다.
                        아래 참조링크들을 보면, joinPoint가 아니고 다른 변수명을 쓰는데, 실제로 그냥 joinPoint를 변수명으로 쓰는 경우도 많았다.
                        그리고 이 변수명 자체는 크게 의미없는거같다. 물론, ProceedingJoinPoint형이 인터페이스이고 이를 구현한 구현체가 형변환되서 들어오는것
                        같은데, 아래 joinPoint에 대한 설명을 봐도 그리고 다른 글들을 봐도 구현체가 하나밖에 없는것 같고 그 외에도 정상작동하며 다른 것을
                        거론한것도 없다. 즉, 내가 편한데로 쓰데 처음쓸때는 그냥 joinPoint로 쓰는게 낫겠다.
                        [직접해봄]    
                        [참조문헌 : 스프링5 161pg] / 변수명 joinPoint
                        [참조문헌 : 스프링부트 시작하기 초록책 107pg] / 변수명 joinPoint
                        [참조링크 : https://www.egovframe.go.kr/wiki/doku.php?id=egovframework:rte:fdl:aop:aspectj] / 변수명 joinPoint가 아님
                        [참조링크 : https://sa1341.github.io/2019/05/25/%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B0%9C%EB%85%90-%EB%B0%8F-Proxy%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B5%AC%EB%8F%99%EC%9B%90%EB%A6%AC/] / 변수명 joinPoint가 아님   
                    (1-3).ProceedingJoinPoint형의 변수 joinPoint의 경우, 주로 사용되는 메서드는 3가지가 있다.(더 메서드 종류를 알아봐야할 필요가 있는 경우 그때가서 알아보자.)
                        지금 보여지는 봐로는 이 3가지만 알아도 되는것 같다. 우선적으로
                            1.getSignature()이며 반환형은 Signature
                            2.getTarget()이며 반환형은 Object
                            3.getArgs()이며 반환형은 Object[]
                        이다. 여기서 보듯이, joinPoint변수는 1.메서드 시그너처 객체를 반환할 수도 있으며, 2.아니면 해당 호출된 핵심기능 메서드를 사용한
                        대상 객체를 리턴할 수도 있다. 3. 또한, 해당 메서드 호출시에 넘겨준 파라미터에 대해서도 배열로 값을 반환 받을수 있다. 각각에 대해서 아래
                        계쏙 자세하게 정리하도록 하겠다.
                        [참조문헌 : 스프링5 166pg]     
                        [참조링크 : https://velog.io/@gillog/AOP%EA%B4%80%EC%A0%90-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D]    
                        [참조링크 : https://sa1341.github.io/2019/05/25/%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B0%9C%EB%85%90-%EB%B0%8F-Proxy%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B5%AC%EB%8F%99%EC%9B%90%EB%A6%AC/]    
                        [참조링크 : https://ktko.tistory.com/entry/Spring-ProceedingJoinPoint%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C]    
                        [참조링크 : https://sjh836.tistory.com/157]    
                    (1-4).위의 1-3에 해당하는 메서드들에 대해 조금만 더 자세히 보도록 하겠다.
                        우선, (1-3).의 1.에 해당하는 getSignature()메서드는 Signature객체를 반환하게 되는데, 클라이언트가 호출한 메서드의
                        시그너처가 담긴 Signature형 객체이다.(그런데, 이 Signature객체에 대해 뒤에 자세히 보겠지만, 단순히 해당 메서드의 이름과
                        파라미터타입 그리고 파타미터 갯수에 대한 정보보다 더 많은 정보를 담고있다. 뒤에서 자세히 설명하겠다.) 그리고 2.getTarget()메서드
                        에 대해서는 반환형이 Object이고 해당 대상객체를 리턴하게 된다. 추가로 이것에 관해서는 아래 +로 설명해놓았다. 마지막으로 3.메서드인
                        getArgs()에 관해서다. 반환형은 Object[]이며, 해당 메서드를 호출할 때 넘겨준 인자 목록을 Object 배열로 리턴한다고 한다. 이게 아래모든 참조링크와 참조문헌에서 설명한 전부다. 근데
                        이 반환값이라는게 Object[]배열이여서 이 Object[]배열 형의 변수를 반환하는것인데, 아래 참조문헌에서 예시를 보면, Arrays.toString(joinPoint.getArgs())
                        와 같이 사용되고 있다. Arrays.toString()은 추가사항에 설명해놓았고, 여기서 Object형으로 객체들을 담을 수는 있는데, 어떻게 숫자,문자열 같은거를 담아내서 반환하는지는 모르겠다..
                        여러가지 방안이 있는데, Int,long등은 wrapper 클래스로 받아들이고, String 문자열은 String객체로 바꿔서 적용해볼 수 있다고 생각해봤다.(아니면 모두 String 객체로 받던지, String도
                        자바 책을보니, 그냥 문자열대입할 수도 있고, 객체를 만들어서 사용할 수 있다. 당연히 여기선 객체 만들어서 사용할듯.) 이 부분에 대해서는 나중에 필요시
                        자세히보고, 이렇게 Object[] 배열 변수가 반환된다는것을 알았을때, 아래 Arrays.toString(joinPoint.getArgs())에 대한 예시에는 파라미터타입이 double이고 1개였다.
                        결과물에서는 이 Arrays.toString(joinPoint.getArgs())이 [5] 로 나왔는데, 아무래도 이해하는 방향이, wrapper객체이건 String객체이건 어느것이든, Arrays.toString()이
                        안에 배열 변수를 넣게되면 값만 문자열로 갖고와서 [~] 문자열 형태로 반환하는것으로 이해해야한다. 그 외에 다른 일반 객체들은 어떻게 되는지 모르겠다. 이렇게만 알고있고,
                        나중에 필요할 시에 다시 보도록 하자. 또한, 추가로 아래 참조문헌에 보면, 그렇게 안중요할지 모르겠지만 getArgs()로 갖고오는 인자 목록에 대해서는 대상 객체의 호출된 핵심기능
                        메서드에서 갖고온다고 한다.
                        [참조문헌 : 스프링5 166pg]     
                        [참조링크 : https://velog.io/@gillog/AOP%EA%B4%80%EC%A0%90-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D]    
                        [참조링크 : https://sa1341.github.io/2019/05/25/%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B0%9C%EB%85%90-%EB%B0%8F-Proxy%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B5%AC%EB%8F%99%EC%9B%90%EB%A6%AC/]    
                        [참조링크 : https://ktko.tistory.com/entry/Spring-ProceedingJoinPoint%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C]    
                        [참조링크 : https://sjh836.tistory.com/157]    
                        [참조문헌 : 스프링5 161pg,164pg] / Arrays.toString(joinPoint.getArgs()) 예시와 결과값이 나와있다.                   
                        [참조문헌 : 스프링5 162pg] / getArgs()메서드는 대상객체의 핵심기능 메서드에서 갖고온 인자 목록을 나타낸다.   
                        +
                        아래 참조문헌에 보면, joinPoint.getTarget().getClass()로 쓰인다. 분명 getTarget()하면, 대상객체가 반환이 되는데
                        Object형으로 반환된다고 했다. 그럼 여기서 짚고 넘어가야할 것이 해당 대상객체형의 빈이 반환이 되는데, 이를 Object형으로
                        자동형변환되서 리턴되는거다. 즉, 여기서는 대상객체 빈을 사용할 수 있되, Object형으로 자동형 변환되는데, 상속되는것 사이에서도
                        직접해본결과(물론, 상위클래스형 변수명 = new 하위클래스명()으로 해본 결과다.) 정상적으로 작동했었다. 그러면, Object형 반환 
                        메서드에서 대상객체도 자동형변환될것으로 보고있다.(여기서는 이정도만 해도 충분할거같다.) 이 두가지를 짚고 넘어가며, 그 다음
                        getClass()를 사용하게되면, 인터페이스형이며 자동형변환된 객체를 가리키는 변수와 같이 해당 getClass()를 실행한 자동 형변환된 
                        하위클래스에 대한 정보를 Class형으로 반환하게 된다. 이것모두 직접해보았다.
                        [직접해봄]    
                        [참조문헌 : 스프링5 161pg]    
                    (1-5).이 부분은 그냥 사용예시에 대해 담아놓은 부분이다.
                        joinPoint.getTarget().getClass().getSimpleName()처럼 대상객체를 Object형으로 받아오고 이것을 바로 getClass()로 클래스형 클래스를 받아오고
                        그다음 바로 getSimpleName()으로 클래스형 객체의 메서드로 객체 클래스 이름을 갖고온다. 이렇게 사용할 수 있는것도 알아두자.
                        [참조문헌 : 스프링5 161pg]    
                    (1-6).여기에 나와있는 ProceedingJoinPoint의 메서드인 proceed()메서드에 대해 알아보겠다.
                        이 ProceedingJoinPoint형의 변수의 메서드인 proceed()가 실행되면 해당 호출된 프록시 객체의 메서드에 해당하는 실제 핵심기능에
                        해당하는 대상객체의 메서드를 호출한다고 나와있다. 이렇게만 나와있고, 그 외에 대해서는 나온게 없다. 이정도만 알아도 될것같다.
                        [참조문헌 : 스프링5 162pg] / proceed()사용시 대상 객체의 메서드를 호출    
                        [참조링크 : https://owin2828.github.io/devlog/2019/12/30/spring-7.html] / proceed()사용시 대상 객체의 메서드를 호출    
                        [참조링크 : https://jojoldu.tistory.com/71] / proceed()사용시 대상 객체의 메서드를 호출    
                    [추가사항]    
                        아래 참조문헌을 보면, Arrays.toString()에 관한 내용이 나온다. 여기에서 나오는 내용이기 때문에 어떤 메서드 인지 짚고 넘어가도록 하겠다.
                        우선, 이 Arrays에 관한 객체는 자바 책에 따로 나오지 않았고, 그냥 아래 참조링크에 보듯이, 그리고 참조문헌에 보듯이 import java.util.Arrays;
                        만 import해주면 사용할 수 있는것으로 보인다. import 문 보니 자바에서 기본적으로 제공해주는것 같다.(이 부분은 나중에 필요시 다시보고) 이
                        Arrays.toString() 자체를 기억하는게 좋을것같은데, Arrays.toString(배열 변수명)을 넣어주면 [배열첫번째값, 배열두번째값, ..] 와 같은 문자열형태로
                        값을 반환한다. 근데, 아래 예시에서 보듯이 모두 int,double같은 형의 배열을 든 예시인데, 배열에 정의된 값들을 문자열 형태로 만들어서
                        리턴해주는것이라 한다.
                        [참조문헌 : 스프링5 161pg]    
                        [참조링크 : https://hianna.tistory.com/510]     
                        [참조링크 : https://crmn.tistory.com/61]     
                2.Signature 객체에 대해 알아보겠다.
                    (2-1).우선, 먼저 알아야 할것은 메서드 시그너처 라는것이다. 메서드 시그너처란 그냥 메서드 이름과 파라미터를 합쳐서
                        메서드 시그너처라고 한다. 즉, 좀 더 예시를 들자면 메서드 이름이 다르거나 파라미터 타입 혹은 파라미터 개수가 다르면 시그너처가 다르다고
                        표현한다. 즉, 반대로 메서드 이름이 같고, 파라미터 타입과 갯수가 같으면 메서드 시그너처가 같다고 한다. 여기서 파라미터의 이름은 따지지
                        않는것으로 보인다. 아래 참조링크들을 보면. 또한, 정리하자면 메서드 시그너처란 것이 정말로 메서드 이름과 파라미터 타입, 개수를 합쳐서
                        그냥 일컫는것으로 보인다. 또한 추가로 메서드의 리턴 타입이나 익셉션 타입은 시그너처에 포함되지 않는다.
                        [참조문헌 : 스프링5 162pg] / 메서드 시그너처의 개념 & 자바에서는 메서드의 리턴타입이나 익셉션 타입은 시그너처에 포함되지 않는다.                   
                        [참조링크 : https://wanna-b.tistory.com/75]    
                        [참조링크 : https://ildann.tistory.com/7]    
                    (2-2).그럼 이 Signature 객체란 무엇인가.
                        첫번째 참조링크에 보면, Signature객체란 클라이언트가 호출한 메서드의 메서드 시그너처 정보가 저장된 객체를 뜻한다고 한다. 근데, 여기서
                        보면, 이 Signature객체의 메서드 중에 리턴타입, 해당 메서드를 가지는 클래스 풀패키지명 등 여러 메서드를 제공하는것으로 보아,
                        실제 메서드 시그너처 정보 외에도 여러 정보를 갖고있는것으로 보인다. 바로 아래 (2-3).에 정리해 놓았다.
                        [참조링크 : https://sa1341.github.io/2019/05/25/%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B0%9C%EB%85%90-%EB%B0%8F-Proxy%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B5%AC%EB%8F%99%EC%9B%90%EB%A6%AC/]       
                    (2-3).Signature객체가 갖고있는 메서드에 대해 보겠다.
                        1.getName()이며 반환형은 String이다.
                        2.toLongString()이며 반환형은 String이다.
                        3.toShortString()이며 반환형은 String이다.
                        4.getDeclaringTypeName()이며 반환형은 String이다.
                        각각에 대해 간단하게 정리해보도록 하겠다. 우선, 첫번째로 getName()메서드의 경우 말 그대로 해당 호출되는 메서드의 이름을
                        반환한다. 딱 그 메서드명만 반환하는데 아래에 참조링크에 보면 예시도 함께 있다. toShortString() 메서드는 호출되는 메서드를
                        축약해서 표현한 문장을 반환한다고 한다. 근데 어느 참조링크를 봐도 이것외에는 설명이 없고 예시도 없었다. 이 부분은 나중에 필요시
                        다시 봐보도록 하자. 그 다음 StringtoLongString() 메서드인데, 이는 호출되는 메서드를 완전하게 표현한 문장을 반환하는데, 클라이언트가
                        호출한 메서드의 리턴타입, 이름, 매개변수를 패키지 경로까지 포함하여 반환한다고 한다.이것도 참조문헌이나 참조링크에 이렇게만 적혀져있다.
                        또한, 예시들도 없었다. 나중에 필요시 더 찾아보고 정리하도록 하자. 마지막으로 getDeclaringTypeName()메서드에 대해 보도록 하겠다.
                        이 메서드는 호출된 메서드를 가지는 대상 객체의 풀패키지명(클래스명포함)을 값으로 반환한다. 실제 예시는 아래 참조문헌에 나와있다.
                        이것으로 보았을때, Signature는 메서드 시그너처와 해당 호출 메서드의 반환타입 해당 호출 메서드를 갖고있는 클래스의 풀패키지명을
                        추가로 갖고있는것으로 볼 수 있다.
                        [참조문헌 : 스프링5 166pg] / getName(), toLongString(), toShortString() 메서드 개념
                        [참조링크 : https://sjh836.tistory.com/157] / getName(), toLongString(), toShortString() 메서드 개념
                        [참조링크 : https://ktko.tistory.com/entry/Spring-ProceedingJoinPoint%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C] / getName(), toLongString(), toShortString() 메서드 개념
                        [참조링크 : https://velog.io/@gillog/AOP%EA%B4%80%EC%A0%90-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D] / getName(), toLongString(), toShortString(), getDeclaringTypeName() 메서드 개념
                        [참조링크 : https://sa1341.github.io/2019/05/25/%EC%8A%A4%ED%94%84%EB%A7%81-AOP-%EA%B0%9C%EB%85%90-%EB%B0%8F-Proxy%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B5%AC%EB%8F%99%EC%9B%90%EB%A6%AC/] / getName(), toLongString(), toShortString(), getDeclaringTypeName() 메서드 개념
                        [참조문헌 : 스프링5 161pg, 164pg] / 실제 getName()사용예시와 결과값       
                        [참조문헌 : 스프링부트 시작하기 초록책 107,108pg] / 실제 getDeclaringTypeName()사용예시와 결과값
                        +
                        한가지 getDeclaringTypeName()에 대해 짚고 넘어가야할것이 있는데, 이는 호출되는 핵심기능 메서드를 갖고있는 대상객체에
                        대한 풀패키지명(클래스명포함)을 반환하는거다. 즉, 동적프록시는 그 과정을 생각했을때, 대상객체인 구현체 객체의 풀패키지명을 반환하는거고,
                        CGLIB같은경우는, 위의 CGLIB관련 생성 과정을 보면 알겠지만, 컨트롤러 클래스 같은것도 CGLIB같은경우 핵심기능 메서드는 대상객체의 메서드를 호출해서 
                        사용하기에, 여기서도 상속받은 프록시객체가 아닌 대상객체인 원래 컨트롤러 클래스의 풀패키지명을 반환한다. 만약에 인터페이스형이면서 자동형변환되는 변수에
                        해당하는것을 CGLIB 프록시 객체로 쓸때도, 그냥 빈 만들어질때 인터페이스형이면서 그 안에 자동형변환되는 객체가 기존 구현체 객체대신 이 상속받은 CGLIB 프록시
                        객체가 들어가게되어(들어가는게, CGLIB 프록시 객체 자체보다는, 상위클래스로 자동형변환된것이 들어가는것 같다.), 해당 getDeclaringTypeName()을 해도 CGLIB이
                        상속받은 상위 클래스의 풀패키지명이 뜨는것으로 보인다. 추가로, 위의 인터페이스형으로 자동형변환되는 CGLIB 프록시 객체가 들어갈때 그 외에는 아무 코딩 변화도
                        일으키지 않는것같다. 그니까 단순히 인터페이스형으로 자동형변환해서 쓰는것으로 보인다. 당연히 이게 맞는게 아닐지 모르겠지만 우선 이렇게 알자. 
                        [직접해봄]    
                        [참조문헌 : 스프링부트 시작하기 초록책 108pg]     
                        +
                        추가로, 위의 mapper인터페이스형의 경우에는 그냥 매퍼 인터페이스형의 변수에 빈을 넣어야 할때, 이 매퍼 인터페이스형의 구현체 객체가 생성이 되고 구현체형으로는
                        빈으로 등록이 안된상태에서 JDK Dynamic Proxy가 동일하게 적용이 되는거다. 그러니 이 매퍼인터페이스의 메서드에 포인트컷을 설정하고, 이 매퍼인터페이스형 변수이면서
                        해당 구현체 자동형변환반환되는 변수를 사용하게되면 여기에 동적프록시 객체가 들어가게되고 이 변수의 메서드가 호출이 되고 그게 핵심 기능에 관련된 메서드이면서
                        그 안에서 Sginature객체의 getDeclaringTypeNAme()메서드가 호출이 된다면, 원래라면 대상객체의 풀패키지명을 String형으로 반환하는게 맞는데 이거는 직접해본결과
                        매퍼인터페이를 풀패키지명(인터페이스명포함)으로 반환했었다. 이거는 그냥 이렇다고만 알고 넘어가자
                        [직접해봄]    
                        [참조문헌 : 스프링부트 시작하기 초록책 107pg]    
                    (2-4).추가로 Signature 객체의 사용예를 보겠다.
                        아래 참조문헌에 보면, Signature sig = joinPoint.getSignature();으로 직접 Signature 객체를 따로 변수에 대입해서
                        사용하며, sig.getName()을 직접사용했다. 두번째 참조문헌에 보면, 스프링부트 시작하기 초록책에 나와있는 내용인데, joinPoint.getSignature().getDeclaringTypeName();
                        이랑 joinPoint.getSignature().getName();처럼 사용되어져 있다. 이거보면 바로 ProceedingJoinPoint형의 getSignature()를 쓰고 바로 Signature객체의 메서드인
                        이 두가지를 바로 쓰는것을 볼 수 있다. 그냥 알아두기만 하자.
                        [참조문헌 : 스프링5 161pg]    
                        [참조문헌 : 스프링부트 시작하기 초록책 107pg]       
                    (2-5).또한 추가로, 이 Signature에 포함된 메서드 정보들은 프록시 객체의 클라이언트가 호출한 메서드에 대한 정보보다도,
                        대상객체의 실제 핵심기능 메서드에 대한 정보를 갖고와 보여주는것으로 볼 수 있다. 아래 참조문헌에 보면 그렇게 나와있다.
                        그런데, 이건 인지정도만 하고 넘어가야할게 사실상 프록시 객체의 호출 메서드에 관해서건, 아니면 대상객체의 핵심기능 메서드에
                        관해서건 크게 차이가 없기 때문이다.
                        [직접해봄]    
                        [참조문헌 : 스프링5 162pg]    
                [추가사항]    
                    아래 참조문헌에 보면, String의 메서드로써 indexOf()라는 메서드가있다. 참조문헌에 보면, Aspect 클래스에서
                    쓰였다. 기능은, 자바 책에서 String 클래스보면, 그냥 문자열 대입해서 쓰거나 아니면 문자열을 남은 STring객체를
                    생성해서 사용하는데, 아래 참조링크를 보면 전부 그냥 문자열 대입해서 메서드 사용한다. 참조문헌에서도. 이 indexOf(~)
                    의 기능은 이 메서드를 쓰는 String타입 변수에 "~"라는 문자열을(""붙여서) 넣어서 실행시키면 해당 문자열을 마주치는 인덱스의
                    값을 돌려준다. 즉, String str = "abcdef";이고 str.indexOf("c")이면 이 c의 index값 2를 돌려준다는거다. 다른 예시를들면,
                    String strTest = "영일이삼사오육칠팔구십"; 이고 strTest.indexOf("사오육");이면 이는 4를 값으로 돌려준다. 또한, 아래 참조링크에서
                    보듯이 이 메서드의 반환형은 int이다. 또한, 만약 해당 ~ 문자열을 찾지못하면 -1을 반환한다고 한다. 더 알아야할 내용이 있다면 
                    나중에 더 자세히 알아보도록 하자.
                    [참조문헌 : 스프링부트 시작하기 초록책 107pg]    
                    [참조링크 : https://hey79.tistory.com/41]     
                    [참조링크 : https://bamdule.tistory.com/19]     
.
.
.
    5.이제 마지막으로 실질적으로 이 Aspect클래스를 사용할때의 구체적인 사항과 실질적으로 이 Aspect클래스 안에는 어떠한 공통기능을
        넣고 사용하는지에 대해 정리하도록 하겠다.
        (1).우선은, 이 어드바이스 메서드의 반환형에 관해서다. 여기서는 Object로 쓰였는데, 이거는 아래 참조문헌이나 다른 참조링크에서도
            모두 예외없이 Object형으로 사용했다. 근데, 아래 참조문헌과 참조링크를 보면 ProceedingJoinPoint형의 변수의 메서드인 proceed()를
            실행시키고 나서도 이를 반환값을 Object형 변수에다 받는다. 즉, proceed()의 반환형도 Object로 보는게 좋겠다. 순차적으로 추가적으로
            아래에 설명하도록 하겠다.
            [참조문헌 : 스프링5 161pg]    
            [참조문헌 : 스프링부트 시작하기 초록책 107pg]    
            [참조링크 : https://galid1.tistory.com/498]    
            +
            우선은 이게 확실히 맞는지 아닌지는 모르나 이럴것이라고 생각하는게 좋을것같다. 우선, proceed()메서드의 반환형은 Object형이 맞다. 대신에 이
            proceed()메서드가 실행이 되고 대상객체의 핵심기능 메서드가 실행이 되고 반환값이 나왔을때 이것을 proceed()메서드 안에서 다 Object형으로 반환할 수
            있게 해주는것 같은데, 만약 int형이나 long과 같은형으로 핵심기능메서드에서 반환하는 경우 wrapper 객체로 감싸고, String형인경우 이것도 Object형으로
            반환할 수 있게 해주면서(바로 반환이 가능한지 아니면 String객체를 따로 만들어서 넣어주는건지는 나중에 필요시 해보자.) 나머지 일반 형들은 그대로 반환이
            되는것같다. 그렇게 wrapper 객체들은 Object형으로 자동 형변환되고(이게 되는지는 안해봤으나 나중에 필요시 해보자.) 이 String형 객체도 Object형으로 
            자동 형변환되고(되는지 안되는지는 안해봤다.) 일반 형 객체들도 Object형으로 자동 형변환이 되서 proceed()메서드에서 Object형으로 값들을 반환하게 되는것같다.
            [직접해봄]     
            +
            그러고 나서 과정이 Object형으로 값을 반환하고 나면 이것을 어드바이스 메서드 내에서 Object형 변수에 대입시키거나 아니면 그대로
            어드바이스 메서드의 return 값으로 지정하여 값을 반환시키게 되면, 프록시 객체의 포인트컷에 해당하는 메서드 내로 나오게 된다. 여기에서 다시 한번의 작동을
            하는게 있는것같은데, 바로 원래 핵심기능 메서드의 반환형에 맞게 다시 바꿔주는거다. 원래 int, long과 같은것이였는데 Object형으로 자동형변환된 래퍼클래스로 변환된것은 
            다시 int와 long형으로 바꿔주고, String형이였던것은 Object형으로 자동형변환된 객체에서 다시 String형으로 바꿔주고 일반 형인 Object형으로 자동형변환된 객체들은 
            다시 원래 반환형으로 바꿔주게되어서 그런다음에 해당 프록시 객체의 메서드에서 반환이 되는것으로 보인다. 물론 이 과정들은 이해하기 편하기위해 생각한것이긴 하나
            이렇게 생각하는것도 나쁘지 않을것으로 보인다. 
            [직접해봄]     
        (2).그 다음 볼 내용은 바로 어드바이스 메서드의 이름이다.
            아래에 보면 참조링크나 참조문헌 모두 메서드 이름이 제각각 이였다. 이거는 따로 드러나는 부분도 없고 그냥 해당 어드바이스의
            공통기능에 관해서 겉으로 나타내주는 역활을 하는 것 같다. 특정한 메서드 이름을 적어야 하는것은 없는것같다. 어드바이스별로 기능에
            해당하는것으로 적당히 지으면 될것같다.
            [참조링크 : https://galid1.tistory.com/498]    
            [참조문헌 : 스프링5 161pg]    
            [참조문헌 : 스프링부트 시작하기 초록책 107pg]    
        (3).그 다음 볼 것이 바로 어드바이스 메서드의 throws Throwable에 관해서다.
            ㅁ@@@@@@@@@@@@@@@@
.
.
.
    [추가사항]
        1.분명, @Component와 @ComponentScan과 같은 방법으로 설정파일에 등록하고 빈을 만들어 내는경우 @Component가 붙은 클래스의 명에서 첫번째 글자만
            소문자로 바꾼게, 빈의 이름이 된다고 했었다. 그런데, 직접 해본것중에 예외가 있었던게 바로 첫번째, 두번째 글자가 모두 대문자인 경우에는 이 @Component와
            @ComponentScan을 사용하여 빈이 등록됬는데도 첫번째 글자가 소문자로 바뀌지 않고 그대로 대문자로 빈 이름이 등록됬었다.(실제로, ctx.getBean("빈이름",~)으로
            빈 이름에 첫글짜 소문자 넣었더니 안되고 대문자 넣었더니 됬다.) 즉, 이렇게 연속으로 앞글자 그리고 두번째 글자가 대문자이면 첫번째 글자를 대문자로
            빈을 등록하나 보다. 나는 TTest1.class, TTest2.class 이렇게 두개 클래스로 해봤었다.
            [직접해봄]   
            [참조문헌 : 스프링5 132pg]   
        2.위의 .getClass()메서드 내용과 관련된 .getName() 메서드에 대해서도 더 자세하게 보겠다.
            (2-1).우선 getClass()에 대해 보겠다.
                1.우선, getClass()메서드는 모든 클래스의 최상위 클래스 Object 클래스의 메서드이다. 즉, 모든 클래스는 getClass()를 기본적으로 갖고있다.
                    (따로, 오버라이딩 하지않는이상 그 기능 그대로 간다.)
                    [참조문헌 : 자바 책 352 ~ 353pg]   
                2.여기서 .getClass()메서드의 기능은 객체의 Class 클래스를 반환한다는건데, 그 의미는 Class형의 인스턴스를 값으로 반환하는데, 이 Class형의 인스턴스는
                    해당 getClass()메서드를 사용한 인스턴스에 해당하는 클래스나 인터페이스의 class파일에 저장된 정보를 갖고오는것이다.
                    [참조문헌 : 자바 책 378pg ]   
                3.추가로 클래스나 인터페이스 둘다 컴파일이 되고 나면, .class라는 class파일로 생성이 된다고 한다.
                    [참조문헌 : 자바 책 378pg]   
                    [참조링크 : https://jang-sn.tistory.com/55]    
                    [참조링크 : https://gbs1995.tistory.com/15]    
            (2-2).getName()메서드에 대해 알아보겠다.
                1.이 getName()메서드는 Class형의 클래스의 메서드이다. 즉, Class형 인스턴스만 쓸 수 있는것이며 이것이 적용될 수 있는 이유는,
                    애초에, Class형의 클래스가 존재하고 어떤 인스턴스에 .getClass()를 사용하게 되면, 해당 인스턴스에 해당하는 .class 파일에서
                    정보를 모두 긁어 갖고와 Class형 인스턴스로 갖고오는것같다. 그리고 해당 Class형 인스턴스에 .getName() 메서드를
                    사용하게 된다면, 저장되었던 정보중 하나를 갖고오는거다.
                    [참조문헌 : 자바책 378pg]    
                2.getName()메서드는 해당 클래스의 이름을 값으로 제공한다. 근데, 여기서 보면 해당 메서드를 직접사용하면
                    패키지명과함꼐 해당파일명도 다 함께 제공한다는것을 알 수 있다. 이는 일반 클래스형이나 아니면 구현체 형인데
                    자동형변환된 인스턴스에 사용하건 상관없이 다 같았다.    
                    [직접해봄]    
                    [참조링크 : https://ifuwanna.tistory.com/282] / 패키지명이 포함된 파일명 반환   
                    [참조링크 : https://woochan-autobiography.tistory.com/222]   
                    [참조링크 : https://zzdd1558.tistory.com/57]   
                    +
                    getSimpleName()이란 메서드가 있는데, 이를 사용하게 되면 패키지명은 안뜨고, 해당 .class의 파일명만
                    뜨게 된다.
                    [직접해봄]   
                    [참조링크 : https://ifuwanna.tistory.com/282]   
                3.그럼, 당연히 일반 클래스의 경우(상속은 안해봤다.)에는 패키지명과 해당 클래스명이 함꼐 뜨고, 인터페이스형으로 자동형변환된
                    구현체 인스턴스에 getCLass().getName()을 사용해보니, 해당 구현체 클래스의 패키지명과 클래스명이 떳었다. 즉, 애초에 인터페이스형으로
                    자동형변환된 구현체 인스턴스(자동형변환된 인스턴스가 대입된 인터페이스형 변수에 사용했었다.)에서 .getClass()를 사용하게되면,
                    구현체의 .class파일에서 정보들을 갖고와 Class형 인스턴스에 저장하는것 같다. (또한, 여기서는 ctx.getBean을 이용해서 빈으로 직접
                    해본것인데, 별 문제없을것으로 보인다.)
                    [직접해봄]    
            (2-3).위에서 보면, 예시들에 보면, ~.getClass().getName()와 같이 쓰이는게 보인다. 
                자바에서, 애초에, ~.getClass()를 하고 해당 Class형 인스턴스로 바로 적용이 되어서 Class형의 메서드인
                getName()을 사용할 수 있게 해놓은것 같다. 만약 이와 비슷하거나 다른 경우 더 자세히 알아야할 필요가 있다면
                그때 더 자세히 정리하도록 하자. 직접해봤을때, 클래스 빈이나 자동형변환된 구현체 빈 모두 사용가능했었다.
                [직접해봄]        
                +
                아래 참조문헌을 보니, ~getClass().getSimpleName()도 되는걸 보니, 애초에 getClass()를 쓰고 Class형 관련
                메서드들을 이어서 쓸 수 있는것 같다. 아래 참조링크는, 인터페이스형 변수였고 구현체의 자동형변환된 인스턴스가
                들어간것이 작동하는것이다. 만약 추가로 알아야할 사항이 있다면 그때 다시 봐보자.
                [참조문헌 : 스프링5 155pg]    
        3.여기서는 동적프록시와 CGLIB프록시를 사용하기 위해서 설정해야할 의존모듈과 스프링과 스프링부트에서 어떻게 다르게 설정하는지 그리고 보다
            세부적인 사항들에 대해 보도록 하겠다.
                (3-1).우선, 스프링에서 이 프록시 객체들을 사용하기 위해서는 artifactId가 spring-context 모듈과 aspectjweaver 모듈을 의존 대상으로
                    추가하면 정상적으로 작동하였다. 좀 더 자세히 보자면, 스프링에서는 이 spring-context모듈을 의존대상으로 추가하니, 그 안에 artifactId가
                    spring-aop인 모듈도 들어있어 자동으로 의존대상으로 추가됬었다. 그런데, aspectjweaver 모듈은 따로 의존 대상으로 추가해주어야 했었다.
                    [직접해봄]    
                    [참조문헌 : 스프링5 152pg]    
                    +
                    스프링부트에서 사용할때는, spring-boot-starter-web 모듈을 의존 대상으로 추가해주기만 하면, 사실상 이 모듈안에 spring-aop와 spring-context모듈
                    모두 포함되어 있었다. 그러나, spring-boot-starter-aop와 spring-boot-starter-web을 함께 모듈을 의존 대상으로 추가해주니, 원래는 spring-boot-starter-web
                    모듈에 spring-aop와 spring-context가 함께 있어 추가되어야 했던게 사라지고 대신 spring-boot-starter-aop에 이 spring-context와 spring-aop모듈이
                    있어서 여기에서 함께 의존모듈이 추가된것으로 나온다. 그 외에도 spring-boot-starter-web에 있어야할 여러가지 모듈들이 없어지고 spring-boot-starter-aop에 대신
                    모듈들이 지정이 되어서 여기서 여러 모듈들이 의존 대상으로 추가 되었었다. 또한, spring-boot-starter-aop 모듈을 의존 대상으로 추가해주면 그 안에 aspectjweaver
                    모듈도 있어서 자동으로 의존 대상에 추가가된다. 그러기에 스프링부트는 spring-boot-starter-aop이 모듈 하나만 추가해주면 aop관련 의존 모듈은 모두 추가해주는것이다.
                    [직접해봄]    
                    [참조문헌 : 스프링부트 시작하기 초록책 42pg]    
                (3-2).스프링에서는 @EnableAspectJAutoProxy를 사용하는데, 이는 import문을 보면 spring-context의 의존모듈에서 직접 import해서 가져다
                    쓰고 있다.(스프링, 스프링부트 둘다.) 또한, 그 외에 ProceedingJoinPoint와 @Aspect, @Around의 경우 스프링,스프링부트 상관없이 사용하게 되는경우 
                    aspectjweaver 모듈에서 직접 가져다 쓰고, 스프링에서 추가로 @Pointcut과 Signature를 사용할때 aspectjweaver 모듈에서 직접 가져다 사용하고 있었다. 
                    만약 스프링부트에서도 @Pointcut과 Signature형 변수를 써야하는 경우 스프링과 똑같이 import하여 사용해야할것이다. 이거는 위에 aspectjweaver를 왜 쓰는지에
                    대해서도 설명했는데, spring-aop 모듈에서도 이와 비슷한 기능들이 제공되는것으로 안다. 그러나 aspectjweaver를 쓰는 이유는 더 효율적으로 사용하거나 아니면 spring-aop
                    에는 없는 몇가지를 사용하기 위해서 사용하는것으로 보인다. 추가적으로 얘기하자면, 그 외에 위빙방식이나 포인트컷을 실질적으로 사용하는것에 대해서는 이 spring-aop모듈에
                    있는것을 사용하는것같다. 왜냐하면 spring-aop 방식이 런타임만 제공하며 포인트컷도 메서드가 호출했을때만 제공하기 때문이다.(자세한건 위에 정리) 즉, 실질적 설정을 뺀 사용은
                    모두 spring-aop로 작동하는것같다.
                    [직접해봄]    
                    [참조문헌 : 스프링5 162pg]     
                    [참조문헌 : 스프링부트 시작하기 초록책 107pg]            
                (3-3).이거는 Signature객체뿐만이 아니라 알아두면 좋은 자바 문법이다.
                    여기 Signature객체를 사용할때 봐야 할 것이 있다. 스프링5책에서는 직접 Signature형의 변수를 선언하고 사용하기 위해 사용되고 있고,
                    아래 참조문헌에 스프링부트 시작하기 초록책에서는 Signature형 변수를 선언하지는 않지만, 똑같이 Signature객체를 반환값으로해서 사용하고 있다. 그런데, 아래
                    스프링5에서 보듯이 여기서는 이 Signature객체를 사용하기 위해 import를 해주었고 반대로 스프링부트 시작하기 초록책에서는 따로 import문을
                    적어주지 않았다. 내 생각에 특정 클래스에서 어떠한 형의 객체를 반환하든지 이 경우에는 해당 형의 클래스나 인터페이스를 import할 필요가 없지만,
                    만약 해당 특정 클래스에서 그 어떠한 형의 변수를 선언하고싶다면 그 '형'을 쓰기 위해서는 해당하는 인터페이스나 클래스를 import해주어야 하는것같다.
                    여기도 직접봐본결과 Signature가 인터페이스인데 이를 변수 형으로 사용하기 위해 해당 인터페이스를 import해줘서 사용하고 있다.
                    이 외에도 부수적인 내용이 더 나오거나 더 정확하게 알아야할 필요가 있다면 다시 정리하도록 하자.
                    [직접해봄]    
                    [참조문헌 : 스프링5 161pg]    
                    [참조문헌 : 스프링부트 시작하기 초록책 107pg]    
.
.
.