.
.
.
1.스프링부트 로깅에 대해 본격적으로 들어가기에 앞서 기본적인 내용들과 추가 부수적인 내용들에대해
    한번 정리하고 들어가겠다. 여기에 있는 내용들은 뒤의 2.에서 정리한 내용과 섞여가며 설명을 하겠다. 그래야
    이해가 잘된다.
    (1).log4j, logback, log4j2를 모두 로깅 구현체라고 부르는데 이러한 이유와 slf4j를 로그 모듈들의 추상체이며 인터페이스와
        비슷하다고 하는 이유에 대해 간단하게 이해가 되게 정리해보도록 하겠다. 엄밀히 말하면 slf4j가 완전히 인터페이스와 같은 역활을
        하는것같진 않지만 인터페이스와 비슷한 역활을 한다고 볼 수 있다. 그렇기에, 위와같은 이유로 스프링부트의 기본설정인 logback 로깅 프레임워크(로그 라이브러리) 
        외에도 다른 로그 구현체를 최소한의 설정만 변경하면 바로 사용할 수 있다고 한다. 또한, 로그를 사용하는 코드에서는 특정 로깅 구현체의 패키지를 사용하지 않기 때문에 
        즉, 특정 로깅 구현체의 패키지를 import같은것을 해서 사용하지 않기 때문에 더욱더 다른 로깅 구현체로 바꿔주는게 쉬운것 같다. 즉, 더 얘기하자면 애초에, 로그를 사용하려는
        클래스에서 로거를 생성해서 사용을 하는데 이 로거를 사용하기 위해 실제 import되는 패키지는 slf4j 패키지밖에 없다는 것이다. 즉, 로그를 사용할 클래스에서도
        logback과 같은 로깅 구현체의 패키지를 import하지 않고 이 slf4j만 import하기 때문에 이렇게 클래스에 로그 관련 코드를 작성하고 나서도 다른 로깅 구현체를
        사용하려고 한다해도 해당 클래스에서 추가적으로 변경할 부분이 없기때문에 쉽다는거다. 실제로 기본설정된 logback만 사용해보겠지만 나중에 필요시 log4j2로
        사용하는 경우에 더 자세한 사항들은 그때 보도록 하자. 즉, 정말로 클래스에 적혀진 코드들은 아무것도 안건드려도 되는지 혹은 설정파일은 변경할 것은 없는지에
        관해서는 나중에 실제로 바꿀때 해보자는거다.
        [직접해봄]        
        [참조문헌 : 스프링부트 시작하기 초록책 92pg,94pg]            
        (1-1).우선은 이 아래 코드들
            import org.slf4j.Logger;
            import org.slf4j.LoggerFactory;
            (공간)
            Logger log = LoggerFactory.getLogger(this.getClass());
            를 보면서 얘기해보도록 하겠다. 여기에서 볼것이 굉장히 많은데 하나하나 보도록
            하겠다. 추가로 봐야할것은 어디는 private static final 에 대해서 또한 롬복
            라이브러리도 추가로 보도록 하겠다.
            [참조문헌 : 스프링부트 시작하기 초록책 107pg] / 코드 예시    
        (1-2).동시에, 이 Logger log = LoggerFactory.getLogger(this.getClass());에 대해서 보도록 하겠다. 이 Logger는 인터페이스형이고 LoggerFactory
            는 클래스형인데, 위의 코드를 보면, 이 Logger형 타입선언과 LoggerFactory를 쓰기위해서는 slf4j에 대한 모듈을 import해서 사용해야 한다. 그렇게해서
            Logger형 변수를 선언해주고 LoggerFactory.getLogger()메서드를 이용해서 로거 객체를 갖고오게 된다. 이때 또 알아야 할 것은 LoggerFactory는 생성자주입도 
            아니고, 객체를 대입해준것도 아닌데 그냥 이 자체로 사용이 가능하였었다. 이거는 찾아봐도 안나오고 이 자체로 특수케이스라고 생각하고 넘어가자. 즉, 조금 더 이해를
            하자면, 이 LoggerFactory자체를 해당 형의 인스턴스가 주입된 변수명이라고 이해하는게 맞을것같다. 즉, 이미 이 자체로 코드가 읽히기만 한다면 LoggerFactory의 메서드 같은것을
            사용할 수 있는것이다.(또한, 자바클래스에서 멤버변수에 new ~()로 생성자로 객체주입하거나 아니면 this.메서드()사용해서 멤버변수 값 대입하고 출력 했는데 모두 정상적으로
            적용이 됬었다. 즉, 인스턴스화 할때 코드를 읽는다는것이다. 이정도만 알고 당연히 뒤에서 이것에 대해 더 자세하게 봐야된다면 그때 더 정리하도록 하자.)
            그리고나서 LoggerFactory.getLogger(this.getClass())처럼 사용이 되는데, 우선 여기서 위의 말대로 getLogger()메서드를 사용할 수 있게 되는것이고,
            또 신기한게 원래 이 this는 사실상 사용되는 클래스의 생성자나 메서드안에서 사용이 되는것만 봐왔는데, 위에서 보듯이 멤버변수공간에서도 this가 쓰이는것을
            보았다.(심지어 this.print()로 해당 클래스내의 메서드를 호출해서 그 안에 숫자 3을 System.out.println으로 호출하는거 해봄) 즉, 어떤 클래스를 인스턴스화 
            시킬때 멤버변수쪽 코드를 읽을때 이렇게 this.메서드()로 호출이 가능하다는것을 알았다. 그로인해 해당 클래스가 항상 갖고있는 getClass()메서드를 사용할 수
            있게 되고 this.getClass()의 결과물로 해당 클래스의 자료를 클래스형객체형태로 반환하게 되는거다. 그렇게 되면, 원래는 이 getLogger("~")에 "~"로 적어넣으면
            ~를 이름으로 로거의 이름을 기반으로 로거 인스턴스를 생성해서 갖고오게 되는건데 getLogger(this.getClass())처럼 클래스 객체를 넘겨주게 되면, 로거의 이름이
            해당 클래스형 객체에 담겨있는 클래스 정보의 패키지 이름과 클래스 이름으로 로거 이름이 완성된다고 한다. (ex 마치 "패키지 이름 + 클래스 이름" 이런형태라는거다.)
            근데 이 getLogger()로 로거의 이름을 기반으로 로거 인스턴스를 생성해준다고 했는데, 좀 더 이해가 가게설명하자면 이 로거의 이름에 해당하는것으로 빈이 생성이 되는데,
            빈 이름이 이 '로거의 이름'으로 쓰이게 되고, '형'은 로깅구현체를 무엇으로 쓰냐에 따라 그 '형'으로 지정이 되는것 같다. 만약 중복되었던 로거이름을 적어주면 
            기존에 있었던 해당 이름의 로거 객체를 갖고오게되나보다. 또한, <pattern>같은데도 한번 봐봤는데 여기에서도 로거 객체의 이름을 이용해서 뭔가를 나타내는것은 없었다. 
            딱여기까지만 이해하고 나중에 필요시 더 이해하도록하자. (또한, 아래 설명할거지만 실제 생성되는 로거 객체의 타입은 logback관련 타입일것이다.)
            [직접해봄]    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@여기 파일명 정리할때, 클래스의 멤버변수 필드에 생성자, this.메서드도 사용이 가능해서 코드를 읽는다는거 정리하기
            [참조문헌 : 스프링부트 시작하기 초록책 94pg] / getLogger()에 대한 개념    
            [참조문헌 : 스프링부트 시작하기 초록책 107pg] / 예시코드   
            [참조링크 : https://docs.python.org/ko/3.8/library/logging.html] / .getLogger(~)에서 만약 ~에 같은 이름을 적어주면, 항상 같은 로거 객체를 반환해준다고 한다.    
        (1-3).이제, Logger log = LoggerFactory.getLogger(this.getClass());에서 이 Logger앞에 private static final을 붙이거나
            아니면 private final Logger ~ 처럼 사용하는 경우를 보았다. 여기서 private을 붙이는거는 어떻게보면 당연한게 해당 Logger 인터페이스형이
            변수가 만들어진 클래스의 메서드에서밖에(지금까지 내가봐온바론 그렇다. 나중에 다른경우가 있는경우 더 정리) 안쓰이기에 사실상 해당 클래스 안에서
            밖에 안쓰이는것이기 떄문에 private으로 하는게 맞다. 또한, final의 경우는 자바책을 봤을때 한번 대입이 되면 그 다음은 값을 변경할 수 없게 하는거다.
            사실상, 한번 대입된 로거 인스턴스는 바뀔일이 없기때문에 이것또한 어느 정도 맞다고 생각했다. 아래 final 조금 더 정리)
            [참조링크 : https://goddaehee.tistory.com/206] / private final    
            [참조링크 : https://backtony.github.io/spring/2021/03/23/spring-mvc-0/] private final    
            [참조링크 : https://osc131.tistory.com/120] / private static final   
            [참조링크 : https://kogle.tistory.com/28] / private static final            
            +
            근데, 한가지 직접해본결과 나는 스프링부트 시작하기 초록책 95pg에 나오는것처럼 컨트롤러에서도 했는데, 사실상 여기에는 나는
            @RequiredArgsConstructor을 지정해서 사용도 같이 했었다. 그런데 이거는 final이 붙은 필드의 경우 생성자주입을 해주는데 이
            Logger 멤버변수의 경우는 대입되는 값이 있어서인지 별다른 에러나 아니면 변경된 사항이 없었었다. 이제는 static에 대해 볼것인데
            static 멤버변수는 클래스 내부에 선언하지만, 다른 멤버변수처럼 인스턴스가 생성될 때마다 새로 생성되는 변수가 아니라, 객체를 생성하기
            전에 static 변수는 Static영역에 올라가게되어서 객체를 생성하기전에도 사용할 수 있다고 한다.(클래스도 이 Static 영역에 생성이 되는거고
            new 연산을 통해 생성된 객체는 힙영역에 생성이 되는거다. 그런데 이 힙영역의 메모리는 가비지콜렉터를 통해 수시로 관리를 받지만, Static영역에
            할당된 메모리는 관련 모든 객체가 공유하는 메모리라는 장점을 갖었지만 가비지 콜렉터의 관리 영역밖에 존재하므로 이 Static영역에 메모리를 할당되어서
            사용되어지는 static 지정 멤버변수를 너무 많이 지정해서 사용하게 되면 프로그램의 종료시에만 이 메모리가 해제되기에 되면 시스템의 performance에 악영향을 줄 수
            있다고 한다.) 그렇기에, 매번 객체를 생성해주고 그에 관해 this라는 것도 생성된 객체를 나타내는건데 이런 객체가 생성되어지기전에 static 멤버변수
            코드를 읽어서 static영역에 올리는거니 this라는 예약어는 사용할 수 없는것으로 보인다. 그렇기에 아래 + 참조링크에서도 이 static을 이용해서 로거
            변수를 선언해줄때도 그 안의 코드에 this를 사용하지 않고 그냥 클래스파일명을 적어주었다. 그러나 아래 참조링크들을 추가로 보자면, 보통 이 static
            을 붙여서 멤버변수를 사용하는 경우는 1.자주사용되고, 2.절대 변하지 않는 경우에 static final을 붙여서 사용한다고 한다.(보면 알겠지만 보통
            static만 안쓰고 final을 같이 붙여쓴다.) 그렇게 되면, 매번 객체가 생성될때마다 코드를 읽어서 만들어줄 필요가 없어서 성능향상에 좋다고 한다.
            물론, 이러한 자잘한 로거변수는 성능향상에 큰 도움이 없을 수 있다. 또한, 나중에는 아래 참조링크에 나와있지만, static을 잘못사용하면 굉장히 문제가
            크게 발생할 수도 있다고 하나 이는 쓰레드니 기타 다른 내용에서의 이야기로 보인다. 이거는 나중에 필요하면 다시 보도록 하자. 또한 아래 참조링크
            중 하나는 말이 모호하게 되있는데 static을 자주사용한다고 시스템의 퍼포먼스에 악영향을 주는것보다는 잘못사용하여 에러가 발생하거나 아니면 성능을
            악화시키는일 또는 과도하게 사용하여 메모리가 부족하게 되는 경우가 주 문제로 보인다. 그러니 이 부분은 신경쓰지 말고 나중에 문제가 된다면 다시봐보도록 하자.
            이제 원래 하고자했던 얘기는 그래서 static을 쓸까말까를 얘기할건데 그 얘기는 아래에 추가로 정리하도록 하겠다.
            [참조문헌 : 자바책 181pg]    
            [참조링크 : https://mangkyu.tistory.com/47] / static 멤버변수를 자주쓰면 메모리가 할당된 채로 존재하므로 시스템 퍼포먼스에 악영향을 주게 된다고 한다.
            [참조링크 : https://12bme.tistory.com/94]     
            [참조링크 : https://programmingfbf7290.tistory.com/entry/static-%EC%84%B1%EB%8A%A5]    
            [참조링크 : https://reference-m1.tistory.com/69]    
            [참조링크 : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=software705&logNo=220634319628]    
            [참조링크 : https://sungjk.github.io/2019/03/30/java-performance-tuning-2.html]    @@@@@@@@@@@@ 멤버변수에 final있어도 LoggerFactory처럼 대입해주면 @RequiredArgsConstructor 적용안되나보다. , static멤버변수성능 , Static영역 & 힙영역 ,static멤버변수 this
            +
            여기는 각각 private , private final , private static final을 Logger로 사용하고 있지만, private도 붙이고 
            private final도 붙이고 private static final도 붙여서 사용을 하는데, 아래 @Slf4j와 방금까지 설명한것들을 보면,
            private과 final은 당연히 붙여주는게 좋고, static을 붙이는것도 문제될것이 없고 오히려 긍정적인 효과를 낼것으로 보고
            있다. 또한 @Slf4j에서 기본적으로 private static final와 같은 방식으로 만들어지니 만약에 직접 쓸 일이 있다면, 이렇게
            private static final을 모두 사용하여 해주는게 좋을것으로 보고있다.
            [참조링크 : https://goddaehee.tistory.com/206] / private final Logger ~
            [참조링크 : https://unipiz.tistory.com/4] / private final Logger ~    
            [참조링크 : https://kogle.tistory.com/28] / private static final Logger ~ (~.class)    
            [참조링크 : https://osc131.tistory.com/120] / private static final Logger ~ (~.class)    
            [참조문헌 : 스프링부트 시작하기 초록책 95pg] / private Logger ~     
            +
            추가로 알게된 사실인데 멤버변수를 메서드,생성자에서 그대로 이름그대로 쓸 수 있었다. 그 특유의 파라미터명이 이 멤버변수와 같은
            이름을 쓸때는 못쓰는거고 이럴떄 this.멤버변수명을 쓰는거고 만약 파라미터명과 겹치지 않으면 그냥 그 자체 멤버변수명을 써도 잘
            적용이 됬었다. 또한, 추가로 멤버변수에 다른 멤버변수를 this.멤버변수로 값을 써주어도 정상작동했었다. 그러나 만약에 static을 붙인
            클래스 변수가 있게 되면 우선 위에서 언급했던대로 getLogger(this.getClass());와 같은것은 써주지 못하는 이유가 아직 객체 생성 전이기
            때문에 this가 쓰이는게 불가능한거고 방금 말한거는 이미 객체가 생성되고 나서이기 때문에 가능한거다. 그렇다면 클래스변수를 다른 멤버변수나
            메서드나 생성자에서 사용하려면 어떨까 ? 직접해보니 클래스변수도 멤버변수 다른 변수나 아니면 생성자 혹은 메서드에서 클래스 변수명을
            그대로 사용할 수 있었다. 그러나 this.클래스변수명을 사용하려 할때는 다른 멤버변수나 메서드 혹은 생성자에서는 실제로 사용을 할때
            정상작동은 하였으나 오류를 고치라고 나왔다. 즉, 이 클래스변수는 this.클래스변수로는 왠만하면 사용지 않는게 좋겠다.
            [직접해봄]    
        (1-4).위에 이 Logger에 대해 자세히 설명했으니, 그러면 이어서 @Slf4j와 롬복에 관련해서도 정리하겠다. 이 @Slf4j를 사용하게 되면
            private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(@Slf4j를 쓴 클래스명.class);와 같이 뜨게
            되는데, 여기서 우선 알아야 할 두가지가 이 org.slf4j.Logger와 org.slf4j.LoggerFactory처럼 뜨는것과 클래스명.class로 적혀지게 되는
            것이다. 첫번째로 @Slf4j를 사용하게 되면 org.slf4j.Logger와 org.slf4j.LoggerFActory처럼 코드가 생성이 되는데, 이렇게 사용되는경우
            해당 Logger와 LoggerFactory를 사용하기 위한 import문을 사용할 일이 없어지게 된다. 그래서 실제로 BoardService를 해봤는데 패키지명을
            앞에 전부 붙여주니 import문에서 회색 글자로 표시되서 전혀 쓰이지 않는다고 나왔다. 똑같이 Logger관련 코드를 지우고 @Slf4j만 적어주게
            되니 Logger와 LoggerFactory import문을 아예 안쓴다고 나와있다. 즉, @Slf4j를 사용하게되면 이 Logger와 LoggerFactory import문을
            아예 안써도 될것같다. 두번쨰로 이 @Slf4j를 쓴 클래스명.class와 같이 적었는데, 사실 이것에 대해 알아보려 했으나 이것도 나중에 필요시
            알아보고 여기서는 적어주려는 클래스명.class가 코드가 적힌 클래스의 클래스명이라면 사용할 수 있고, 원래는 파라미터에 변수나 객체 아니면
            이러한 실체가 있는것들만 올렸었는데, 이렇게 클래스명.class 같은것도 올릴 수 있다는 것을 알았다. 이거에 대해 자세한것은 나중에 필요하면
            다시 정리하도록 하고, 우선 이렇게 적어주게 되면 클래스객체를 올려주는것과 동일한 효과를 주는것으로 알고있다. 즉, 해당 클래스의 패키지명과
            클래스명으로 로거의 이름을 짓는것 같다. 이 부분도 만약에 나중에 필요시 더 자세하게 보고싶다면 다시 정리하도록 하자. 또한 추가로 위에 생성되는
            코드에서도 보듯이 변수명은 log로 고정된다고 한다. 또한, import문은 import lombok.extern.slf4j.Slf4j; 와 같았는데, 이는 다른 getter,setter
            나 toString혹은 RequiredArgsConstructor와 같은 롬복 모듈에서 갖고오는건데 차이점은 이 @Slf4j만 패키지를 하나 더들어가서 해당 클래스를
            갖고온다는것 뿐이다. 즉, 다른것들은 import lombok.~으로 갖고온다.
            [직접해봄]    
            [참조링크 : https://fntg.tistory.com/200] / @Slf4j를 사용하게 되면 실제 생성되는 코드    
            [참조링크 : https://inseok9068.github.io/java/java-lombok-slf4j/] / 변수명은 log로 고정된다.
            [참조링크 : https://blog.leocat.kr/notes/2019/10/01/slf4j-test-lombok-logger-is-logging] / 변수명은 log로 고정된다.   
            +
            추가로 아래 프로젝트를 실행시켜야지 그때서야 로거 객체를 만들어준다고 한다.
            [참조링크 : https://blog.leocat.kr/notes/2019/10/01/slf4j-test-lombok-logger-is-logging]    
        (1-5).이제는 이 log.메서드(~)에서 이 안에 ~를 쓸때 String형 변수의 경우 왜 +로 연결시켜서 나타내지 않고 {}를 써서
            매칭을 시켜주어야 하는지 보도록 하겠다. 우선 아래 참조링크를 보면 log 메서드나 System.out.println메서드 상관없이
            String형 변수를 + 연산자를 이용해서 사용해주면 성능에 안좋다고 나와있다. 그래서 아래 System.out.println으로 설명한
            참조링크에서는 StringBuilder, StringBuffer, StringJoiner이 세개를 대신에서 상황에 따라 사용하라고 나와있다. 이것은
            나중에 필요할 시에 다시보도록 하겠다. 또한, 추가로 아래 String.format을 이용해서도 log메서드 부분에 사용하고 있으나
            이 방법도 좋지 않다고 하고 상세한 이유가 나와있는데 이 부분도 나중에 더욱 필요할 때 다시 보도록 하자.
            [직접해봄]    
            [참조링크 : https://data-traveler.tistory.com/22] / String형 변수를 + 연산자로 이용해주면 성능에 좋지않다.(System.out.println(~)이 ~안에서 설명함)    
            [참조링크 : https://enai.tistory.com/36] / String형 변수를 + 연산자로 이용해주면 성능에 좋지않다.(log.메서드(~)이 ~안에서 설명함)   
            [참조링크 : https://eminentstar.tistory.com/77] / log.debug(String.format("Writing to AMQP with %s items", items.size())) 코드
            +
            그렇다면, log.메서드(~)의 ~ 안에서는 이를 어떻게 사용해야할까 ? 바로 {}를 사용해서 이용해주면된다.
            사용법은 아래 참조링크에 나와있고, 단순히 log.debug("나는 {}입니다.",name)처럼 name이 변수이거나 아니면
            직접 값 "홍길동"이런것을 적어주어도 정상적으로 작동한다.
            [참조링크 : https://enai.tistory.com/36] / log.메서드(~)에서 ~의 {} 사용법    
            [참조링크 : https://taetaetae.github.io/2017/02/19/logback/] / {} 사용 코드 예시
            [참조링크 : https://goodteacher.tistory.com/175] / {} 사용 코드 예시    
            [참조문헌 : 스프링부트 시작하기 초록책 107pg] / 여기있는 코드를 {}로 바꿔서 직접 해봤다.
        (1-6).logback 기본 설정 구현체 말고 다른 로그 라이브러리를 사용하더라도(log4j2같은거) 최소한의 설정만 변경하면 바로 사용할 수 있는지, 로그를 사용하는 코드에서도
            왜 특정 로깅 구현체의 패키지를 사용하지 않는지에 대해 정리하겠다. 우선, 아래 logback-spring.xml이 정리된 글을 보면 스프링부트가 가동이 되고 properties
            설정파일을 읽어와서 기본경로인 logback-spring.xml을 읽을지 아니면 다른 경로와 파일명으로 로그백설정파일을 읽어올지 등을 정하며 동시에 properties에서도
            로그백 관련 설정코드가 있으면 적용이 되고 그 다음 로그백 설정파일을 읽어와서 로그백 설정을 한다고 나와있다. 그럼 이 로그백설정과 관련해서는 패키지별로 어느
            로그 level을 정해놓을지 그리고 패키지경로별로 몇개의 로그를 발생시키고 어떠한 형태로 로그를 발생시킬지 어디로 보낼지 관련 설정을 하게 된다. 이런것들은 모두
            로그백에서 설정하게 된다고 한다.(로그 구현체) 여기서 아마 제대로는 아니겠지만, properties설정파일에서 로그 관련설정이나 아니면 로그관련 xml설정파일을 읽는
            경로를 설정하는 코드 혹은 로그관련 xml설정파일내용을 다른 로깅 구현체를 바꾼다해도 수정할것은 없는것으로 보인다. 변경한다면 로그백은 logback-spring.xml을
            설정파일명으로 사용하지만 log4j2는 log4j2.xml을 설정파일명으로 사용하기에 이것만 바꿔주면 되는것같다. 그리고 추가로 만약 log4j2를 사용하게된다면 기존의
            spring-boot-starter-aop나 spring-boot-starter-web에서 logback의존모듈을 사용하지 않는다 설정해주고, log4j2 의존모듈을 추가해주면 되는것으로 알고있다.
            분명 더 알아야 할게 많고 다를 수는 있지만 우선이렇게 알고있자. 그리고 그 이후에 로그를 발생시키는 로거 객체에서도 사실상 아래 logger관련 내용을 보면 알겠지만,
            다른 구현체를 사용한다해서 바뀌는 내용이 하나도 없다. 그냥 getLogger 메서드에서 적용된 로그 구현체 관련 객체가 생성되는 것뿐이다. 이렇듯, 다른 로깅 구현체를
            사용한다하더라도 이를 쉽게 바꿀 수 있다는 내용이 이런 내용이다.
            [직접해봄]    
            [참조문헌 : 스프링부트 시작하기 초록책 92pg ~ 94pg]    
            +
            이제는, 간단하게 왜 위의 (1-3).에 적어놓았던것을 왜 slf4j가 추상체이며 자바의 인터페이스와 비슷한 역활을하고 logback은 로깅 구현체 중 하나
            라고 하는지에 대해 간략하게 설명하겠다. 우선 로그관련 설정파일 xml파일을 사용할때 이는 로깅 구현체에서 주관해서 사용되는것으로 보인다. 즉, 실질적인
            설정은 모두 로깅 구현체에서 하게 되는것이고 로거 객체를 생성할때도 실제로 생성되어 들어가는 객체가 로깅 구현체 관련 객체가 들어가게 되는것이다. 즉,
            내가 봤을때 xml설정파일에서 지정해주면 이 내용들을 바탕으로 로그 관련 설정들을 해주고 Logger형을 사용하고 LoggerFactory를 이용해서 구현체 객체를
            갖고와 사용하게 하는것모두 틀로써 작용하게 되는것이다. 물론 Logger를 사용하는것은 어떠한 구현체를 넣어라도 정상적으로 작동하기 위함이겠지만,
            어쨋든 실제로 Logger가 인터페이스로써 역활도 하기 때문에 이와 같이 얘기가 나오는것같다.
            [직접해봄]    
            [참조문헌 : 스프링부트 시작하기 초록책 92pg ~ 94pg]    
    (2).우선, 고민을 했었다. logback 스프링부트 기본설정 로깅 구현체를 쓸지 아니면 제일 최근에 나왔다고 하는
        log4j2라는 로깅 구현체를 쓸지 말이다. 실제로 log4j2라는 로깅 구현체는 멀티쓰레드환경에서 다른 구현체와는
        다른 월등한 성능효과를 보였다. 하지만, 기본적으로 스프링부트의 기본 설정은 logback으로 되있고, 이전에도 대부분 logback
        을 써왔었다. 만약에 logback사용으로 성능에 문제가 있거나 바꿔야할 필요성을 느끼게 된다면 그때 다시 log4j2 로깅 프레임워크를
        보도록 하자. 그리고 그냥 같이 있어서 정리하지만 원래는 아래 (3)에 정리하는게 더 어룰리지만 함께 참조링크에 있어서 정리하는데
         log4j, logback, log4j2 모두 로깅 구현체라고도 한다고 한다.
        [직접해봄]    
        [참조링크 : https://huisam.tistory.com/entry/log4j2] / log4j2의 월등한 성능 & 로깅 구현체라 부른다. 
        [참조링크 : https://minkwon4.tistory.com/161] / log4j2의 월등한 성능 & 로깅 구현체라 부른다.
    (3).log4j -> logback -> log4j2 순서로 로깅 구현체가 나왔는데, 여기서 이 3개 각각을 모두 로깅 프레임워크라고
        부른다고 나와있다. 이 외에 다른 참조링크들에서도 모두 로깅 프레임워크라 부른다. 근데 또 아래 참조문헌에는 log4j
        , logback 그리고 log4j2를 모두 로그 라이브러리라고 부르고 있다. 이렇다는것만 알아두고 이 부분에 관해서는 나중에 명확하게
        알아야 할 필요가 있을시에 다시 봐보도록 하자.
        [참조링크 : https://madplay.github.io/post/log4j-logback-log4j2] / log4f, logback, log4j2를 모두 로깅 프레임워크라 했다.    
        [참조링크 : https://junshock5.tistory.com/124] / log4j, logback, log4j2를 모두 로깅 프레임워크라 했다.
        [참조문헌 : 스프링부트 시작하기 초록책 92pg] / 여기서는 log4j와 나머지들 logback, log4j2도 로그 라이브러리라 불렀다.   
    [추가사항]    
        1.로그를 사용하는 이유에 대해 보도록 하겠다. 로그를 사용하는 이유는 크게 두가지다. 바로 서비스 동작 상태 파악과  
            특정 api사용에 대한 통계등에 관해서 그리고 장애파악혹은 이로인한 알람이다. 또한, 수민이가 굳이, 로그를 분석해서
            cs관리를 따로 하려는 규모의 웹서비스가 아니면 사실상 에러만 잡아도 되고 나도 ERROR 레벨로만 로그를 잡아서 사용하려고 한다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://m.blog.naver.com/minjincodi/60063653]    
            [참조링크 : https://ahndding.tistory.com/12]    
.
.
.
2.스프링부트에서 로그를 실제로 사용하기 위한 과정에 대해 설명하겠다.
    (1).우선적으로 의존 모듈 설정에 대해 설명하도록 하겠다.
        (1-1).제일 먼저, spring-boot-starter-web 의존 모듈을 추가해준다면 그 안에 spring-boot-starter-logging이라는 모듈이 있어서
            이것이 자동으로 의존 모듈로 추가가 되는거다. 조금 더 이 spring-boot-starter-logging에 대해 알아보자면, 우선, 이 spring-boot-starter-logging
            안에는 logback-classic과 그 외에 두가지 모듈이 더 있다.(이 모듈들 중에 안에 또 다른 모듈도 있긴하다.) 아래 참조링크를 보면, logback을 사용하려면, 
            logback-classic과 logback-core 모듈을 추가해주어야지 logback을 쓸 수 있는것으로 나와있는데, 실제 이 spring-boot-starter-logging모듈안의 
            logback-classic에 logback-core도 포함되어 있어서 logback-core를 따로 추가해주지 않아도 된다.
            [직접해봄]    
            [참조링크 : https://jeong-pro.tistory.com/154]     
            [참조링크 : https://bamdule.tistory.com/29]    
        (1-2).그리고 spring-boot-starter-aop에 관해서인데, 이게 왜 나오냐면 spring-boot-starter-aop모듈도 추가를 해준다면, spring-boot-starter-web에 포함되어있는
            spring-boot-starter-logging과 동일한 모듈이 spring-boot-starter-aop에도 포함되어 있어서 만약에, spring-boot-starter-web과 spring-boot-starter-aop을 
            둘 모듈 모두 의존 모듈로 추가하게 된다면, 기존에 spring-boot-starter-web에 있던 spring-boot-starter-logging 모듈은 사라지고 spring-boot-starter-aop에
            있는 spring-boot-starter-logging으로 의존 모듈을 추가하게 된다. 직접 해본결과다 이렇게 완전히 겹치는 모듈이 있다면 그 중에 하나를 골라서 한쪽에 있는것을 모듈로 
            추가해주고 다른 모듈에 포함되어있는것은 아예 포함시키지 않는것같다.
            [직접해봄]    
        (1-3).spring-boot-starter-logging 모듈안에 logback-classic모듈말고도 또 두가지 모듈이 더 있다고 말했다.(당연히 어떤 모듈은 그 안에 또 다른 모듈을
            또 포함하기도 한다.) 근데, 이 두가지 나머지 모듈에 대해서는 사실 따로 설명한 참조링크들이 없었다. 그리고 slf4j를 사용하는데 있어서도 따로 모듈을 의존
            대상으로 추가해주지 않는데, 이 spring-boot-starter-logging에 있는 나머지 모듈들이 이 역활들을 해주는것으로 이해하고 있자.
            [직접해봄]    
        [정리]    
            이렇게, spring-boot-starter-aop혹은 spring-boot-starter-web만 추가해주면 로그는(logback 구현체) 그대로 사용할 수 있다.
            [직접해봄]     
    (2).그 다음은 로그를 사용하기 위한 설정파일 혹은 이 설정과 관련된것에 정리 하도록 하겠다.
        (2-1).우선적으로, 순차적으로 적용되는 방식에 대해 알아야 한다. 아래 참조링크들을 보면, 우선적으로 logback(로그백) 관련 설정을
            해야하는데, 보통 스프링부트(스프링에서는 진행하지 않을꺼니 나중에 필요시보고)가 구동하기전에 logback은 설정을 할 설정파일을 자동으로 찾는데, logback내부에서 먼저 
            logback.groovy -> logback-test.xml -> logback.xml 순으로 찾아서 로그백 설정을 한다고 한다.(근데, 이게 resources 바로 아래에서 찾는건지는 안나왔다.) 그런다음에, 
            스프링부트가 구동이되고, 스프링부트에서 로그백 설정을 해주기위해 기본 클래스패스 resources아래에 기본 설정파일명인 logback-spring.xml을 찾아 로그백 관련
            설정을 또 하게 된다.
            [참조링크 : https://jeong-pro.tistory.com/154] / 스프링부트가 구동되기 전 즉, 스프링부트에서 로그백관련 설정 전에 로그백설정을(logback.xml등) 하게된다.    
            [참조링크 : https://supawer0728.github.io/2018/04/07/spring-boot-logging/] / 스프링부트가 구동되기 전 즉, 스프링부트에서 로그백관련 설정 전에 로그백설정을(logback.xml등) 하게된다.    
            +
            여기서 보아야 할 것들이 있는데, 우선 이 스프링부트 가동전에 로그백 자체 내에서 로그백 설정을 하게 된다는것은, 스프링부트 연동으로 설정된것이 아니라서
            만약, 내가 로그백 설정파일을 logback-spring.xml로 안하고 클래스패스에 logback.xml로 파일명을 써놓으면 스프링부트가 구동전에 로그백 내에서 자체적인 설정에서
            이 파일을 가져다가 로그백 설정을 하게 되는것같다. 그런데, 원래는 스프링부트에서는 logback-spring.xml을 사용해서 스프링부트에서 로그백을 구동할 수 있도록 
            지원해줌으로써 프로필이나 application.xml에 설정된 properties등을 읽어올 수 있다고 한다.(이 부분은 나중에 필요시 자세하게 알아보겠지만, 간단하게 말하면 아래 참조링크처럼 
            로그백을 커스텀하거나 추가 기능 설정등을 가능하게 해주는데( logback-spring.xml사용시) 만약에, 이 logback.xml명으로 로그백을 설정하게되면 방금 써놓은 추가기능이나
            로그백 커스터마이즈를 할 수 없다고 한다. 즉, 이해하는 방향이 스프링부트로 연동해서 로그백 설정이 된것이 아니기때문에 한번 logback.xml로 설정된것은 스프링부트에서
            변동시킬 수 없다고 보는게 나을것같다.(만약에 틀릴 시 나중에 다시 정리)
            [참조링크 : https://supawer0728.github.io/2018/04/07/spring-boot-logging/] / logback-spring.xml을 사용하면 프로필이나 각종 properties을 적용할 수 있다.   
            [참조링크 : https://gaemi606.tistory.com/entry/Spring-Boot-logbackxml-%ED%8C%8C%EC%9D%BC-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95] / logback-spring.xml로 로그백설정을 해야 커스텀 할 수 있다고 한다.   
            [참조링크 : https://dadadamarine.github.io/java/spring/2019/05/01/spring-logging-xml.html] / logback.xml로 파일명으로 설정하면 로그백과 스프링부트를 연동해주는 '스프링부트' 설정전에 로그백 설정이 되어서 로그백 관련 제어나 추가 기능설정이 불가한것같다.
            [참조링크 : https://goddaehee.tistory.com/206] / logback-spring.xml을 이용하여 스프링부트가 logback을 구동할 수 있게 지원하며 이를 이용하여 프로필을 이용하고, application.xml에 설정된 properties를 읽어올 수 있다고 한다.
            +
            아래 참조링크를 보면 스프링부트의 로그백 기본 설정방법은 application.properties와 resources/loback-spring.xml
            그리고 resources/logback.xml이 3가지가 있다고 한다. 또한, 스프링이나 자바 프로그램의 경우 logback.xml로 resources디렉토리에
            만들어서 로그백 설정을 한다고 하는데, 여기서도 아마 로그백 커스터마이즈가 안되는것으로 알고있다. 이 부분도 나중에 필요시 더 자세하고
            정확하게 정리하도록 하자.
            [참조링크 : https://yjh5369.tistory.com/483]
            +
            진짜 추가적으로 얘기하자면 아래 참조링크를 보면, profile쓰는것이 나와있다. 아마도, 커스터마이즈란 이런 프로필을 쓰는것으로
            이것을 스프링부트 연동 로그백 설정에서만 사용할 수 있는것으로 보아 로그백 설정파일명을 logback.xml으로하면 이러한 연동에서 주는
            기능을 못쓰지 커스터마이즈 혹은 profile등의 기능을 못쓴다고 하나보다. 나중에 필요시 더 자세하게 보도록 하자.
            [참조링크 : https://m.blog.naver.com/cutesboy3/221933485820]    
        (2-2).부수적으로 알아야 할 것이 만약에 스프링부트에서 로그백을 설정해주는 클래스패스와 설정파일명을 변경하고 싶다면
            아래와 같이 스프링부트에서 적용되어지는 properties파일에 이것만 적어주면 된다. logging.config=classpath:logback/logback-config.xml
            이렇게 적어주게 되면, 클래스패스는 resources안에 logback이며, 설정파일명은 logback-config.xml이 되게 된다. 추가로 이 문장
            위에 #logging config 같은 주석도 적어주면 좋다.
            [참조링크 : https://aljjabaegi.tistory.com/413]    
            [참조링크 : https://coding-start.tistory.com/186]    
        (2-3).위에서 추가적으로 알아야 할 과정이 무엇이냐면, 스프링부트 가동전에 로그백내에서 알아서 로그백관련 설정파일을 찾아서 로그백 설정을 하게되고, 
            그 다음 스프링부트가 가동이 된 다음에, properties 설정파일에서 logging.config=classpath:~ 와 같은 문장이 있으면 읽어서 반영을 하고 없으면 그냥
            기본 클래스패스에 logback-spring.xml설정파일명을 찾아서 로그백 설정을 하게 된다.(이거는 내가 생각한거지만, 나중에 틀릴시에 다시봐보도록 하자.) 근데
            여기서 그 후에 .yml이나 .properties파일에서 로그백 관련설정을 또 읽어가는데(위의 properties설정파일의 logging.config관련과는 다른거로 보는게 좋겠다.)
            , 그렇게 되면 .yml(.properties)에 있는 로그백 설정파일을 적용 후에 xml파일의 로그백 설정을 적용한다고 한다. 자세한 사항은 나중에 .yml이나 .properties로
            로그백 설정을 하게 된다면 알아보면 될 것 같다. 내 생각에는 다시 봐보니, 이 properties에서 로그백 xml설정파일에 관한 logging.config=classpath:~가 있으면
            이것을 적용하고 동시에 로그백 설정이 이 properties파일에 있으면 이것부터 적용하고 나중에 xml파일을 적용한다로 이해하면 될것같다.
            [참조링크 : https://goddaehee.tistory.com/206]    
            +
            .yml이나 .properties로 로그백 설정도 가능하지만, 할 수 있는 기능이 많지 않다고 한다. 그래서 실제 어느 정도
            규모가 있는 서비스를 운영하기 위해서는 xml파일로 설정해 두는것이 좋다고 한다. 또한 스프링부트 시작하기 초록책에서도
            따로 .yml이나 .properties를 이용해서 로그백을 설정하지 않았었다.
            [참조링크 : https://gofnrk.tistory.com/108]    
            [참조문헌 : 스프링부트 시작하기 초록책 93pc]    
        (2-4).그렇다면, 이제 그 다음은 logback-spring.xml설정파일에 대해 알아보도록 하겠다.
            (1).제일먼저 logback-spring.xml파일에 맨 앞에 적혀져 있는 <?xml version="1.0" encoding="UTF-8"?>에 대해
                보도록 하겠다. 이 xml파일 선언부는 79번쯤되는 xml파일 관련 정리문서에 잘 설명되어있다. 여기서는 그보다, 이 xml
                파일이 근본적으로 어떤 용도인지에 대해 알아보겠다. 아래 참조링크를 보니, xml파일은 데이터들을 쉽게 구조화 해서
                전달하기 위해 만들어진 문서 형식이라고 한다. 즉, 데이터를 전송하기 위한 하나의 매게체로 보면 될 것같다.
                [참조링크 : https://hi098123.tistory.com/96]    
                +
                어느 참조링크나 참조문헌을 봐도 이 xml선언부에 standalone을 사용하는것을 못봤다.
                mapper.xml에서도 못봤고, 이것은 그냥 주어진데로 생략해서 사용하고 나중에 더 자세히
                알아야할 때 다시 봐보도록 하자.
                [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/]     
                [참조링크 : https://jeong-pro.tistory.com/154]    
                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
            (2).그 다음은, <configuration>에 대해 보도록 하겠다.
                우선은, 모든 logback-spring.xml파일을 보면 선언부 다음에 항상 이 <configuration>태그가 나왔다. 한 번의 예외도 없이
                나왔다. mapper.xml파일을 봤을때도, <mapper>가 나왔었는데 이와 비슷하게 정리하자면, 이 <configuration> 태그 안에 로그백설정
                관련 태그들을 적어야 적용되는것으로 보인다. 다른 참조링크에 대해 정확히 그렇다고 명시된것은 없지만, 다른 참조링크에서 항상 이 <configuration>
                태그를 쓰고 아래 두 참조링크에서도 <configuration>태그 내에 로그백 설정 태그들에 대해 적어야 된다고 나와있다. 즉, 정리하자면 이 
                <configuration>태그는 스프링부트에서 로그백설정을 하기위해 logback-spring.xml파일을 읽어가 설정할때, <configuration>태그를
                일종의 기준점, 즉 일종의 있어야할 필수 구조중 하나로 보고 이것을 기준으로 긁어가서 이해하는것같다.
                [참조링크 : https://dololak.tistory.com/631]    
                [참조링크 : https://ckddn9496.tistory.com/79]    
                +
                이 <configuration> 태그는 내부에 최대 1개의 root 태그만을 갖고, 0개 이상의 appender와 logger태그를 가질 수 있다고
                한다. 사실 어떻게보면 당연한 이야기지만, 여러 참조링크중에 이러한 얘기가 따로 있어서 정리해 보았다. 나중에 더 자세히 봐야한다면
                그때 다시 알아보도록 하자.
                [참조링크 : https://ckddn9496.tistory.com/79]    
                +
                이 <configuration>태그에는 여태까지 봐왔던거랑 참조링크를보면, 두가지 속성에 관해 나오는데 첫번째 속성은 debug라는것이다.
                이 debug의 값은 false와 true가 있는데, 간단하게 말하면 만약 debug="true"를 작성하게되면, 어떠한 기능이냐면 이 logback-spring.xml
                이라는 설정파일을 분석하는 동안 경고 또는 에러가 발생하면, Logback은 내장 상태 시스템에 의해 콘솔에 내부 상태 데이터를 자동으로 출력
                한다는것이다. 또한, 만약 코드를 작성하는 개발자가 이 내부 상태 수신 코드를 명시적으로 등록할 경우에는 중복을 제거하기 위해 loback의
                자동 상태 출력 기능은 비활성화가 된다고 한다. 즉, 이거는 logback설정파일을 분석할때 경고 또는 에러발생시에 로그를 출력하기위한 기능으로
                이 configuration태그의 속성값으로 설정할 수 있는것 같다. 또한, 콘솔이라 했는데 이것은 나중에 더 제대로 알아야 할 필요가 있을때 다시보도록하고
                우선, debug="true"로 속성 설정값을 설정하고 사용하는게 좋을것같다. 또한, 어딜봐도 이 debug속성의 기본값에 대해서는 나와있지 않은데, 아래
                참조링크를 보면 만약 debug속성값을 false로 사용하고 싶다면 그냥 속성자체를 지우면 된다고 한다. 그러는것보니 기본값은 false인것같다. 이것도
                나중에 더 자세하게 알아봐야한다면 다시 봐보도록 하자.
                [참조링크 : https://ckddn9496.tistory.com/78]    
                [참조링크 : https://kouzie.github.io/spring/logback/#logback-xml-%EC%84%A4%EC%A0%95]    
                [참조링크 : https://pythonq.com/so/logback/24150]    
                [참조링크 : https://ckddn9496.tistory.com/79] / 여기서 configuration파일이란 로그백 설정파일인 logback-spring.xml을 의미한다.
                [참조링크 : https://pythonq.com/so/logback/24150] / debug의 값을 false로 하고 싶다면 제거하거나 false라고 값을 명시해주라고 한다.
                +
                두번째 속성으로는 scan="true"와 scanPeriod="30 seconds"가 있다. 이거는 true로 놓으면 해당 초 주기마다(여기는 30초라고 적어놓았다.)
                logback-spring.xml이 바뀌었는지 검사하고 바뀌었으면 프로그램에서 갱신한다고 한다. 즉, 이 기능은 서버를 재시작 하지 않아도 해당 로그백
                설정파일을 다시 읽어봐 서버를 재시작 하지 않아도 되는 기능이다. scan의 기본값은 false로 보고 있으며, scanPeriod="60 seconds"로 60초
                등 초로 맞춰서 사용할 수 있다. 만약 scan="true"로 맞춰놓고 scanPeriod를 맞춰놓지 않으면 디폴트는 60초라고 한다. 근데, 사실상 ec2 인스턴스에 올리고
                배포하여 사용하는 경우에는 어떻게 서버 재시작을 하지않고 올린다는것인지는 모르겠다. 이것도 나중에 필요하면 다시보고 맨 아래 참조링크에 보면, scan을
                할때 너무 자주 하게 하면 disk io가 증가해서 오히려 부담이 될 수 있다고 한다. 즉, 우선은 이 기능은 사용하지 않도록 하고 나중에 필요시에 사용하도록 하고
                그때 필요한 만큼 다시 더 자세히 보도록 하자. 스프링부트 시작하기 초록책에서도 적혀있찌 않은 속성값이였다.
                [참조링크 : https://jaehyun8719.github.io/2019/05/15/utils/logback/]    
                [참조링크 : https://goddaehee.tistory.com/206]    
                [참조링크 : https://ming9mon.tistory.com/150]    
                [참조링크 : https://linkeverything.github.io/springboot/spring-logging-runtime/]     
            (3).여기에서는, <appender>와 <logger>를 한번에 정리하도록 하겠다.
                (3-1).이 <appender>와 <logger>에 대해서 들어가기전에 먼저 알아두어야 할 것이 있다. 이걸 알아두면 이해하기 더 편할것으로 보고있다.
                    바로 로그는 전부다 발생하고 그걸 형식에 맞게 그 로그들을 갖고오는게 아니라, 애초에 <logger>나 <root>마다, 주어진 조건에 맞는것만,
                    로그를 발생시키고 가져오는것으로 보인다. 아래에 설명하면서 더 구체적으로 봐보도록 하겠다. 일종의 순서를 얘기하자면, 이 로그백 설정들이
                    적용이되고 패키지경로에따라 로그 레벨이 정해지고 그 다음, root나 logger의 name에 따라 additivity를 적절히 적용되어서 해당되는 패키지경로에서
                    지정된 로그 레벨 이상만 로그를 발생시키고 각각 console이나 db등 보내게 되는거다. 근데, 이때 각각의 root나 logger에 지정된 <patter>에 따라
                    로그를 각각 발생시키고 가져가게 되는거다.
                    [직접해봄]
                    +
                    Logback-spring.xml은 <appender>와 <logger>이렇게 크게 두개로 구분된다고 한다. 다른 관련 참조링크들도 그렇고 대부분
                    이렇게 얘기 한다.
                    [직접해봄]      
                    [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0]    
                    [참조링크 : https://goddaehee.tistory.com/206]      
                (3-2).이번엔 <appender>태그에 대해 알아보도록 하겠다.
                    1.우선 이 appender태그의 의미부터 알아야 하는데, 이 loback-spring.xml이 적용되는 방향과 의미하는 바를 먼저 알 필요가 있다.
                        이게 실제로 정확히는 안맞을지 몰라도 이렇게 이해하는게 좋을것같다. 우선, 이 logger는 하나의 태그이자 요소로 이것 자체가 주체가
                        되는게 아니라 하나의 설정인것이다. 그렇게 보고 시작해야한다.
                        이 appender라는 요소 안에는 name과 class라는 속성이 있다. 아래 더 자세히 볼 거지만 간략하게 말하면, appender태그는 마치 logger태그내의
                        <appender-ref>태그의 ref 속성으로 연결시켜주어서 순서가 있을것같지만, 실제로는 이 logger태그와 연결된 appender태그의 속성들을 한꺼번에 적용시키는것이라
                        실제 사용되는것에서는 순서가 없이 각각 요소의 속성들의 기능에 맞게 적용이 되는거다. 이 말을 하는 이유는 아래 <logger>에서 알게 될거다. 본격적으로
                        appender의 속성인 name부터 보자면, 이는 단순히 appender를 나타내는 명칭으로, logger에서 <appender-ref>에서 지정해서 사용하는것이며, class는 발생된로그를
                        갖고와서 콘솔이나 db나 파일로 만들어줄것인지 정하는것이다. 그리고 마지막으로 하위에 있는 <pattern>이라는 요소는 여기에 지정된 값들을 적용을해서 로그를 발생시킬때
                        이 형식에 맞게 로그를 발생시키는거다.
                        [직접해봄]      
                    2.여기서는 appender 태그의 name 속성에 대해 보도록 하겠다.
                        사실은, 이 appender태그의 name속성은 그렇게 크게 의미가 없으나 아래에 보다시피 필수로 적어주어야 한다. 여기에다가
                        name값 즉 이름을 지어주게 되면 logger의 하위요소인 appender-ref요소에서 값을 지정하여 사용하게 되는것이다. 즉, logger와
                        연결시키기 위한 이름작명 정도라고 알면된다.
                        [참조링크 : https://ckddn9496.tistory.com/79] / name속성은 appender의 이름을 명시       
                        [참조링크 : https://gs.saro.me/dev?tn=479] / name속성은 appender의 이름   
                        +
                        아래 나와있는 참조링크들을보면, name속성은 필수로 지정해주어야 한다고 한다. 즉,
                        appender요소의 name속성은 필수로 지정해주어야 한다고 나와있다.
                        [참조링크 : https://goddaehee.tistory.com/206] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                        [참조링크 : https://ckddn9496.tistory.com/79] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                        [참조링크 : https://yjh5369.tistory.com/483] / logger요소의 name속성을 적어주는것은 필수라고 한다.                        
                    3.그 다음은 <appender>태그의 하위 요소인 <encoder>와 <pattern>그리고 <layout>에 대해 보도록 하겠다. 사실 순서로 따지면 appender태그의 class속성을
                        보는게 먼저이나, 개념 이해를 하려면 이 <encoder>와 <layout>그리고 <pattern>에 대해 먼저 보는게 좋을것같아서 먼저 정리 한다. 우선
                        <encoder>태그와 <layout>태그에 대해 정리하도록 하겠다. 
                        [직접해봄]    
                            (3-1).이 <encoder>와 <layout>에 대한 개념인데, 우선 아래 참조링크를 보면 참조링크의 ConsoleAppender에 관한 설명에서
                                appender태그가 출력되는 로그의 형식을 직접 가지고 있지 않고, 해당 기능은 layout이나 encoder에 위임해서(<patter>포함) 여기서 layout이나
                                encoder에 적혀있는 클래스를 인스턴스화 시켜 appender에 주입되어져서 사용되는것으로 알고있다. encoder나 layout의 class속성의 값이란,
                                아래 참조링크를 가보면 class속성에 명시할 값들이 써져있는데, 이거를 이용하는것으로 알고있다. 그러나 콘솔, sentry의 경우에는 대부분 모두
                                encoder방식을 사용하고 따로 class속성의 값을 명시하지 않으며, slack관련 appender를 사용하는 경우에는 encoder로는 안되고 layout으로
                                사용해야 하는것같다. 이 부분 아래에 좀 더 설명하겠다.
                                [참조링크 : https://github.com/sonegy/how-to-use-logback] / 로그 출력될 형식을 appender에서 직접가지고 있지않고, layout과 encoder에서(당연 하위 <pattern>포함)) 해당 class속성에 맞는 클래스를 생성해서 appender에 주입한다고 한다.  
                                [참조링크 : https://ckddn9496.tistory.com/79] / encoder와 layout의 class속성에 명시할 값`나열    
                                +
                                완벽하게는 아니지만 조금 더 부가설명을 하자면, layout과 encoder에서 둘 중에 보통 1개만 사용하는것으로 보이며,(여태 참조링크들 모두 그랬다.
                                이 부분도 나중에 다시 봐야하면 다시 보기) 아래 참조링크를 보면, <appender>태그에는 0개 또는 1개의 <layout>태그와 0개 이상의 <encoder>태그를 
                                가질 수 있다고 나와있다.(이것도 나중에 필요시 더 자세히 보기) 또한, 아래 두번쨰 참조링크를 보면, 같은 appender태그의 class 속성값에 대하여, 즉,
                                appender태그의 class 속성값이 console관련 설정인데 이것을 사용하기 위해서 layout방식이나 encoder방식 태그 둘다 사용할 수 있고, layout방식은 
                                옛날방식이고 encoder가 요새 사용하는 방식이라 나와있는것보니, layout이나 encoder 둘다 본질적으로 기능은 같으나 좀 더 상향된 기능을 갖고있는 방식이
                                encoder라고 보면 될것 같다. 실제로 아래 참조링크에 차이점도 나와있다.
                                [참조링크 : https://ckddn9496.tistory.com/79] / <appender>태그에는 0개 또는 1개의 <layout>태그와 0개 이상의 <encoder>태그   
                                [참조링크 : https://jeong-pro.tistory.com/154] / layout방식은 옛날방식이고 encoder가 요새 사용하는 방식 & layout과 encoder의 차이점
                                +
                                위에서 설명한대로, 다른 참조링크들이나 참조문헌에 보면 콘솔이나 sentry로 appender class를 사용하는 경우에는,
                                이 <encoder>태그에 class속성을 따로 명시하지 않는곳이 대부분이였다.(물론 명시한곳도 있지만 구지 필요하지 않은것 같다. 바로 아래의 + 추가글을 보고
                                참조링크를 보면, 기본적인 인스턴스화 시킬 class값이 지정되어있는것 같다. 이 부분도 필요시 더 자세히 보도록 하자.) 또한, slack으로 appender class를 
                                지정한 경우에는, <encoder>로는 class값을 적어주던 아무것도 안적어주던 작동하지 않았었다. 즉, layout태그로만 사용을 했어야했고 class값으로 
                                ch.qos.logback.classic.PatternLayout를 적어주고 사용했었다. 직접해보니 class값을 적어주지 않아도 작동은 했는데 다른 참조링크들에서 
                                모두 적어주니 나도 참고해서 적고 사용하기로 하자.(나중에 필요시 이 부분 다시 정리하도록 하자.)
                                [직접해봄]    
                                [참조문헌 : 스프링부트 시작하기 초록책 93pg] / 콘솔,encoder예시    
                                [참조링크 : https://coding-start.tistory.com/186] / 콘솔,encoder예시     
                                [참조링크 : https://m.blog.naver.com/cutesboy3/221933485820] / sentry,encoder예시
                                [참조링크 : https://zorba91.tistory.com/311] / sentry,encoder예시   
                                [참조링크 : https://bum752.github.io/posts/logback-slack-appender/] / slack, layout예시      
                                [참조링크 : https://rutgo-letsgo.tistory.com/125] / slack, layout예시    
                                [참조링크 : https://devlog-wjdrbs96.tistory.com/327] / slack, layout예시       
                                +
                                조금 더 바로 위에 내용에 대해 보충하자면, 이 encoder나 layout의 class속성값은 아래 첫번째 참조링크처럼 인스턴스와 시킬
                                클래스가 나열되어 있다. 그러나, 위에서 encoder에 class속성값을 따로 명시하지 않는 경우는 자동으로 적절한 클래스를 인스턴스화
                                시켜서 appender태그에 적용시켜주거나 하는것 같다. 아니면 굳이 직접 class값을 적어서도 사용하는것 같기도 하다.(이 부분 나중에 필요시 더
                                자세히 보도록 하자.) 또한, 두번째 참조링크를 보면, appender태그의 class속성값으로 FileAppender 가 있는데 이는 하위 태그로 encoder를 
                                필요로 하고 layout은 사용하지 않는다는것을 보니 위에서 encoder가 layout보다는 상향버전 이라는것과 각 appender 태그의 class속성값에 따라 즉, 
                                어디로 보내주냐는 그 값에 따라 encoder를 쓸 수 있고 layout을 쓸 수 있거나 아니면 둘 다 쓸 수 있는게 있는것 같다. 아래 (3-2). 
                                slack appender 설정에서도 이를 보여줄거다.
                                [참조링크 : https://ckddn9496.tistory.com/79]    
                                [참조링크 : https://goddaehee.tistory.com/206]    
                            (3-2).<appender> 태그의 class속성값이 SlackAppender인 경우 <layout>에 대해정리
                                우선적으로 내가 이 SlackAppender를 사용하는 경우에는 <encoder>로는 사용할 수 없었다. <encoder>를 사용하는 경우 위에서 설명한것처럼
                                정상적으로 작동하지 않았고, <encoder>에 class값을 직접 써주었는데도 정상적으로 작동하지 않았다. <layout>태그만 적어주거나 아니면 <layout>
                                태그내에 class속성값을 적어주는경우 둘다 정상적으로 작동했다. 그러나 한가지 더 얘기하자면, 대부분 참조링크에서 이 layout태그내에 class속성값
                                을 적어주어서 사용하니 나도 그렇게 사용하는것으로 하자.
                                [직접해봄]    
                                [참조링크 : https://dundung.tistory.com/232] / 쓰임예시   
                                [참조링크 : https://bum752.github.io/posts/logback-slack-appender/] / 쓰임예시     
                                [참조링크 : https://rutgo-letsgo.tistory.com/125] / 쓰임예시     
                                [참조링크 : https://devlog-wjdrbs96.tistory.com/327] / 쓰임예시     
                            (3-3).<pattern>에 대해서 정리하도록 하겠다.
                                우선 사용하는 기본 방법은 이 <pattern>~</pattern>처럼 ~ 안에다가 값을 넣어서 패턴을 적용시키는 거다.
                                기본적으로 알아야 할 몇가지에 대해 설명하고 추가로 설명한다음 정리하도록 하겠다. 우선 %d가 있는데 이는 로그 기록시간을
                                의미한다. 그 다음 %p는 로그 레벨을 의미한다. 즉, ERROR인지 INFO인지 나타내는 거다. 그리고 %c가 있는데, 이는 로깅이 발생한
                                카테고리 즉, 풀패키지명(클래스명 포함)을 나타낸다.(직접해봤다.) 그 다음 %m이 있는데, 이는 로그 메세지를 의미했었다. 마지막으로
                                %n은 줄바꿈의 기능을 했었다. 추가로 말하자면, %d의 시간은 초단위 바로 아래 시간단위까지 나왔으며 %p말고도 %5p라고 적어주게 되면,
                                우측 정렬로 로그 레벨을 남기는것인데, 로그레벨이 5글자가 안되면 왼쪽에 공백을 추가하여 5글자를 맞추는 방식이다. 반대로 %-5p의 경우는
                                좌측정렬인데 굳이 필요할것같진 않다. 또한 방금 본 내용들은 아래 참조문헌에서 사용한것을 갖고온것이다.
                                [직접해봄]    
                                [참조링크 : https://kwonnam.pe.kr/wiki/java/log4j/pattern] / %5p와 %-5p의 우측 정렬과 좌측 정렬에 대한 내용    
                                [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0] / 위에 쓰인 %문자에 대한 내용    
                                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
                                +
                                그렇다면 이제, 그 외의 것들에 대해 보도록 하겠다. 메서드명도 해야할거같은데 다른 참조링크들을보면 여러가지 방식으로 로그를 설정해놓았다.
                                만약 부족한게 있다면 아래참조링크들에서 필요한 %~를 찾아서 더 적도록 하고 그 외에는 나중에 필요시 하도록 하겠다. 여기서는 %M이라는 메서드명만
                                추가해서 사용하도록 하겠다.
                                [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0]    
                                [참조링크 : https://coding-start.tistory.com/186]    
                                [참조링크 : https://yjh5369.tistory.com/483]    
                                [참조링크 : https://goddaehee.tistory.com/206]        
                                +
                                만약 이 <pattern>안에 내용을 아무값도 적어주지 않거나, 아니면 아예 <pattern>만 지우거나 아니면 <encoder>까지 함꼐 지우거나해도
                                아예 프로젝트 시작도 못하고 fail이 떳었다. 아니면, 아예 logback-spring.xml을 지우니, 로그가 뜨는 방식이 조금 달랐는데 알 수 없는
                                로그 내용도 떳었었다. 또한, 원래는 <logger>같은거에 log level을 지정해주지 않으면 DEBUG이상만 로그를 보여줬었는데, 이 logback-spring.xml 로그백 설정
                                파일을 아예 지우니 로그가 생기는것들이 INFO레벨 이상만 떳었다. 아래 참조링크에 아무 설정안할경우 로그레벨과 로그 내용에 관해 적어놨는데, 첫번째
                                참조링크의 내용과는 많이 다르고 두번째 아무설정 안할경우의 참조링크에서 설명하는 내용과 흡사했다. 이 부분도 나중에 정확히 알아야 한다면 다시
                                정리하도록 하자.
                                [직접해봄]    
                                [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/] / 아무설정 안할경우 로그    
                                [참조링크 : https://velog.io/@max9106/Spring-Boot-%EB%A1%9C%EA%B9%85-3nk6avy3vm] / 아무설정 안할경우 로그           
                            [추가사항]    
                                내가 %M을 사용하기위해 <pattern>안에다가 (%M)으로 사용을 했는데 아예 logback-spring.xml 자체가 오류를 일으켜서인지 뭔지 그냥 아예 모든 로그레벨 자체가
                                발생하지 않고 보이지도 않았다. 그래서 xml파일 형식의 문제인줄알고 알아봤는데 또 그것도 아니였다. 즉 그러면 이 logback-spring.xml인 로그백 설정 파일에서는
                                ()를 <pattern>에 쓰면 안된다는것을 알고가자. 그래서 그냥 ~ [%c] %M %m%n ~ 과 같은 형태로 적용하기로 하자. 
                                [직접해봄]                 
                    4.그 다음은 <appender>의 class 속성에 대해 보도록 하겠다.
                        먼저 class속성에는 적을 수 있는 값들이 여러개 있다. 파일에 저장할지 아니면 DB에 저장할지 등등 여러가지가 있는데,
                        내가 할것은 1.콘솔 과 2.Sentry 그리고 3.slack에 넘겨주는 세 방식만 보도록 하겠다. 나머지 방식들에 대해서는 나중에 필요시 보도록 하고
                        아래에 하나하나 차근차근 설명하도록 하겠다. 그 외에 DB나 파일로 저장하거나 기타 다른방식들은 class에 해당하는 속성값을 넣어주고 하위 태그에 
                        여러 다른 태그들을 넣어주나 이것들은 그때 나중에 필요한경우에 알아보도록 하겠다.
                            (3-1).console에 로그를 보내는 경우 
                                우선 class 속성값을 ch.qos.logback.core.ConsoleAppender로 넣어주면 된다.
                                그 외에 다른 설정을 없는것으로 보이며 아래에 코드예시들이 담긴 참조링크들을 적도록 하겠다.
                                [직접해봄]           
                                [참조링크 : https://coding-start.tistory.com/186]    
                                [참조링크 : https://m.blog.naver.com/cutesboy3/221933485820]    
                                [참조링크 : https://zorba91.tistory.com/311]    
                                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
                            (3-2).sentry에 로그를 보내는 경우
                                우선 class 속성값을 io.sentry.logback.SentryAppender로 넣어주면 된다.
                                그 외에 다른 설정을 없는것으로 보이며 아래에 코드예시들이 담긴 참조링크들을 적도록 하겠다.
                                [직접해봄]    
                                [참조링크 : https://m.blog.naver.com/cutesboy3/221933485820]    
                                [참조링크 : https://zorba91.tistory.com/311]    
                            (3-3).slack에 로그를 보내는 경우
                                우선 class 속성값을 com.github.maricn.logback.SlackAppender로 넣어주면 된다.
                                그 외에 다른 설정을 없는것으로 보이며 아래에 코드예시들이 담긴 참조링크들을 적도록 하겠다.
                                [직접해봄]    
                                [참조링크 : https://bum752.github.io/posts/logback-slack-appender/]    
                                [참조링크 : https://rutgo-letsgo.tistory.com/125]    
                                [참조링크 : https://devlog-wjdrbs96.tistory.com/327]    
                            [추가사항]    
                                1.추가로 아래 참조링크를보면, class속성을 필수로 적어주어야 한다고 나와있다.
                                    [참조링크 : https://ckddn9496.tistory.com/79]        
                (3-3).이번엔 <logger>태그에 대해 알아보도록 하겠다. 
                    1.우선 이 logger태그의 의미부터 알아야 한다. 이 loback-spring.xml이 적용되는 방향과 의미하는 바를 먼저 알 필요가 있다.
                        이게 실제로 정확히는 안맞을지 몰라도 이렇게 이해하는게 좋을것같다. 우선, 이 logger는 하나의 태그이자 요소로 이것 자체가 주체가
                        되는게 아니라 하나의 설정인것이다. 그렇게 보고 시작해야한다.
                        이 logger라는 요소 안에는 name과 level 그리고 하위요소로 <appender-ref> 라는 요소가 있다. 자세히 볼 거지만 간략하게 말하면, level은 내가 
                        설정해놓은 레벨이상의 로그로 구역으로 지정하고, name은 로그가 발생했을시에 해당 범위(name)만큼에서 level에 맞는 로그들만 발생시키고 갖고오게 된다. 
                        좀 더 말하자면, 이 level과 <logger>의 name과 <root>로 적용되어서 만들어져야할 로그의 갯수와는 전혀 독립적인 관계인거다. 서로 독립적으로 생각해야한다. 그런데, 이때
                        <appender-ref>태그의 ref속성값은 <appender>태그와 연결하는것으로 이때 위의 (3-2).에서 말했다시피, <logger>와 <appender>가 적용된 기능들이 한번에 적용되는것이라고 
                        했는데 즉, 위의 <appender>내의 <pattern>에 해당하는 값들이 적용이되어서, 방금 로그들이 발생한다할때 이 pattern의 형식에 맞춰서 발생이 되고 가져오게되는거다. 
                        그리고나서 이 갖고온 로그들을 해당 <appender>요소의 속성중 하나인 class의 값에 맞게 로그들을 보내게 되는거다. 또한, 아래 name에서 더 정확하게
                        다루겠지만, 이 <logger>나 <root>로 name에 해당하는것을 여러개 적용할 수 있다. 자세한것은 아래에서 설명하겠다. 또한, additivity속성도 name에서
                        더 정확하게 하겠다.
                        [직접해봄]    
                    2.여기서는 이 name에 대해 더 자세히 보도록 하겠다.        
                        그럼 이 name의 역활은 무엇이냐는 거다. 이 name에는 값을 넣어주는건데, 무슨 값을 넣어주냐면
                        패키지명을 적어주는거다. 그런데 다른 참조링크에서도 봤는데 풀패키지명을 적어주어야 정상적으로 작동한다.(근데, 그 링크 까먹음..)
                        그리고 실제로도 풀패키지명이 아닌 그냥 디렉토리로 적어서 해봤는데 정상적으로 작동하지 않았었다. 풀패키지로 적으니 정상작동했다.
                        그렇게 패키지명을 적게되면 해당 패키지명 이하 패키지를 일종의 영역인거다. 그렇게 해서 root는 전역이 영역인거고 logger는 해당하는
                        name이하의 패키지가 영역인거다. 근데 이 영역은 logger와 root마다 중복이 될 수 있는것이며 level은 level에서 말했다싶이 독립적으로
                        적용이 되면, 이제 그 패키지별로 지정된 log level의 이상이 발생이되면 이 logger name이나 root가 지정된 갯수만큼 중복으로 로그를 발생시키게
                        되는거다. 이때 로그가 발생이 될때 각각의 logger나 name이 연결된 appender의 pattern에 맞게 생성이 되는거고, 그리고 나서 연결된 appender
                        의 class에 맞게 로그를 보내게 되는거다. 
                        [직접해봄]    
                        [참조링크 : https://jaehyun8719.github.io/2019/05/15/utils/logback/] / name이하 패키지에만 로그를 적용
                        [참조링크 : https://coding-start.tistory.com/186] / name에 애플리케이션 패키지명을 넣는다.    
                        [참조링크 : https://linkeverything.github.io/springboot/spring-logging-runtime/] / name에 애플리케이션 패키지명을 넣는다.    
                        [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/]      
                        +
                        그리고, 어차피 이 logger안의 additivity라는 속성도 있는데, 이것은 logger의 name속성과만 연관된것이니 여기에 정리하도록 하겠다.
                        우선, additivity는 따로 값을 지정해주지 않을경우 기본값은 true이다. 이 true와 false가 의미하는 바는 위에서 root나 logger의 name의 경우
                        로그를 발생시키는 영역의 갯수를 의미하는데 이를 중복되지 못하게 막는것이다. 즉, 만약 root가 있고 logger의 name이 com.celebmine인것과 name이
                        com.celebmine.webservice이렇게 된것 3가지가 있다고 해보자. 그러면, com.celebmine.webservice.~에 해당하는 패키지들에는 이 3가지 영역이 들어가있어서
                        해당 패키지에 level를 충족하는 로그가 발생시에 각각의 영역들의 appender의 pattern에 맞게 로그들이 3번이 발생이되어 전달되게 된다. 근데 만약에
                        이 name이 com.celebmine.webservice에 해당하는 logger의 additivity가 false로 지정해준다면 상위의 패키지에서 지정해준 name이나 root는 해당 additivity를
                        false로 지정해준 logger의 name값의 패키지 이하에는 영역이 침범하지 못하게 되는것이다. 즉, com.celebmine.webservice.~에 로그가 발생해도 이 name이 com.celebmine.webservice
                        에 해당하는것만 로그를 발생하게 한다는것이다. 또한 다른요소들은 additivity를 적용안하고 만약에 com.celebmine이 name값인 logger에 additivity를 false로 해주면
                        이때는 com.celebmine.webservice.~에 로그가 발생하게 되면 name이 com.celebmine인것과 name이 com.celebmine.webservice인것의 두 영역만 로그를 발생시키게 된다.
                        [직접해봄]    
                        [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/]    
                        [참조링크 : https://goddaehee.tistory.com/206] / additivity의 기본값은 true라고 한다. 
                        [참조링크 : https://jaehyun8719.github.io/2019/05/15/utils/logback/]    
                        [참조링크 : https://gs.saro.me/dev?tn=479]    
                        [참조링크 : https://jeong-pro.tistory.com/154]
                        +
                        아래 나와있는 참조링크들을보면, name속성은 필수로 지정해주어야 한다고 한다. 그러나 여기 뿐만이 아니라 즉,
                        logger요소의 name속성뿐만이 아니라, appender요소의 name속성또한 필수로 지정해주어야 한다고 나와있다.
                        [참조링크 : https://goddaehee.tistory.com/206] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                        [참조링크 : https://ckddn9496.tistory.com/79] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                        [참조링크 : https://yjh5369.tistory.com/483] / logger요소의 name속성을 적어주는것은 필수라고 한다.
                    3.이 logger태그에서 level에 쓰이는 것에대해 잠깐 보도록 하겠다.
                        우선, 로그 레벨은 TRACE, DEBUG, INFO, WARN, 그리고 ERROR가 있다. 간략하게 설명하자면, TRACE는 DEBUG보다 좀 더 상세한 정보이고
                        DEBUG는 프로그램을 디버깅하기 위한정보이며, INFO는 상태변경과 같은 정보성 로그 그리고 WARN은 처리 가능한 문제이나 향후 시스템 에러의 원인이
                        될 수 있는 경고성 메시지를 나타낸다. 그리고 ERROR는 요청을 처리하는 중 오류가 발생한 경우 표시한다. 여기서 DEBUG는 운영서버에서는 표시하지 않는다고 한다.
                        또한, 이 level에 값으로 ERROR, WARN, INFO, DEBUG, TRACE가 있는데 특정 값을 넣어주면 해당 로그 레벨 이상의 로그만 출력한다고 한다. 또한, 아래
                        참조링크를 보면 FATAL이라는것도 있는데, 이는 어플리케이션을 종료 상태로 만들 수 있는 경우이다. 즉, ERROR와 다른점은 ERROR는 종료까지 가지 않지만,
                        의도하지 않은 에러를 의미하며, FATAL은 어플리케이션을 종료 상태로 까지 만들 수 있는경우다.
                        [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0] / 로그 레벨에 대하여 & DEBUG는 운영서버에서는 표시하지 않는다.   
                        [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/] / 로그 레벨에 대하여 & 설정하는 로그 레벨 이상의 로그만 출력한다한다    
                        [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/] / FATAL 레벨도 있다.    
                        +
                        그리고, 이 level 속성값이 대문자이거나 소문자여도 상관이 없다. 직접 둘다 해보았고 책에는 대문자로
                        적혀져있고 내가 직접해보니 소문자로도 잘 작동했었다. 그런데 대부분 참조링크에서는 대문자로 쓰니 나도
                        대문자로 쓰는게 더 가독성이 좋아볼일것같기는하다.
                        [직접해봄]    
                        [참조링크 : https://ckddn9496.tistory.com/79]    
                        +
                        그리고, 이 level에 대해서 알아야 할 것이 있는데, logger나 root로 level을 지정하더라도, 이거는 다른 logger의 name속성이나
                        아니면 그 어떠한것도 무관한거다. 그냥 특정 패키지에 level이 지정되고 이 하위 패키지에 logger요소로 또 level을 지정하게 되면, 그냥
                        이건 더 하위 패키지에 level이 지정되있지 않는이상 해당 특정 패키지의 모든 하위 로그 level은 특정 패키지에서 정해준 로그 level을 따라가게
                        되니 한마디로 level을 logger나 root로 적용함으로써 일종의 level영역 표시가 되는거다. 즉, 하위 패키지에서 level을 debug로 하고 해당 패키지의
                        상위 패키지에서 level을 error로 해놔도 해당 하위패키지 바로 위의 패키지까지만 level이 error로 지정이 된다. 이건 root에서 지정해주건 logger에서
                        지정해주건 차이가 없고, 어느 요소에서 level을 지정해주던지 딱 영역별로 level을 지정해주는기능밖에는 없다. 그 외에 다른 기능은 없다. 그렇게해서
                        적용된 logger나 root의 갯수만큼 해당 구역의 로그level 이상의 로그만을 발생시키게 되는거다.
                        [직접해봄]    
                        +
                        즉, 좀만 더 덧붙이자면, 이 level은 additivity나 logger의 name속성 등 이런것과는 전혀 무관한것으로 그냥 패키지명에 따른
                        독립적으로 log level을 지정해주고, 해당 패키지 경로에는 지정된 로그 level에 해당하는 로그만 발생시키게 되는것이다.
                        [직접해봄]    
                        +
                        그리고 이 logger요소의 level속성값을 off로 주게되면, 해당 off가 적용된 디렉토리는 어떠한 레벨의 로그도 발생시키지 않는다는것이다. 이게
                        root에 하고 logger에는 level="debug"로 하던 아니면 logger에 off로 level속성값넣고 그 하위 logger level속성값을 off로 하던 off속성값도
                        똑같이 다른 level속성값과 동일하게 적용이된다. 또한, level을 명시해주지 않으면 debug이상만 나오게 되는데 직접 logger요소에서 해봐서 확인해봤고
                        이것도 off속성값과 마차가지로 다른 level속성값처럼 logger에 적용하던 root에 적용하던 아니면 level이 적용되는 중간에 적용하던 모두 다른 로그 level
                        속성값들과 동일한 성격을 갖었다. 즉, 특정 디렉토리가 level이 없는거로 적용되고 하위 디렉토리가 로그 level이 trace면 이 하위디렉토리는 모두 trace로
                        적용되고 바로 위의 특정 디렉토리까지가 level이 적용안됬으니 debug로 적용된다는것이다. 아래 root요소의 level속성에서도 적용했는데, 단 level을
                        지정해주지 않으면 다른 예외 사항이 하나있다. 그것을 아래 root요소의 level 값에 대해서 설명한것을 보도록 하자.
                        [직접해봄]    
                        [참조링크 : https://benfatto.tistory.com/47] / <logger>요소에서도 level off 사용한다. 
                        [참조링크 : https://ckddn9496.tistory.com/79] / 여기에 logger의 level속성은 필수가 아니고 선택적이라 나와있다.    
                        +
                        위에 name을 정리하다가 추가로 정리하려고 하는데, 이 level은 root는 어차피 전역이니 제외하고 level이 적용된
                        logger에는 필수로 name이 적용되어 있다. 그러면 해당 name의 패키지명을 포함한 하위의 모든 패키지에 level속성을 적용하게되는것이고
                        이것은 additivity와는 별개로 오직 logger에서 어느 name을 써서 어느것이 더 하위패키지에 적용되냐를 따져서 적용하는거다. 즉, 이 level
                        이 적용되는범위는 name에 따라 달렸으며, logger의 name이 더 하위패키지냐에 따라 level이 적용되는것이다. 즉, com.celebmine과 com.celebmine.webservice
                        이렇게 name이 다른 logger가 있으면 com.celebmine.webservice가 더 하위패키지이기 떄문에 여기에 level을 적용시키면 com.celebmine의 name을 가진
                        logger의 level은 적용되지 않고 이것은 additivity와 무관하다는 거다.
                        [직접해봄]    
                   4.마지막으로 이 logger태그의 하위태그인 <appender-ref>태그에 대해 보도록 하겠다.
                        원래는, 스프링부트 시작하기 초록책 93pg에 보면 appender-ref속성으로 logger태그 내에 쓰이도록 나왔는데, 실제로 간혹 참조링크에
                        이렇게 속성으로 쓰인것들이 있었는데, 이거는 제대로 작동하지 않았었다. 이것은 나중에 필요시 다시 보도록 하고 우선은 logger태그의 하위태그로
                        쓰이는 <appender-ref>태그에 대해 정리하도록 하겠다. 이 appender-ref태그의 속성인 ref에는 appender태그의 name값에 해당하는것을 적어주는데
                        그렇게 되면 해당 logger태그는 해당 name을 갖은 appender태그를 참조하게되어 appender태그의 pattern을 적용하고 로그 발생시 appender태그의 class
                        에 해당하는곳으로 로그를 보내게 된다.
                        [참조링크 : https://earth-95.tistory.com/41]     
                        [참조링크 : https://benfatto.tistory.com/47]    
                        [참조링크 : https://ckddn9496.tistory.com/79]    
                        +
                        근데, 이 appender-ref태그의 경우는 <logger>내에서 중복으로 태그를 사용이 가능한것으로 알고있고, 
                        logger에는 0개 이상 appender-ref태그를 적을 수 있다고 한다. 또한, logger내 또는 root태그내에 appender-ref태그를 직접 해보니 
                        appender-ref 태그를 안써줘도 정상작동은 했었다. 즉, 에러가 안났다. 즉, root태그혹은 logger태그에서도 0개의 appender-ref태그를 
                        적어줄 수 있는것으로 보인다. 그렇다면, 여러개의 appender-ref태그를 적어주는것에 관해서가 문제인데, 우선 이 appender-ref태그를 해당
                        logger요소의 속성인 name 경로에서 발생시킬 로그의 수를 의미한다.(당연 각각의 appender-ref에 맞는 appender태그의 pattern도 각각 적용된다.)
                        (또한, 당연히 하위에 logger요소의 name으로 지정된 영역이 있고 additivity여부도 따져주어야 하지만 말이다.) 그렇기에 만약에 <appender> 요소가 2개
                        (각각 A와 B라하면) logger요소나 root요소의 appender-ref에서 ref속성값을 각각 A가 중복되던 B가 중복되던 상관이없다.
                        [직접해봄]    
                        [참조링크 : https://thinkwarelab.wordpress.com/2016/11/18/java%EC%97%90%EC%84%9C-logback%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B9%85logging-%EC%82%AC%EC%9A%A9%EB%B2%95/] / 0개 이상의 appender-ref요소를 사용할 수 있다.    
                        [참조링크 : https://goddaehee.tistory.com/206] / root요소, logger요소 모두 여러개 써줌   
                        [참조문헌 : 스프링부트 시작하기 초록책 93pg] / 여기서 내가 변형하여 appender중복해서 사용했는데도 괜찮았다.    
                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@아 그것도 해야해 한 경로에 어디는 info이상만 어디는 error이상만. 근데 이거는 여기서 못하는거아닌가
            (4).이번엔 <root>태그에 대해 알아보도록 하겠다.
                (4-1).우선, root 요소는 전역설정이라고 하는데(추가로 logger는 지역설정이라한다.), 
                    한마디로 모든 패키지에 해당하는 경로를 지정하는것으로 보인다. 그래서 logger요소처럼 name속성이 
                    따로 있는것도 아닌가보다. 두번쨰 참조링크를 보면 root요소는 최상위 패키지에 기본적으로 적용한다고 나와있다. 
                    그리고 root도 그 외에는 logger와 같다고 나와있다.
                    [참조링크 : https://goddaehee.tistory.com/206]        
                    [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0]    
                (4-2).이 root 요소는 속성으로는 하나인 level속성만 사용하는것 같다. 아래 참조링크에 보면, 루트 로거의 속성으로는
                    단 하나 level속성만 허용된다고 나와있다. 이 level에 대해서는 logger요소의 level에 대한것과 아래 실제 사용하는 서비스에서의
                    level에 대해 충분히 정리했으니 그곳을 참고하면 될것같다. 덧붙이자면, 이 level에 값을 넣어주고 logger요소의 level속성값을 무엇을
                    적어주든지 간에 그 logger의 하위 level속성값은 해당 요소의 logger의 level속성값이 적용이 되는거다.(당연, 또 그 하위 패키지명에
                    logger로 level지정해주면 그게 지정이 된다. 그 하위 패키지는) 추가로 다른 참조링크를 보아도 이 root요소에 level속성말고 다른것을
                    쓰는것을 본적이 없다.
                    [직접해봄]    
                    [참조링크 : https://ckddn9496.tistory.com/79]    
                (4-3).신기한것은 이 root 요소의 level속성값에는 OFF라는게 들어갈 수 있는데, 아니면 아예 안적어 줄 수도있다.
                    내가 직접해보니 off로 적어주건 OFF로 적어주건 똑같이 정상작동하였고, 이 OFF나 off의 의미는 어떠한 로그 레벨도
                    설정하지 않는다는것으로 볼 수 있다. 즉, off라고 적어주면 어떠한 로그 레벨도 지정되지 않게된다. 즉, 이 off가 적용된
                    패키지경로에서는 아무 로그도 발생시키지 않는다. 또한 아무것도 level속성값을 적어주지 않게되면, 직접해본결과 DEBUG부터 
                    로그를 출력하게 된다. 즉, level이 debug로 맞춰지는거다. 이는 logger요소에도 똑같으며, 이렇게 아무것도 안적어주어서 level이
                    debug로 맞춰지는것도 똑같이 level끼리 패키지명에 따른 level구분되는것이 똑같이 적용되는거다. 즉, logger에서 하위패키지에 또
                    다른 level지정해주면 거기는 해당 지정된 level이 적용되는거다. 근데 반드시 짚고 넘어가야 할것은 만약 아무것도 level을 안적어
                    주게된다면 다른점이 있는데 만약 상위패키지에서 임의로 level 값을 지정해주게 되면 그 값으로 덮어씌워지게 된다는것이다. 이거는
                    additivity상관없이 그랬고 상위패키지에서 적어준 level값이 debug보다 낮은 trace여도 덮어씌워졌었다.
                    [직접해봄]    
                    [참조링크 : https://ckddn9496.tistory.com/79]    
                    [참조링크 : https://benfatto.tistory.com/47] / <logger>요소에서도 level off 사용한다.         
                    [참조링크 : https://www.nextree.co.kr/p5584/] / 여기는 off를 대문자로씀
                    [참조문헌 : 스프링부트 시작하기 초록책 93pg] / 여기는 off를 소문자로씀
                (4-4).이제 이 root 요소의 하위 태그인 <appender-ref>태그와 그 속성인 ref에 대해 보도록 하겠다.
                    이 부분은 위에 logger태그에서의 appender-ref태그에 정리해 놓았으니 여기에서 보도록 해보겠다.
                    [직접해봄]    
            (5).마지막으로, <filter>태그에 대해 보도록 하겠다.
                우선, 이 <filter>태그란, <appender>태그 안에 사용하는것으로 좀 더 자세히 볼텐데 그전에 이것을 확실히 하고 가야한다.
                logger나 root에 level속성값은 진짜 단순 해당 경로의 설정값으로 실질적으로 로그를 발생시키고 어떻게 발생시킬지를 정하는것은
                appender태그에 달린것이다. 이 <appender>태그를 <logger>태그 내에서 <appender-ref>태그로 몇개를 지목하냐에 따라 그 지목한
                appender태그에 맞춰서 로그가 발생이되는거다. 즉, 더 쉽게 말하자면 실제로 로그는 logger태그내에서 지정해준 log level에 따라서만
                로그가 발생하게 되는데, 그걸 넘어서 각 <appender-ref>가 적용된것마다 또 따로 해당 지정된 <appender>태그 내에 <filter>태그가 있으면
                이 설정에 맞춰서 해당하는 log level에 맞는경우 로그를 발생시키게 되고 또한 발생시킬때 <pattern>에 맞는 형식으로 발생을 시킨다. 즉,
                logger의 log level은 그냥 경로에 따른 기본설정이고 각각의 <appender-ref>설정에 따라 발생할 실질적 로그에 대해서는 이 <appender>내부의
                규칙을 따른다는것이다. 
                [참조링크 : https://yjh5369.tistory.com/483] / filter태그란    
                [참조링크 : https://goddaehee.tistory.com/206] / filter태그란
                +
                그래서 사용하는 방법은 <appender>태그내에 아래와 같이 코드를 작성하는것인데, 
                <filter class="ch.qos.logback.classic.filter.ThresholdFilter"> 
                    <level>INFO</level> 
                </filter>
                이건 filter태그의 class속성값이 ThresholdFilter인 경우를 나타낸거지만 이거를 보는게아니라 원리를 이해하기위해
                설명을 하도록 하겠다. 보다시피 해당 filter태그의 class속성값에 해당하는 기능을 적용시켜서 로그를 발생하게 한다.
                그러기에 이 <filter>태그는 <encoder>나 <layout>뒤에 적던 아니면 <appender>의 class속성값이 slack이여서 <webhookUri>
                뒤에 적던, 이런것에 상관없이 다 잘 작동했었다. 즉, 이 <filter>가 무슨 기능인지만 이해하면 될것같다.
                [직접해봄]    
                +
                이제는 ThresholdFilter와 LevelFilter에 대해 볼건데, levelFilter는 간단하게 얘기하면 지정한 level과 같은 level의 로그 이벤트를
                필터링하여 로그를 발생시킨다는거다. 따로 이것을 사용하려면 onMatch와 onMismatch등을 설정을 해주어야 하는데 이거는 직접적으로 사용하지는
                않을것이므로 나중에 필요시 더 자세히 보도록 하자. 그 다음은 ThresholdFilter에 관하여인데, 이거는 지정한 레벨의 이상의 로그레벨에 해당하는
                로그만 발생시킨다는 것이다. 즉,
                <filter class="ch.qos.logback.classic.filter.ThresholdFilter"> 
                    <level>INFO</level> 
                </filter>
                와 같이 사용하면 되며, 이 <level>태그 안에는 원하는 로그레벨을 적어주면 되는것이다. 이것만 하면 모든 작업은 끝인거다.
                [참조링크 : https://ckddn9496.tistory.com/89] / LevelFilter에 관하여   
                [참조링크 : https://mycup.tistory.com/276] / LevelFilter에 관하여      
                [참조링크 : https://mycup.tistory.com/276] / ThresholdFilter에 관하여 & <appender>의 class속성값이 ConsoleAppender인경우 사용예시    
                [참조링크 : https://ckddn9496.tistory.com/89] / ThresholdFilter에 관하여 & <appender>의 class속성값이 ConsoleAppender인경우 사용예시     
                [참조링크 : https://zorba91.tistory.com/311] / ThresholdFilter에 관하여 & <appender>의 class속성값이 SentryAppender인경우 사용예시    
            (6).<property>나 <layout>, <file>, <rollingPlicy>, <springProperty>, <springProfile>, <file> 등과 같은경우는
                로그를 파일로 저장할때 쓰거나 아니면 profile을 이용해서 지정하거나 등과같은 역활들을 한다. 그런데, 이러한 추가 태그들
                에 대해서는 나중에 프로필이나 설정파일 사용하거나 아니면 로그를 파일로 저장하거나 등 실제로 필요할 때 알아야 하는경우에
                사용하도록 하자. 다만, 여기서 말한 프로필이나 설정파일 사용이 그 스프링부트에서 logback-spring.xml으로 사용해야지 추가 기능을
                설정할 수 있다는 말이 이것과 연결된다는것쯤은 알고있자. 
                [참조링크 : https://supawer0728.github.io/2018/04/07/spring-boot-logging/]    
                [참조링크 : https://goddaehee.tistory.com/206]    
                [참조링크 : https://pjh3749.tistory.com/262]    
                [참조링크 : https://aljjabaegi.tistory.com/413]    
                [참조링크 : https://jaehyun8719.github.io/2019/05/17/springboot/logback-spring/]    
        [추가사항]    
            1.properties파일에서 주석은 #을 붙여서 주석처리 한다고 한다. 그냥 #을 적게되면 해당줄은 모두 주석으로
                처리 되는것 같다.
                [참조링크 : http://java-wonyoung.blogspot.com/2013/01/properties.html] / 개념    
                [참조링크 : https://aljjabaegi.tistory.com/413] / 예시
                [참조링크 : https://coding-start.tistory.com/186] / 예시
            2.이 위에서 클래스패스(classpath)가 언급되어서 얘기해보도록 할텐데, 우선 이 클래스패스의 개념부터 보도록 하겠다.
                클래스패스란 말 그대로 클래스를 찾기위한 경로이다. 즉, 자바에서도 동일한 의미로 사용이 되는데 JVM이 프로그램을 실행할 때,
                클래스파일을 찾는 데 기준이 되는 파일 경로를 클래스패스라고 하는것이다. 근데, 그러면 궁금한거는 클래스패스에서 xml파일을
                읽어간다고 위에 보면 나와있는데, 이게 꼭 클래스패스라고 클래스파일만 찾아 읽어가는게 아니라, 다른 xml파일같은것도 이 클래스패스를
                기준으로 읽어갈 수 있는것같다.
                [참조링크 : https://effectivesquid.tistory.com/entry/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%8C%A8%EC%8A%A4classpath%EB%9E%80] / 클래스패스 개념    
                [참조링크 : https://mkil.tistory.com/385] / 클래스패스(classpath)에 위치한 xml파일을 읽어간다.    
                +
                추가로, 외부설정파일인 properties파일에도 classpath(클래스패스)가 나오는데 여기서도 resources바로 아래가 클래스
                패스라고 나와있다. 여기서도 이 클래스패스라는 경로를 나타내는 명을 가져다 쓰는것 같다.
                [직접해봄]    
            3.xml파일에서는 주석을 사용할 수 있는데, <!-- ~ -->처럼 작성하여서 이 ~안에다가 적어서 주석을 완성시키는것이다.
                그러나, 아래 참조링크에보면 ~ 안에 --는 적어서 넣을 수 없다고 한다. 또한, xml선언부 다음에 태그를 작성해야지
                정상적으로 적용이되고 에러가 나지 않는다고 한다.
                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
                [참조링크 : http://www.devkuma.com/books/pages/1224]    
            4.아래 참조링크를 보면, logback-spring.xml에 작성을 할때 대소문자를 구별하지 않는다고 한다. 즉, <logger>를 <LOGGER>와
                같은것으로 본다는거다. 또한, 아래 참조문헌에 보면 이상하게 <Patter>만 이렇게 대문자로 시작하고 있다. 나는 직접해봤는데
                이거를 <patter>으로 하던지 상관없이 정상적으로 작동했었다. 또한, 맨 아래 참조링크를 보니 태그에 대문자나 소문자가 들어가는것은
                상관이 없으나 여는 태그와 닫는태그에서는 대소문자가 반드시 일치해야한다고 한다.(<xyz> ~ </xYz>로 닫을 수 없다.) 
                그리고 태그의 이름이 길어지면 camel 낙타표기법으로 짓고 사용하라 하는데 이는 나중에 필요시 더 자세히 봐보자.
                [직접해봄]    
                [참조링크 : https://goddaehee.tistory.com/206]    
                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
                [참조링크 : https://ckddn9496.tistory.com/79] / 태그의 대소문자를 구분하지 않고 선언할 수 있다. & 여는태그와 닫는태그에서 대소문자의 규칙은 xml규칙을 따른다. & 태그가 길어지면 CamelCase를 따라서 태그의 이름을 짓는것을 권장한다.
                [참조링크 : https://qh5944.tistory.com/70] / 여는태그와 닫는태그는 반드시 일치
            5.원래는 아래 참조링크를 보니, HTML이나 XML모두 시작태그와 종료태그가 있으면 상관없으나 만약 시작과 종료를 한꺼번에 표현해야하는
                태그면 해당 태그 끝에 "/"를 붙여주어야 하는것같다. 잘 보면, <br>과 같은것도 그런데, 사실 html은 이러한태그에 /를 필수적으로 붙여주지않더라도
                에러가 나지 않고, 오히려 이게 / 있는게 더 어색한 경우가 많다. 그러나 아래 참조문헌에 보면 <appender-ref ref="console"/>와 같이 xml에서는 이를
                반드시 지켜주지 않으면 에러가 나고 정상적으로 작동하지 않는것 같다. 만약 더 자세히 알아봐야 한다면 그때 다시 봐보도록 하자.
                [직접해봄]    
                [참조링크 : https://ehpub.co.kr/html5-6-%EC%95%88%EC%A0%84%ED%95%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9C%84%ED%95%B4-br-%ED%83%9C%EA%B7%B8%EC%97%90-%EC%A2%85%EB%A3%8C%EB%A5%BC-%ED%91%9C%EC%8B%9C%ED%95%98%EC%9E%90/]    
                [참조문헌 : 스프링부트 시작하기 초록책 93pg]    
            6.직접 해본건데, <appender>와 <logger>의 경우 이 태그를 적는 순서도 따져야 한다. 실제로 <appender>보다
                이 <logger>태그가 뒤에 있어야지 정상적으로 작동이 된다. 실제로 <logger>를 <appender>보다 앞으로 가져가니
                아예 에러가 발생했었다.
                [직접해봄]    
                [참조링크 : https://gs.saro.me/dev?tn=479]
.
.
.
3.lg4jdbc
    (1).@@@@@@@@@@@@@@
.
.
.
4.예외처리 @ControllerAdvice근데 자바책 501pg를 보니 이 throws 다음 예외클래스명이 나오는거였어 그렇기에 스프링부트시작하기 초록책
    컨트롤러나 서비스등에서 throws Exception이 모든 예외에 대해서 throws가 되는거였다. Exception.class가 아마 모든 예외가 상속하는?
.
.
.
5.실제 스프링부트에서 사용될때의 지식에 관해서 설명하도록 하겠다.
    (1).우선, LEVEL에 대해서 말해보도록 하겠다.
        (1-1).우선 LEVEL에 대한 기본 설명은 위에서 해놓았다. 근데, 실제 사용에서는 이 LEVEL을 어떻게 사용하느냐이다. 우선,
            간단하게 결론만 말하면, ERROR와 INFO만 로그로 기록해서 사용한다고 한다. 그 상세한 이유에 대해서는 아래에 설명하도록 하겠다.
            그리고 TRACE는 사용하는 경우를 못봤으며, DEBUG의 경우 개발하는 경우에 로그를 설정해서 사용하다가 실제 서비스에는 INFO와
            ERROR만 사용한다고 한다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://ahndding.tistory.com/12]    
            [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0] / DEBUG는 개발때에만 사용하고 실 서비스에서는 사용하지 않는다.    
            +
            우선적으로, FATAL이란것도 위에서 말했는데 왜 쓰지 않냐면, FATAL은 어플리케이션을 종료 상태로 만들 수 있는경우이며,
            ERROR와 FATAL이 가지는 공통적인 목적은 '의도하지 않은'이다. 그리고 이미 FATAL로그가 생길만한 일이 있으면 어플리케이션이
            중단이 되고 다양한 원인으로 작성되지 않을 확률이 다분하기에 이 경우는 사용하지 않고 대부분 ERROR로 적는것을 추천한다고 한다.
            또한, 내가 사용하는 logback은 FATAL레벨이 없다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://ahndding.tistory.com/12]    
            [참조링크 : https://luvstudy.tistory.com/133] / logback은 FATAL레벨이 없다고 한다.
            +
            이제 INFO로그에 대해 볼건데, INFO로그는 ERROR와는 조금 다른데, INFO는 서비스 시나리오나 요구사항에 사용한다고 한다. 즉,
            서비스의 목적을 달성했는지 분석하는 용도가 첫번째인데 이는 그냥 서비스가 정상작동하냐를 말하는것이고, 두번째는 요구사항으로 이는 외부
            API 호출을 로그로 관리하여 대략적인 통계로 활용한다는것이다. 또한, 예외가 발생했을떄도 이 INFO로그로 출력할 수도 있는데 그러한 경우에는
            내가 일부로 특정 예외를 사용하고 의도한 예외인 경우에는 INFO로 한다. 아래 참조링크에는 이에 해당하는 예시가 있다. 여기서 예외를 의도적으로
            사용하고 있다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://ahndding.tistory.com/12]    
            +
            추가로 WARN같은거는 동작에는 문제 없지만 나중에 에러가 발생가능한 경우를 의미하는데 이를 측정이나 기준이 있을까
            이느냐이며, 굳이 WARN일 떄도 알람을 제공해야하나이다. 또한, TRACE는 사용하는 로그의 의미가 없는것으로 알고있다. 그 외에
            DEBUG는 주로 개발할때 디버그용으로는 많이 사용하고 있지만 실제서비스에서는 DEBUG 레벨은 사용하지 않는다.
            [참조링크 : https://blog.lulab.net/programmer/what-should-i-log-with-an-intention-method-and-level/]    
            [참조링크 : https://romeoh.tistory.com/entry/Spring-Boot-Logback-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0] / DEBUG는 개발때에만 사용하고 실 서비스에서는 사용하지 않는다.
            [참조링크 : https://velog.io/@ehdrms2034/%EC%8A%A4%ED%94%84%EB%A7%81-Boot-%EB%A1%9C%EA%B9%85-Logging] / DEBUG는 개발때에만 사용하고 실 서비스에서는 사용하지 않는다.   
            [참조링크 : https://ahndding.tistory.com/12]    
        (1-2).위의 (1-1).을 바탕으로 그래서 원래 실 서비스에서는 주로 INFO와 ERROR가 쓰이고 개발할때는 DEBUG도 같이 쓰이게 되는거다.
            그러나, 내가 서비스하려는것의 목표는 사실상 서비스가 정상작동하는지등의 시나리오나 요구사항 즉, 특정 api에 대한 통계 수치를 사용하진 않을것이다.
            이것은 주로 cs에서나 하는것으로 나는 ERROR로그만 잡아서 사용할 것이다.
            [직접해봄]    
    (2).이제 로그를 실제로 어디에 저장시킬지에 대해 보도록 하겠다. 여기서는 sentry와 console그리고 slack 추가로 email에 대해 정리하도록 하겠다.
        (2-1).여기서는 sentry에 대해 설명하도록 하겠다.
            (2-1-1).우선 sentry로 연결하는 방법을 볼건데, 우선적으로 해야 하는것이 의존모듈의 추가이다. 의존 모듈을 두개는 추가해야하는데 각각
                'io.sentry:sentry-logback:1.7.30'와 'io.sentry:sentry-spring-boot-starter:1.7.30' 이다. 실제로 내가 build.gradle에 추가한 코드는
                    implementation('io.sentry:sentry-spring-boot-starter:1.7.30')
                    implementation('io.sentry:sentry-logback:1.7.30')
                와 같으며, 이 버전에 관해서는 1.7.30이라 한곳도 있찌만 지금은 5로 시작한 버전을 모듈을 사용하라고 센트리 홈페이지에서 그런다 실제로 다른
                참조링크를 봐도 버전은 5를 쓰는데가 있는데, 이거는 나중에 필요하거나 문제가 될시에 버전을 바꾸고 지금은 이 1.7.30 그대로 쓰도록 하자.
                그리고 다른 참조링크를보면 이 둘중 하나만을 추가하기도 하는데, 그러면 정상작동하지 않았었다. 또한 맨 아래 참조링크에보면, 코드가
                implementation('io.sentry:sentry-spring-boot-starter:1.7.30') 이거 대신 'io.sentry:sentry-spring:1.7.27'로 대신해서 쓰는데,
                사실 이 의존모듈은 io.sentry:sentry-spring-boot-starter에 있는 의존모듈이다. 나는 당연히 spring-boot-starter로 의존모듈을 추가하고
                이 부분에 대해서는 나중에 필요시 다시 더 보도록 하자. 추가로 아래 참조링크에보면, sentry 의존모듈 버전은 4.3.0이상을 쓰게 되면 기존의 방식과는
                다르다고 한다. 만약에 버전을 올려서 사용한다면 이 참조링크도 참고하도록 하자.
                [직접해봄]    
                [참조링크 : https://zorba91.tistory.com/311]    
                [참조링크 : https://sg-choi.tistory.com/568]    
                [참조링크 : https://forl.tistory.com/134] / 버전 1.7.30 쓰는곳
                [참조링크 : https://ivvve.github.io/2020/10/11/java/Spring/third-party-integration-1/] / 버전 1.7.30 쓰는곳
                [참조링크 : https://sbgb.tistory.com/8] / io.sentry:sentry-spring:1.7.27   
                [참조링크 : https://forl.tistory.com/134] / sentry버전업에 따른 다른 사용법
                +
                그럼 각각의 의존모듈의 기능에 대해서는 간략하게라도 알아야 좋을것같은데, 우선 implementation('io.sentry:sentry-logback:1.7.30') 이
                의존모듈은 logback-spring.xml의 appender태그의 class값으로 추가하는 클래스파일이 존재하는곳이다. 즉, 이것은 로그백설정과 센트리 설정을 이어주는것으로
                보고 이 appender태그의 class값 즉, 위의 의존모듈의 클래스로 로그백 설정한 로그를 받고 그외에 implementation('io.sentry:sentry-spring-boot-starter:1.7.30')의 경우에는,
                의존모듈 추가시에, 1.io.sentry:sentry-spring-boot-starter:1.7.30, 2.io.sentry:sentry-spring:1.7.30, 3.io.sentry:sentry:1.7.30 이렇게 3개가 추가되는데, 이중에
                3.이 Sentry에서 말하는 SDK로 아래 2-1-2설명에서 DSN의 값을 이용해서 어느 센트리의 프로젝트로 보내느냐의 역활을 하는것이니 그것으로 알고(io.sentry:sentry-logback:1.7.30로
                받아온 로그들을 여기로 보내 이 SDK에서 센트리로 보내는거로 이해하자), 1.과 2.는 이러한 Sentry SDK와 Sentry관련 모듈이 스프링부트 혹은 스프링에서 잘 작동하게 하는 것이라고 이해하자.
                분명 여기서 다른 부분들이 있겠지만 이렇게 이해하고 넘어가며 나중에 필요시 더 정확하게 알도록 하자.
                추가로 아래 참조링크1을 보니 io.sentry:sentry-logback:1.7.30를 추가하지 않고 다른설정들은 그대로 하고 로그백 자체를 사용을 안하니 즉, logback-spring.xml을 사용을 안하니
                그냥 모든 기본설정 로그들이 발생하고 바로 Sentry로 보냈었다. 즉, 어느정도 이 의존모듈은 로그백 설정파일에 따른 로그들을 받아내고 연결하는 역활을 한다는게 말이 되는것으로 본다.
                [직접해봄]    
                [참조링크 : https://bokyung.dev/2021/04/15/sentry-springboot/] / 참조링크1
                +
                SDK란 Software Development Kit으로 이 소프트웨어 개발 키트는 개발자에게 다른 프로그램에 추가하거나 연결할 수 있는 기능을 제공해주는 도구 모음이다.
                근데 , Sentry에서도 SDK라는 용어를 쓰는데 위에서 본 의존모듈을 가리켜 Sentry에서는 SDK라고 한다. 비록 'io.sentry:sentry'만을 나타내고있긴 하지만,
                (io.sentry:sentry-spring-boot-starter 의존모듈안에 있는 모듈이긴하다.) 이거를 가리키는 것이다.
                [직접해봄]    
                [참조링크 : https://www.adjust.com/ko/glossary/sdk/] / SDK에 대하여    
                [참조링크 : Sentry에서 프로젝트를 만들고 나서 바로 뜨는 SDK내용] / 여기서 SDK를 추가하라고 하는데 이게 의존모듈이다.   
            (2-1-2).그 다음 Sentry의 DSN에 대해서 보도록 하겠다. Sentry DSN이 의미하는 바는 아래 첫번째 참조링크에 sentry홈페이지에서 설명되어있다. 아래 참조링크에서는
                DSN이란 SDK 모듈에 즉, 해당 클래스객체에 이 로그들을 어드 Sentry의 계정의 어느 프로젝트로 보내느냐를 나타내는것으로 보인다. 근데 이 DSN의 값은 비밀로 해야하는
                이유가 이것만 알면 해당 Sentry 프로젝트로 로그를 언제든 보낼 수 있기 때문에 비밀값으로 붙여져야 하는거다. 아래 참조링크를 보아도 알지만 안보아도 당연히 비밀값이라는
                걸 알아야 한다.
                [직접해봄]    
                [참조링크 : https://sentry.io/settings/wisecompany/projects/java-pu/keys/] / 로그인이 안되있다면 볼 수 없지만, 즉, Sentry로그인하고 프로젝트 선택후 톱니바퀴모양 고르고 Client Keys를 들어가면 확인 가능하다.    
                [참조링크 : https://ivvve.github.io/2020/10/11/java/Spring/third-party-integration-1/] / 이 DSN값은 secret값이므로 외부에 노출되서는 안된다.     
                +
                사용하는 방법은 sentry.dsn=http://2001dedc1de14412b72245f08cc8848d@192.168.56.12:9000/4 으로 그냥 application.properties같은 설정파일에
                sentry.dsn=프로젝트만의 DSN주소를 써 넣으면 된다. 직접 내가 해보기도 했다. 추가로 직접 해본거기도 하고 원래 이렇게 쓰는게 더 가독성도 좋아 보이는게,
                # sentry DSN 값
                sentry.dsn=http://2001dedc1de14412b72245f08cc8848d@192.168.56.12:9000/4
                와 같이 주석을 붙여서 사용하기도 한다.
                [직접해봄]    
                [참조링크 : https://sg-choi.tistory.com/568]    
                [참조링크 : https://blog.eomsh.com/128]    
                [참조링크 : https://bokyung.dev/2021/04/15/sentry-springboot/] / 사용예시 & 주석도 함께 사용하는 예시
            (2-1-3).그러고 나서 이번에는 sentry.io 웹페이지에서 회원가입을 하고 프로젝트를 생성하고 연결하는 법 그리고 센트리 기본적으로 사용할 설정에 대해 보겠다. 
                우선은, 사실 내가 Sentry의 여러기능을 사용해보지 않아서 그렇지, 깃헙이나 지메일로 가입하든 어떠한 가입방식을 사용하더라도 크게 차이는 없었다. 단, 이메일 
                Notification을 보낼때 이 회원가입을 한 메일로 보내긴 했었다. 이 메일에 관해서는 추가로 아래 메일 관련 설명에서 정리하도록 하겠다. 여기서는 사실 별로 적을건 없다. 
                그저 추가 설정들 그리고 초기 세팅에 대해서 명을 더 해보도록 하겠다. 우선 회원가입을 하고 나서는 프로젝트를 만들어주어야 하는데 프로젝트를 create 하게 된다면,
                여기서 플랫폼을 먼저 고르라고 하는데, 자바, 로그백, 스프링, 스프링부트가 있다. 그런데, 여기서 어떤 플랫폼을 고르느냐에 따라서 프로젝트 생성후에 어떤 SDK를 쓰고
                어떻게 DSN을 연결하고가 각각 다르게 설명되어 주어진다. 자바로 선택할경우 설명따로 로그백 선택할경우 설명따로 스프링선택할경우 설명따로 스프링부트 선택할 경우
                설명따로가 나오는데, 사실상 나는 스프링부트로 플랫폼을 선택하면 적절한 적용방법이 나오게 된다. 그외에 자바, 로그백, 스프링만 사용할경우는 따로 필요하지 않아서
                나오는데로 설정하고 사용해보진 않았다.(그리고, 플랫폼을 자바 혹은 로그백을 선택하고도 스프링부트에서 스프링부트와 센트리설정을 해서도 정상 사용이 가능했었다.)
                [직접해봄]         
                +
                위의 내용을 추가로, 아래 참조링크들에서 모두 플랫폼 선택을 자바 아니면 로그백으로 선택했었다. 근데 사실 아래 내용을 보니 플랫폼에서 스프링이나
                스프링부트를 찾을 수 없었다. 즉, 모두 글을 쓸 당시에는 스프링이나 스프링부트 플랫폼이 없다보니 자바나 로그백을 사용하게 된것인데, 그렇다면 나는 그냥 스프링부트를
                선택해서 사용해도 될것으로 보인다. 또한, 어떠한 자바 혹은 로그백 혹은 스프링부트를 선택해도 최소한 스프링부트 프로젝트에서는 정해진 스프링부트와 센트리 설정만
                잘한다면 전혀 어떤 플랫폼을 고르던지 차이가 없는것으로 보였다. 만약에 나중에 더 자세하게 알아야한다면 이 부분도 다시 보도록 하자. 즉, 뭔가 플랫폼 선택에 따른 센트리
                내부적으로 차이가 있다면 다시 보고 정리해보도록 하나 아마 자바, 로그백, 스프링부트 플랫폼에 대해서는 거의 완벽히 똑같을것으로 알고있다. 나중에 더 봐야한다면 더 보도록
                하자.
                [직접해봄]    
                [참조링크 : https://zorba91.tistory.com/311] / 플랫폼 선택 자바,로그백    
                [참조링크 : https://johnmarc.tistory.com/56] / 플랫폼 선택 로그백    
                [참조링크 : https://ondolroom.tistory.com/763] / 플랫폼 선택 자바
                [참조링크 : https://ivvve.github.io/2020/10/11/java/Spring/third-party-integration-1/] / 플랫폼 선택 자바   
                +
                그리고나서 플랫폼을 고르면 Set your default alert settings가 나오는데, 이 부분에서는 내가 딱히 설정할것은 없어 보인다. 그냥
                기본 설정인 I'll create my own alerts later를 선택하고 알림 부분에 대해서는 따로 설정하면 되는것으로 알고있다. 만약에 이 부분도
                사용하게 된다면 나중에 다시 더 정확하게 알아보자. 그 다음 프로젝트 이름과 팀선택인데, 프로젝트 이름은 그냥 해당 서비스 명이나 아니면
                서비스명-error-log-bot 등 처럼 지으면될것 같다. 이건 진짜 자율적인것으로 다른 참조링크들을 보아도 딱히 정해진 방식이 없었다. 그 외에
                팀을 말하기에 앞서, 계정 가입을 하게되면, 우선 유저 이름과 organization이름을 모두 적으라고 하고 그게 그대로 정해진다. 그리고 organization
                이란 말 그대로 해당 organization에서 members를 받고 그 members가 원하는 team에 배정이 되는거다. 그리고 프로젝트는 이 team단위로 배정이되어서
                생성을 하는건데 이 프로젝트 생성시 고르는 팀이 어느 팀에 배정하느냐를 의미하는거다. 이정도면 기본적인 sentry에 대해서 설명하였다.
                [직접해봄]    
            (2-1-4).이제 이 sentry의 기본 사용과 Alerts설정에 대해서 알아보도록 하겠다. Alerts도 이메일과 슬랙 모두 봐보도록 하겠다. 이 Alerts에서
                알림을 생성할때 기본 무료계정으로는 Errors의 Issues밖에 이용하지 못한다. 그 이후로 Issues를 클릭하고 내가 볼만한것은 그저 먼저 Alert의 
                이름을 정하는것인데, 이것도 형식이 정해진것은 아니여서 그때그때 맞춰서 생성하면 된다. 그리고 볼 것은 Set conditions란인데, 첫번째 Add optional trigger에서
                A new issue is created만 이전 alerts에 해놨었는데 만약 이거를 설정해놓으면, regression(resolve됬다고 한 에러로그가 다시 발생한경우) 로그에 대해서는 알림을
                보내지 않았었다. 즉, 이메일(나는 이메일보내는거로 설정했으니)이 보내지지 않았었다. 즉, 정말 new issue에 해당하는것만 발생시 notification을 보내는거고 이러한
                regression에 대해서는 notification을 보내지않았었다. 즉, 나는 그냥 이 Set conditions 부분에서 WHEN을 아예 안건드리고 하는게 나을것같다는거다. 그러고나서 TEHN 부분에서 
                보통 알아야할것은 두가지인데, Send a notification과 Send a slack notification 이 두가지인데 이 하나 Send a slack notification은 유료버전으로 논외로 하자.
                (나중에 쓰게된다면 다시 정리) 그리고 나서 Send a notification은 이메일을 보내는건데, 이 중에 Issue Owners를 하게되면, 내가 회원가입할떄 등록한 이메일로 알람이 보내지게 
                되는거다. 이는 user setting에서 바꿀수있는것으로 알고있고 삭제하거나 이메일을 추가하거나 할 수도 있는거다. 또한, 본인이 가입할때 이메일이더라도 한번 인증을 해야하는경우도 있다.
                (그냥 인증이 되있는경우도 있다.) 그 외에 추가설정들에 대해서는 나중에 하게 된다면 다시 자세히 보도록 하자. 그리고 마지막으로 Set action interval는 같은 issue에 대해서 동일한 
                알람이 발생시에 몇분 간격으로 알람을 보내냐는거다. 좀 더 정확하게 하자면, 동일한 알람이 발생시에 해당 간격이 지나면 또 these actions를 취하겠다는건데 이게 바로 메일로알람보내거나 
                슬랙로 보내거나 하는거다. 즉, 센트리에 기본적으로 찍히는 로그들은 이런거 상관없이 찍히는거고 내가 설정한 THEN perform these actions를 실행하겠다는거다. 그렇게 해서 이것도 직접해봤는데 
                Set action interval을 5분간격으로 하니 동일한 에러로그에 대해서 5분 후에 발생하면 또 이메일로 알람이 왔었다. 동일한 에러로그에 대해(자세한 로그내용에 대해서는 아래 2-1-5에서 설명하겠다.)
                [직접해봄]       
            (2-1-5).이제 마지막으로 추가로 알아야할것은 sentry에서 로그가 어떻게 뜨고 어떻게 이용할것인지 그리고 이메일로는 어떻게오고 어떻게 사용할것인지에대해
                얘기해보도록 하겠다. 우선 sentry issues란에서는 목록들이 보이는데, 여기서 간단히 설명하자면, 하나의 목록의 첫번째는 내가 설정한 로그의 내용에 대해
                나오는거고 그다음줄은 로그가 발생한 클래스의 풀패키지명과 메서드에 대해 나온다. 그리고 또 그 아래는 New issue면 New Issue아니면 Regression이
                뜨게 되는데, 그 옆은 이 sentry의 프로젝트명에서 소문자를 모두 대문자로 표시하게 된다. 그 다음 시간은 실질적으로 보이는 로그가 발생한 시간과
                그 옆의 시간은 해당 똑같다고 여겨지는 issue로 분리된 로그가 최초발생한 시간에 대해서 설명해놓은거다. 그 옆의 문장은 로그가 발생한 클래스를 설명해놓은거다.
                [직접해봄]                                   
                +
                추가로 이 resolve와 ignore에 대해 볼건데, 만약에 이 sentry issues에서 발생한 issue에 대해 Resolve를 누르게 되면, 해결했다는 의미이고,
                ignore을 누르게 되면 같은 issue 리스트에 대해서는 에러 로그가 발생해도 알림을 보내거나 아니면 Issues란에 뜨지 않게된다.(물론, ignore한것찾으면 뜨게할순있음)
                그리고 resolve를 하고 만약에 똑같은 issue리스트에서 로그가 발생하면 그거는 Regression이라고 뜨게되는거다.
                [직접해봄]    
                +
                이 sentry에서는 똑같은로그라고 생각하는 기준이 바로 로그가 발생한 클래스가 다르거나 아니면 같은 클래스여도 해당되는 메서드가 다른 메서드에서
                로그가 발생하면 이 sentry프로젝트에서는 다른 issue로 묶는것으로 보인다. 그 외에 같은 클래스의 같은 메서드 안에서 발생한 로그라면 같은 issue라고
                보고 처리하는것같다. 또한, 같은 클래스의 같은 메서드에서 아예 똑같은 로그 즉, 내가 log.error("~")로 직접 적은 로그가 발생하더라도 내부에서 발생된
                STACK TRACE가 다르다면 서로 다른 로그로 분류될 수 있는것이다. 내가 알기론 여기까지이며 그 외에 다른 추가사항이 있다면 그때가서 정리하도록 하자.
                이 STACK TRACE에 대해서는 아래에 좀 더 자세하게 설명해놓았다.
                [직접해봄]    
                +
                추가로 이 STACK TRACE에 대해 볼것인데, 여기는 자세히볼것은 없고 그냥 해당 로그가 발생했을때 관여한 클래스와 메서드들로 보고있다. 이 메서드를 사용함에
                있어서 어떤 클래스와 어떤 메서드들이 연관되고 얽혀있는지를 대략적으로 보여주는것같다. 로그가 직접발생한 클래스의 메서드도 보여준다. 그리고, 내가 알기론
                바로위의 sentry에서 issue들을 나누는 근거가 이 STACK TRACE가 다르다면 분류하는거로 알고있는데, 유일하게 로그가 발생한 클래스의 메서드내에서 로그의
                line위치가 다른것으로는 다른 로그로 분류하지는 않는것같다. 이것도 모두 STACK TRACE에서 비교해보고 확인한 결과다. 그리고 바로 위의 STACK TRACE가 다르다면
                같은 클래스의 같은메서드의 완전히 동일한 로그가 발생되어진거더라도 이 경우 STACK TRACE보면 맨 아래 서로 다른 클래스과 연관되어있는것을 볼 수 있다. 여기서
                보고 이게 서로 다른 로그 issue로 분류하게 된것이다.
                [직접해봄]    
                +
                그럼 이제 이 issue가 발생했을때 뜨는 리스트중 하나를 클릭했을때 나오는 내용에 대해 정리하도록 하겠다. 다른 모든것들은 따로 필요시에 더 보면되고,
                여기서는 이 로그가 발생한 메서드가 GET방식이냐 아니면 POST방식이냐를 나타내는게 있는데(클라이언트가 url치는것 외에 오류에서 뜨는것에 대해서는 나중에 알아야 할
                필요성이 있을시에 다시 봐보도록 하자), 이는 실제로 클라이언트가 URL을 쳐서 웹을 들어오게되면, 컨트롤러에 들어오게 되고 그다음 서비스 그리고 그 다음 매퍼를 거치게 된다. 
                그런데, 이해해야할것이 이 log.~()로 로그를 발생시킬때 여기에는 클라이언트가 GET방식으로 들어온건지 아니면 POST방식으로 들어온건지 아니면 클라이언트의 ip주소는 어떻게 되는지 
                기타 내용들을 포함하게 되는것같다.(실제로 안그럴 수 있지만 우선 이렇게 이해) 그렇게되어서, Controller에서 발생하는 log.~()에도 포함이 되어있고, 이 컨트롤러 메서드내에 호출하는 
                Service메서드내에서 log.~()에도 포함되어있고 또 Service메서드내의 Mapper메서드 내에서 log.~()를해도 포함되는것으로 알고있다. 그렇기에, Controller,Service,Mapper어디에서 로그가 
                발생했던지 클라이언트가 접속해서 발생한것이라면 GET과 POST방식이 뜨게되며, 또한 클라이언트로부터 받아온값(나는 커맨드객체만 해봤긴하다. 다른 @RequestParam같은것도 다시 적용해봐서 봐야하면 
                그때가서 보기)도 뜨게되는데, 이 또한 Controller, Service, Mapper 이 중 어디에서 로그가 발생하던지 전부 클라이언트에게서 받아온 값들이 떳었다. 같은 흐름으로 생각하자.
                또한, 클라이언트가 GET이던 POST방식이던 보낸 값들이 있는데 이것또한, 센트리의 issue리스트중 클릭하면 무엇을 보냈는지 나오게 되있다. 방금 위에 말한 것이긴 한데 조금 더 
                구체적으로 보자면, 클라이언트가 보낸 값의 이름과, 해당 값이 뜨게된다. 또한, 여기서는 POST방식이던 GET방식이던 상관없이 그냥 Body라고 뜨고 클라이언트가 보내온 값들에 대해
                뜨게 하긴하는데, 사실상 GET방식은 클라이언트가 보내온 값을 받아 http요청의 header에 담아서 갖고오고 POST방식은 클라이언트가 보내온 값을 받아 http요청의 body에 담아서 갖고오기에
                여기 센트리의 issue에서 하나 로그를 클릭했을때뜨는 이 Body가 이 부분을 얘기하는건지 아닌지는 잘 모르겠다. 이 부분도 나중에 필요시 더 자세히 보도록 하자.
                [직접해봄]    
                +
                위의 것을 이어서 추가로, 만약에 Controller, Service, 그리고 Mapper에서 예외가 발생했을때(즉, 클라이언트가 웹주소에 url치고 들어왔을때) throws Exception같은게 있으면
                발생하는 예외가 해당 메서드를 호출한곳에서 처리하도록 한다. 그러나, 또 해당 메서드에서 throws Exception이 있으면 또 그 메서드를 호출한 메서드에 가서 예외처리를
                하게되는데, 그게 Controller까지 오게된다면, 해당 Controller에서 @ExceptionHandler나 아니면 @ControllerAdvice의 @ExceptionHandler에서 처리하게 된다.
                여기서
                [직접해봄]      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                +
                이메일로 notification을 받는 경우에 만약 alert의 interval설정을 5분으로 하고 동일한 로그가 5분후에 발생시에 알람을 보내게되는데, 이때 메일에 온 알람 내용은
                @@@@ 이 interval이 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                [직접해봄]            
            (2-1-6).이 Sentry에서 UTC를 지정해야하는데, UTC=CMT로 세계 표준시간이라고 한다. 한국 시간은 이 UTC +9이고, 반대로 UTC시간은 한국시간 -9이다.
                아래 참조링크를 보면 영국시간이 곧 UTC시간이기도 하다. 그래서 이것도 센트리의 Account Details에서 즉, user setting에서 바꿔주어야 한다.
                그래야 부수적으로 뜨는 이 시간값들에 대해 잘 볼 수 있다. 바꾸게 되면 KST인 한국표준시간으로 바꿔서 뜨게 된다. 시간이 표시되는구간에
                [직접해봄]    
                [참조링크 : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hist0134&logNo=221231357309]          
            (2-1-7).이제 그 다음은 무료계정으로 사용하니 무료계정을 이용할때의 이용가능 혜택과 로그의 기본적으로 사용할 수 있는 기준에 대해 보도록 하겠다.
                아래 참조링크를 보면 무료계정은 1 user에 30 day data retention으로 보인다. 또한 내가 알아야할것은 5천개의 에러를 한달에 받을 수 있다고 한다.
                그외에는 사실상 볼 필요없으며 이메일로 notification 보내는건 무료고 slack같은거 보내면 유료라고 한다. 여기서 한달 5천개의 에러 로그를 받을 수
                있으며, 30일동안 보관해주는것으로 보인다. 그리고 1user라고 적혀져있는건, 하나의 계정으로 로그인해야 해당 이슈들을 조회할 수 있는거라고 한다.
                [참조링크 : https://sentry.io/pricing/]    
                [참조링크 : https://tech.urbanbase.com/dev/2021/03/04/Sentry.html]    
        (2-2).여기서는 slack에 대해 설명하도록 하겠다.
            ()
            [참조링크 : ]    
            [참조링크 : ]         
        (2-3).마지막으로 console에 대해 설명하도록 하겠다.
            [참조링크 : ]    
            [참조링크 : ]              
        [추가사항]    
            ㅁ       
    (3).실제로 log를 사용하는 위치(controlleradvice)와 logger 태그의 name 영역 그리고 레벨에 대해 다시한번 얘기하도록 하겠다.(그니까 실 사용에 대해 + controlleradvice도 정리)
        (3-1).
            [참조링크 : ]    
        (3-2).              
            [참조링크 : ]                               
    (4).로드밸런서 연결해서 콘솔창에 대해서도 간단하게 정리
        [직접해봄]    
    (5).그렇다면, 마지막으로 실질적으로 나는 어떠한 디렉토리영역에서 어떠한 레벨들을 분류하고 어떤 매체(이메일,콘솔,sentry,슬랙)를 이용해서
        로그를 관리할지를 정리하겠다. 우선은 첫번째로 root 디렉토리에서 info레벨이상은 모두 console로 받으려고 한다. 그래야지 구체적으로
        [직접해봄]    @@@@@@@@@@@@@@@이것도 로드밸런서 어떻게 뜨는지 확인하고 정확하게 정리
        +
        그런데, 직접해본 결과 만약에 logback-spring.xml파일에서 오류가 나게되어 프로젝트 자체가 정상적으로 실행이 되지 않게되면,
        그것도 사실은 오류 에러 로그인데, 이게 센트리나 슬랙으로 아예 에러알람이 오지 않았었다. 인텔리제이 콘솔에는 떳었다. 즉, 이렇게
        아예 로그백 설정이 제대로 되지않고 스프링부트 차원에서 에러나 예외가 발생하면 로그백설정에 되있는대로(내가 직접해본것은 콘솔,센트리,슬랙이였다.) 
        로그를 보내지는 않는것같다. 당연히 위의 로그백설정에서 한 콘솔,센트리,슬랙에 모두 로그를 보내지 않았는데, 기본적으로 인텔리제이 창에 뜨는 에러
        로그들은 로그백 설정을 하지 않아도 기본적으로 뜨는 에러로그로 보고있다. 그렇다면, 이 부분도 로드밸런서의 콘솔에 그대로 뜨@@@@@@@@@@@@@@@@@@@@@
        [직접해봄]     @@@@@@@@@@@@@@@2 이거 로드밸런서 콘솔에 뜨는지 확인 ************아니야 이건 빌드자체가 실패한거로 보이는데, 빌드에 대한 정확한
        내용도 이해해야겠다. 빌드할때 뜨는 에러는 또 따로 있을듯
.
.
.
[추가사항]    
    1.System.out.println() 사용에 대해서 정리하도록 하자. 우선, 개발단계에서는 이 System.out.println을 많이
        사용하곤한다. 하지만, 이것을 사용하게되면, 굉장한 성능저하가 오기때문에 실제 서비스에서는 사용하지말아야한다고 한다.
        그 이유는 간략하게 이해만 되게 설명하자면(정확히는 아닐 수 있다.) System.out.println()메서드를 사용하게 되면 이 메서드는
        리소스를 많이 차지하게 되고, 그로인해 CPU를 많이 점유하기때문에 성능이 매우 떨어진다고 한다. 이 System.out.println()을
        파일이나 콘솔에 찍을때 완전히 출력되거나 저장할때까지 어플리케이션의 대기시간이 발생한다고 한다. 만약에 더 자세하게 많이
        알아야 한다면 그때가서 다시 정리하도록 하자.
        [참조링크 : https://ram2ram2.tistory.com/7] / System.out.println은 리소스를 많이 먹는다.   
        [참조링크 : https://donggov.tistory.com/53] / System.out.println은 리소스를 많이 먹는다.   
        [참조링크 : https://programmer93.tistory.com/46] / System.out.println은 IO리소스를 많이 먹는다.    
        [참조링크 : https://blog.fitz.software/81] / System.out.println은 CPU를 많이 점유하여 성능이 매우 떨어진다.    
        +
        그래서 실제 사용에서는 System.out.println()으로 로그를 사용하지 않고, 그 외의 용도로도 사용하지 않고 로그를
        남기는거에서 logback이나 다른 로깅 구현체등을 사용하게 되는것이다.
        [참조링크 : https://donggov.tistory.com/53]    
        [참조링크 : https://m.blog.naver.com/minjincodi/60063653]        
.
.
.